<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="License: MIT Apache License 2.0 docs.rs crates.io Download numbers Github CI Minimum rustc version"><title>asn1_rs - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-6c3ea77c.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="asn1_rs" data-themes="" data-resource-suffix="" data-rustdoc-version="1.86.0 (05f9846f8 2025-03-31)" data-channel="1.86.0" data-search-js="search-581efc7a.js" data-settings-js="settings-6dad6058.js" ><script src="../static.files/storage-3a5871a4.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-4d63596a.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../asn1_rs/index.html">asn1_rs</a><span class="version">0.6.2</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#berder-parsersencoders" title="BER/DER Parsers/Encoders">BER/DER Parsers/Encoders</a></li><li><a href="#berder-parsers" title="BER/DER parsers">BER/DER parsers</a></li><li><a href="#recipes" title="Recipes">Recipes</a><ul><li><a href="#examples" title="Examples">Examples</a></li></ul></li><li><a href="#berder-encoders" title="BER/DER encoders">BER/DER encoders</a><ul><li><a href="#examples-1" title="Examples">Examples</a></li><li><a href="#changes" title="Changes">Changes</a></li></ul></li><li><a href="#references" title="References">References</a></li></ul><h3><a href="#reexports">Crate Items</a></h3><ul class="block"><li><a href="#reexports" title="Re-exports">Re-exports</a></li><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#macros" title="Macros">Macros</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li><li><a href="#derives" title="Derive Macros">Derive Macros</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>asn1_rs</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/asn1_rs/lib.rs.html#1-215">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p><a href="./LICENSE-MIT"><img src="https://img.shields.io/badge/License-MIT-yellow.svg" alt="License: MIT" /></a>
<a href="./LICENSE-APACHE"><img src="https://img.shields.io/badge/License-Apache%202.0-blue.svg" alt="Apache License 2.0" /></a>
<a href="https://docs.rs/asn1-rs"><img src="https://docs.rs/asn1-rs/badge.svg" alt="docs.rs" /></a>
<a href="https://crates.io/crates/asn1-rs"><img src="https://img.shields.io/crates/v/asn1-rs.svg" alt="crates.io" /></a>
<a href="https://crates.io/crates/asn1-rs"><img src="https://img.shields.io/crates/d/asn1-rs.svg" alt="Download numbers" /></a>
<a href="https://github.com/rusticata/asn1-rs/actions"><img src="https://github.com/rusticata/asn1-rs/workflows/Continuous%20integration/badge.svg" alt="Github CI" /></a>
<a href="#rust-version-requirements"><img src="https://img.shields.io/badge/rustc-1.63.0+-lightgray.svg" alt="Minimum rustc version" /></a></p>
<h2 id="berder-parsersencoders"><a class="doc-anchor" href="#berder-parsersencoders">§</a>BER/DER Parsers/Encoders</h2>
<p>A set of parsers/encoders for Basic Encoding Rules (BER [<a href="https://www.itu.int/rec/T-REC-X.690/en" title="ASN.1 encoding rules: Specification of
Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules
(DER).">X.690</a>]) and Distinguished Encoding Rules(DER
[<a href="https://www.itu.int/rec/T-REC-X.690/en" title="ASN.1 encoding rules: Specification of
Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules
(DER).">X.690</a>]) formats, implemented with the <a href="https://github.com/Geal/nom" title="Nom parser combinator framework">nom</a> parser combinator framework.</p>
<p>It is written in pure Rust, fast, and makes extensive use of zero-copy. A lot of care is taken
to ensure security and safety of this crate, including design (recursion limit, defensive
programming), tests, and fuzzing. It also aims to be panic-free.</p>
<p>This crate is a rewrite of <a href="https://crates.io/crates/der-parser">der-parser</a> to propose a more data-oriented API,
and add generalized support for serialization.</p>
<p>Many ideas were borrowed from the <a href="https://github.com/RustCrypto/utils/tree/master/der">crypto/utils/der</a> crate (like
the <code>Any</code>/<code>TryFrom</code>/<code>FromDer</code> mechanism), adapted and merged into a generalized BER/DER crate.
Credits (and many thanks) go to Tony Arcieri for writing the original crate.</p>
<h2 id="berder-parsers"><a class="doc-anchor" href="#berder-parsers">§</a>BER/DER parsers</h2>
<p>BER stands for Basic Encoding Rules, and is defined in [<a href="https://www.itu.int/rec/T-REC-X.690/en" title="ASN.1 encoding rules: Specification of
Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules
(DER).">X.690</a>]. It defines a set of rules to
encode and decode ASN.1 [<a href="http://www.itu.int/rec/T-REC-X.680/en" title="Abstract Syntax Notation One (ASN.1):
Specification of basic notation.">X.680</a>] objects in binary.</p>
<p>[<a href="https://www.itu.int/rec/T-REC-X.690/en" title="ASN.1 encoding rules: Specification of
Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules
(DER).">X.690</a>] also defines Distinguished Encoding Rules (DER), which is BER with added rules to
ensure canonical and unequivocal binary representation of objects.</p>
<p>The choice of which one to use is usually guided by the speficication of the data format based
on BER or DER: for example, X.509 uses DER as encoding representation.</p>
<p>The main traits for parsing are the <a href="trait.FromBer.html" title="trait asn1_rs::FromBer"><code>FromBer</code></a> and <a href="trait.FromDer.html" title="trait asn1_rs::FromDer"><code>FromDer</code></a> traits.
These traits provide methods to parse binary input, and return either the remaining (unparsed) bytes
and the parsed object, or an error.</p>
<p>The parsers follow the interface from <a href="https://github.com/Geal/nom" title="Nom parser combinator framework">nom</a>, and the <a href="type.ParseResult.html" title="type asn1_rs::ParseResult"><code>ParseResult</code></a> object is a specialized version
of <code>nom::IResult</code>. This means that most <code>nom</code> combinators (<code>map</code>, <code>many0</code>, etc.) can be used in
combination to objects and methods from this crate. Reading the nom documentation may
help understanding how to write and combine parsers and use the output.</p>
<p><strong>Minimum Supported Rust Version</strong>: 1.63.0</p>
<h2 id="recipes"><a class="doc-anchor" href="#recipes">§</a>Recipes</h2>
<p>See <a href="doc/recipes/index.html" title="mod asn1_rs::doc::recipes">doc::recipes</a> and <a href="doc/derive/index.html" title="mod asn1_rs::doc::derive">doc::derive</a> for more examples and recipes.</p>
<p>See <a href="doc/debug/index.html" title="mod asn1_rs::doc::debug">doc::debug</a> for advice and tools to debug parsers.</p>
<h3 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h3>
<p>Parse 2 BER integers:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>asn1_rs::{Integer, FromBer};

<span class="kw">let </span>bytes = [ <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x01</span>,
              <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,
];

<span class="kw">let </span>(rem, obj1) = Integer::from_ber(<span class="kw-2">&amp;</span>bytes).expect(<span class="string">"parsing failed"</span>);
<span class="kw">let </span>(rem, obj2) = Integer::from_ber(<span class="kw-2">&amp;</span>bytes).expect(<span class="string">"parsing failed"</span>);

<span class="macro">assert_eq!</span>(obj1, Integer::from_u32(<span class="number">65537</span>));</code></pre></div>
<p>In the above example, the generic <a href="struct.Integer.html" title="struct asn1_rs::Integer"><code>Integer</code></a> type is used. This type can contain integers of any
size, but do not provide a simple API to manipulate the numbers.</p>
<p>In most cases, the integer either has a limit, or is expected to fit into a primitive type.
To get a simple value, just use the <code>from_ber</code>/<code>from_der</code> methods on the primitive types:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>asn1_rs::FromBer;

<span class="kw">let </span>bytes = [ <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x01</span>,
              <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,
];

<span class="kw">let </span>(rem, obj1) = u32::from_ber(<span class="kw-2">&amp;</span>bytes).expect(<span class="string">"parsing failed"</span>);
<span class="kw">let </span>(rem, obj2) = u32::from_ber(<span class="kw-2">&amp;</span>rem).expect(<span class="string">"parsing failed"</span>);

<span class="macro">assert_eq!</span>(obj1, <span class="number">65537</span>);
<span class="macro">assert_eq!</span>(obj2, <span class="number">65536</span>);</code></pre></div>
<p>If the parsing succeeds, but the integer cannot fit into the expected type, the method will return
an <code>IntegerTooLarge</code> error.</p>
<h2 id="berder-encoders"><a class="doc-anchor" href="#berder-encoders">§</a>BER/DER encoders</h2>
<p>BER/DER encoding is symmetrical to decoding, using the traits <code>ToBer</code> and <a href="trait.ToDer.html" title="trait asn1_rs::ToDer"><code>ToDer</code></a> traits.
These traits provide methods to write encoded content to objects with the <code>io::Write</code> trait,
or return an allocated <code>Vec&lt;u8&gt;</code> with the encoded data.
If the serialization fails, an error is returned.</p>
<h3 id="examples-1"><a class="doc-anchor" href="#examples-1">§</a>Examples</h3>
<p>Writing 2 BER integers:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>asn1_rs::{Integer, ToDer};

<span class="kw">let </span><span class="kw-2">mut </span>writer = Vec::new();

<span class="kw">let </span>obj1 = Integer::from_u32(<span class="number">65537</span>);
<span class="kw">let </span>obj2 = Integer::from_u32(<span class="number">65536</span>);

<span class="kw">let _ </span>= obj1.write_der(<span class="kw-2">&amp;mut </span>writer).expect(<span class="string">"serialization failed"</span>);
<span class="kw">let _ </span>= obj2.write_der(<span class="kw-2">&amp;mut </span>writer).expect(<span class="string">"serialization failed"</span>);

<span class="kw">let </span>bytes = <span class="kw-2">&amp;</span>[ <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x01</span>,
               <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,
];
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>writer, bytes);</code></pre></div>
<p>Similarly to <code>FromBer</code>/<code>FromDer</code>, serialization methods are also implemented for primitive types:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>asn1_rs::ToDer;

<span class="kw">let </span><span class="kw-2">mut </span>writer = Vec::new();

<span class="kw">let _ </span>= <span class="number">65537</span>.write_der(<span class="kw-2">&amp;mut </span>writer).expect(<span class="string">"serialization failed"</span>);
<span class="kw">let _ </span>= <span class="number">65536</span>.write_der(<span class="kw-2">&amp;mut </span>writer).expect(<span class="string">"serialization failed"</span>);

<span class="kw">let </span>bytes = <span class="kw-2">&amp;</span>[ <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x01</span>,
               <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,
];
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>writer, bytes);</code></pre></div>
<p>If the parsing succeeds, but the integer cannot fit into the expected type, the method will return
an <code>IntegerTooLarge</code> error.</p>
<h3 id="changes"><a class="doc-anchor" href="#changes">§</a>Changes</h3>
<p>See <code>CHANGELOG.md</code>.</p>
<h2 id="references"><a class="doc-anchor" href="#references">§</a>References</h2>
<ul>
<li>[<a href="http://www.itu.int/rec/T-REC-X.680/en" title="Abstract Syntax Notation One (ASN.1):
Specification of basic notation.">X.680</a>] Abstract Syntax Notation One (ASN.1): Specification of basic notation.</li>
<li>[<a href="https://www.itu.int/rec/T-REC-X.690/en" title="ASN.1 encoding rules: Specification of
Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules
(DER).">X.690</a>] ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical
Encoding Rules (CER) and Distinguished Encoding Rules (DER).</li>
</ul>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><dl class="item-table reexports"><dt id="reexport.Error"><code>pub use crate::<a class="enum" href="enum.Error.html" title="enum asn1_rs::Error">Error</a>;</code></dt><dt id="reexport.SequenceIterator"><code>pub use crate::<a class="struct" href="struct.SequenceIterator.html" title="struct asn1_rs::SequenceIterator">SequenceIterator</a>;</code></dt><dt id="reexport.nom"><code>pub use <a class="mod" href="../nom/index.html" title="mod nom">nom</a>;</code></dt></dl><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="doc/index.html" title="mod asn1_rs::doc">doc</a></dt><dd>Additional documentation: recipes, specific use cases and examples, etc.</dd></dl><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">§</a></h2><dl class="item-table"><dt><a class="macro" href="macro.int.html" title="macro asn1_rs::int">int</a></dt><dd>Helper macro to declare integers at compile-time</dd><dt><a class="macro" href="macro.oid.html" title="macro asn1_rs::oid">oid</a></dt><dd>Helper macro to declare integers at compile-time</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.ASN1DateTime.html" title="struct asn1_rs::ASN1DateTime">ASN1<wbr>Date<wbr>Time</a></dt><dt><a class="struct" href="struct.Any.html" title="struct asn1_rs::Any">Any</a></dt><dd>The <code>Any</code> object is not strictly an ASN.1 type, but holds a generic description of any object
that could be encoded.</dd><dt><a class="struct" href="struct.BerClassFromIntError.html" title="struct asn1_rs::BerClassFromIntError">BerClass<wbr>From<wbr>IntError</a></dt><dt><a class="struct" href="struct.BitString.html" title="struct asn1_rs::BitString">BitString</a></dt><dd>ASN.1 <code>BITSTRING</code> type</dd><dt><a class="struct" href="struct.BmpString.html" title="struct asn1_rs::BmpString">BmpString</a></dt><dd>ASN.1 <code>BMPSTRING</code> type</dd><dt><a class="struct" href="struct.Boolean.html" title="struct asn1_rs::Boolean">Boolean</a></dt><dd>ASN.1 <code>BOOLEAN</code> type</dd><dt><a class="struct" href="struct.EmbeddedPdv.html" title="struct asn1_rs::EmbeddedPdv">Embedded<wbr>Pdv</a></dt><dt><a class="struct" href="struct.EndOfContent.html" title="struct asn1_rs::EndOfContent">EndOf<wbr>Content</a></dt><dd>End-of-contents octets</dd><dt><a class="struct" href="struct.Enumerated.html" title="struct asn1_rs::Enumerated">Enumerated</a></dt><dd>ASN.1 <code>ENUMERATED</code> type</dd><dt><a class="struct" href="struct.GeneralString.html" title="struct asn1_rs::GeneralString">General<wbr>String</a></dt><dd>ASN.1 restricted character string type (<code>GeneralString</code>)</dd><dt><a class="struct" href="struct.GeneralizedTime.html" title="struct asn1_rs::GeneralizedTime">Generalized<wbr>Time</a></dt><dt><a class="struct" href="struct.GraphicString.html" title="struct asn1_rs::GraphicString">Graphic<wbr>String</a></dt><dd>ASN.1 restricted character string type (<code>GraphicString</code>)</dd><dt><a class="struct" href="struct.Header.html" title="struct asn1_rs::Header">Header</a></dt><dd>BER/DER object header (identifier and length)</dd><dt><a class="struct" href="struct.Ia5String.html" title="struct asn1_rs::Ia5String">Ia5String</a></dt><dd>ASN.1 restricted character string type (<code>Ia5String</code>)</dd><dt><a class="struct" href="struct.Integer.html" title="struct asn1_rs::Integer">Integer</a></dt><dd>ASN.1 <code>INTEGER</code> type</dd><dt><a class="struct" href="struct.Null.html" title="struct asn1_rs::Null">Null</a></dt><dd>ASN.1 <code>NULL</code> type</dd><dt><a class="struct" href="struct.NumericString.html" title="struct asn1_rs::NumericString">Numeric<wbr>String</a></dt><dd>ASN.1 restricted character string type (<code>NumericString</code>)</dd><dt><a class="struct" href="struct.ObjectDescriptor.html" title="struct asn1_rs::ObjectDescriptor">Object<wbr>Descriptor</a></dt><dd>ASN.1 restricted character string type (<code>ObjectDescriptor</code>)</dd><dt><a class="struct" href="struct.OctetString.html" title="struct asn1_rs::OctetString">Octet<wbr>String</a></dt><dd>ASN.1 <code>OCTETSTRING</code> type</dd><dt><a class="struct" href="struct.Oid.html" title="struct asn1_rs::Oid">Oid</a></dt><dd>Object ID (OID) representation which can be relative or non-relative.
An example for an OID in string representation is <code>"1.2.840.113549.1.1.5"</code>.</dd><dt><a class="struct" href="struct.OptTaggedParser.html" title="struct asn1_rs::OptTaggedParser">OptTagged<wbr>Parser</a></dt><dd>Helper object to parse TAGGED OPTIONAL types (explicit or implicit)</dd><dt><a class="struct" href="struct.PrintableString.html" title="struct asn1_rs::PrintableString">Printable<wbr>String</a></dt><dd>ASN.1 restricted character string type (<code>PrintableString</code>)</dd><dt><a class="struct" href="struct.Sequence.html" title="struct asn1_rs::Sequence">Sequence</a></dt><dd>The <code>SEQUENCE</code> object is an ordered list of heteregeneous types.</dd><dt><a class="struct" href="struct.SequenceIterator.html" title="struct asn1_rs::SequenceIterator">Sequence<wbr>Iterator</a></dt><dd>An Iterator over binary data, parsing elements of type <code>T</code></dd><dt><a class="struct" href="struct.SequenceOf.html" title="struct asn1_rs::SequenceOf">Sequence<wbr>Of</a></dt><dd>The <code>SEQUENCE OF</code> object is an ordered list of homogeneous types.</dd><dt><a class="struct" href="struct.Set.html" title="struct asn1_rs::Set">Set</a></dt><dd>The <code>SET</code> object is an unordered list of heteregeneous types.</dd><dt><a class="struct" href="struct.SetOf.html" title="struct asn1_rs::SetOf">SetOf</a></dt><dd>The <code>SET OF</code> object is an unordered list of homogeneous types.</dd><dt><a class="struct" href="struct.Tag.html" title="struct asn1_rs::Tag">Tag</a></dt><dd>BER/DER Tag as defined in X.680 section 8.4</dd><dt><a class="struct" href="struct.TaggedParser.html" title="struct asn1_rs::TaggedParser">Tagged<wbr>Parser</a></dt><dt><a class="struct" href="struct.TaggedParserBuilder.html" title="struct asn1_rs::TaggedParserBuilder">Tagged<wbr>Parser<wbr>Builder</a></dt><dd>A builder for parsing tagged values (<code>IMPLICIT</code> or <code>EXPLICIT</code>)</dd><dt><a class="struct" href="struct.TaggedValue.html" title="struct asn1_rs::TaggedValue">Tagged<wbr>Value</a></dt><dd>Helper object for creating <code>FromBer</code>/<code>FromDer</code> types for TAGGED OPTIONAL types</dd><dt><a class="struct" href="struct.TeletexString.html" title="struct asn1_rs::TeletexString">Teletex<wbr>String</a></dt><dd>ASN.1 restricted character string type (<code>TeletexString</code>)</dd><dt><a class="struct" href="struct.UniversalString.html" title="struct asn1_rs::UniversalString">Universal<wbr>String</a></dt><dd>ASN.1 <code>UniversalString</code> type</dd><dt><a class="struct" href="struct.UtcTime.html" title="struct asn1_rs::UtcTime">UtcTime</a></dt><dt><a class="struct" href="struct.Utf8String.html" title="struct asn1_rs::Utf8String">Utf8<wbr>String</a></dt><dd>ASN.1 restricted character string type (<code>Utf8String</code>)</dd><dt><a class="struct" href="struct.VideotexString.html" title="struct asn1_rs::VideotexString">Videotex<wbr>String</a></dt><dd>ASN.1 restricted character string type (<code>VideotexString</code>)</dd><dt><a class="struct" href="struct.VisibleString.html" title="struct asn1_rs::VisibleString">Visible<wbr>String</a></dt><dd>ASN.1 restricted character string type (<code>VisibleString</code>)</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.ASN1TimeZone.html" title="enum asn1_rs::ASN1TimeZone">ASN1<wbr>Time<wbr>Zone</a></dt><dt><a class="enum" href="enum.Class.html" title="enum asn1_rs::Class">Class</a></dt><dd>BER Object class of tag</dd><dt><a class="enum" href="enum.DerConstraint.html" title="enum asn1_rs::DerConstraint">DerConstraint</a></dt><dd>Error types for DER constraints</dd><dt><a class="enum" href="enum.Err.html" title="enum asn1_rs::Err">Err</a></dt><dd>The <code>Err</code> enum indicates the parser was not successful</dd><dt><a class="enum" href="enum.Error.html" title="enum asn1_rs::Error">Error</a></dt><dd>The error type for operations of the <a href="trait.FromBer.html" title="trait asn1_rs::FromBer"><code>FromBer</code></a>,
<a href="trait.FromDer.html" title="trait asn1_rs::FromDer"><code>FromDer</code></a>, and associated traits.</dd><dt><a class="enum" href="enum.Explicit.html" title="enum asn1_rs::Explicit">Explicit</a></dt><dd>A type parameter for <code>EXPLICIT</code> tagged values.</dd><dt><a class="enum" href="enum.Implicit.html" title="enum asn1_rs::Implicit">Implicit</a></dt><dd>A type parameter for <code>IMPLICIT</code> tagged values.</dd><dt><a class="enum" href="enum.Length.html" title="enum asn1_rs::Length">Length</a></dt><dd>BER Object Length</dd><dt><a class="enum" href="enum.Needed.html" title="enum asn1_rs::Needed">Needed</a></dt><dd>Contains information on needed data if a parser returned <code>Incomplete</code></dd><dt><a class="enum" href="enum.OidParseError.html" title="enum asn1_rs::OidParseError">OidParse<wbr>Error</a></dt><dd>An error for OID parsing functions.</dd><dt><a class="enum" href="enum.PdvIdentification.html" title="enum asn1_rs::PdvIdentification">PdvIdentification</a></dt><dt><a class="enum" href="enum.Real.html" title="enum asn1_rs::Real">Real</a></dt><dd>ASN.1 <code>REAL</code> type</dd><dt><a class="enum" href="enum.SerializeError.html" title="enum asn1_rs::SerializeError">Serialize<wbr>Error</a></dt><dd>The error type for serialization operations of the <a href="trait.ToDer.html" title="trait asn1_rs::ToDer"><code>ToDer</code></a> trait.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.AsTaggedExplicit.html" title="trait asn1_rs::AsTaggedExplicit">AsTagged<wbr>Explicit</a></dt><dd>Helper trait for creating tagged EXPLICIT values</dd><dt><a class="trait" href="trait.AsTaggedImplicit.html" title="trait asn1_rs::AsTaggedImplicit">AsTagged<wbr>Implicit</a></dt><dd>Helper trait for creating tagged IMPLICIT values</dd><dt><a class="trait" href="trait.BerChoice.html" title="trait asn1_rs::BerChoice">BerChoice</a></dt><dt><a class="trait" href="trait.CheckDerConstraints.html" title="trait asn1_rs::CheckDerConstraints">Check<wbr>DerConstraints</a></dt><dd>Verification of DER constraints</dd><dt><a class="trait" href="trait.Choice.html" title="trait asn1_rs::Choice">Choice</a></dt><dt><a class="trait" href="trait.DerAutoDerive.html" title="trait asn1_rs::DerAutoDerive">DerAuto<wbr>Derive</a></dt><dd>Trait to automatically derive <code>FromDer</code></dd><dt><a class="trait" href="trait.DerChoice.html" title="trait asn1_rs::DerChoice">DerChoice</a></dt><dt><a class="trait" href="trait.DynTagged.html" title="trait asn1_rs::DynTagged">DynTagged</a></dt><dt><a class="trait" href="trait.FromBer.html" title="trait asn1_rs::FromBer">FromBer</a></dt><dd>Base trait for BER object parsers</dd><dt><a class="trait" href="trait.FromDer.html" title="trait asn1_rs::FromDer">FromDer</a></dt><dd>Base trait for DER object parsers</dd><dt><a class="trait" href="trait.TagKind.html" title="trait asn1_rs::TagKind">TagKind</a></dt><dd>A type parameter for tagged values either <a href="enum.Explicit.html" title="enum asn1_rs::Explicit"><code>Explicit</code></a> or <a href="enum.Implicit.html" title="enum asn1_rs::Implicit"><code>Implicit</code></a>.</dd><dt><a class="trait" href="trait.Tagged.html" title="trait asn1_rs::Tagged">Tagged</a></dt><dt><a class="trait" href="trait.TestValidCharset.html" title="trait asn1_rs::TestValidCharset">Test<wbr>Valid<wbr>Charset</a></dt><dd>Base trait for BER string objects and character set validation</dd><dt><a class="trait" href="trait.ToDer.html" title="trait asn1_rs::ToDer">ToDer</a></dt><dd>Common trait for all objects that can be encoded using the DER representation</dd><dt><a class="trait" href="trait.ToStatic.html" title="trait asn1_rs::ToStatic">ToStatic</a></dt></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.from_nom_error.html" title="fn asn1_rs::from_nom_error">from_<wbr>nom_<wbr>error</a></dt><dd>Flatten all <code>nom::Err</code> variants error into a single error type</dd><dt><a class="fn" href="fn.parse_der_tagged_explicit.html" title="fn asn1_rs::parse_der_tagged_explicit">parse_<wbr>der_<wbr>tagged_<wbr>explicit</a></dt><dt><a class="fn" href="fn.parse_der_tagged_explicit_g.html" title="fn asn1_rs::parse_der_tagged_explicit_g">parse_<wbr>der_<wbr>tagged_<wbr>explicit_<wbr>g</a></dt><dt><a class="fn" href="fn.parse_der_tagged_implicit.html" title="fn asn1_rs::parse_der_tagged_implicit">parse_<wbr>der_<wbr>tagged_<wbr>implicit</a></dt><dt><a class="fn" href="fn.parse_der_tagged_implicit_g.html" title="fn asn1_rs::parse_der_tagged_implicit_g">parse_<wbr>der_<wbr>tagged_<wbr>implicit_<wbr>g</a></dt></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><dl class="item-table"><dt><a class="type" href="type.ApplicationExplicit.html" title="type asn1_rs::ApplicationExplicit">Application<wbr>Explicit</a></dt><dd>A helper object to parse <code>[APPLICATION n] EXPLICIT T</code></dd><dt><a class="type" href="type.ApplicationImplicit.html" title="type asn1_rs::ApplicationImplicit">Application<wbr>Implicit</a></dt><dd>A helper object to parse <code>[APPLICATION n] IMPLICIT T</code></dd><dt><a class="type" href="type.IResult.html" title="type asn1_rs::IResult">IResult</a></dt><dd>Holds the result of parsing functions</dd><dt><a class="type" href="type.OptTaggedExplicit.html" title="type asn1_rs::OptTaggedExplicit">OptTagged<wbr>Explicit</a></dt><dd>A helper object to parse <code>[ n ] EXPLICIT T OPTIONAL</code></dd><dt><a class="type" href="type.OptTaggedImplicit.html" title="type asn1_rs::OptTaggedImplicit">OptTagged<wbr>Implicit</a></dt><dd>A helper object to parse <code>[ n ] IMPLICIT T OPTIONAL</code></dd><dt><a class="type" href="type.ParseResult.html" title="type asn1_rs::ParseResult">Parse<wbr>Result</a></dt><dd>Holds the result of BER/DER serialization functions</dd><dt><a class="type" href="type.PrivateExplicit.html" title="type asn1_rs::PrivateExplicit">Private<wbr>Explicit</a></dt><dd>A helper object to parse <code>[PRIVATE n] EXPLICIT T</code></dd><dt><a class="type" href="type.PrivateImplicit.html" title="type asn1_rs::PrivateImplicit">Private<wbr>Implicit</a></dt><dd>A helper object to parse <code>[PRIVATE n] IMPLICIT T</code></dd><dt><a class="type" href="type.Result.html" title="type asn1_rs::Result">Result</a></dt><dd>A specialized <code>Result</code> type for all operations from this crate.</dd><dt><a class="type" href="type.SerializeResult.html" title="type asn1_rs::SerializeResult">Serialize<wbr>Result</a></dt><dd>Holds the result of BER/DER encoding functions</dd><dt><a class="type" href="type.SetIterator.html" title="type asn1_rs::SetIterator">SetIterator</a></dt><dd>An Iterator over binary data, parsing elements of type <code>T</code></dd><dt><a class="type" href="type.TaggedExplicit.html" title="type asn1_rs::TaggedExplicit">Tagged<wbr>Explicit</a></dt><dd>A helper object to parse <code>[ n ] EXPLICIT T</code></dd><dt><a class="type" href="type.TaggedImplicit.html" title="type asn1_rs::TaggedImplicit">Tagged<wbr>Implicit</a></dt><dd>A helper object to parse <code>[ n ] IMPLICIT T</code></dd></dl><h2 id="derives" class="section-header">Derive Macros<a href="#derives" class="anchor">§</a></h2><dl class="item-table"><dt><a class="derive" href="derive.BerAlias.html" title="derive asn1_rs::BerAlias">BerAlias</a></dt><dd>BerAlias custom derive</dd><dt><a class="derive" href="derive.BerSequence.html" title="derive asn1_rs::BerSequence">BerSequence</a></dt><dd>BerSequence custom derive</dd><dt><a class="derive" href="derive.BerSet.html" title="derive asn1_rs::BerSet">BerSet</a></dt><dd>BerSet custom derive</dd><dt><a class="derive" href="derive.DerAlias.html" title="derive asn1_rs::DerAlias">DerAlias</a></dt><dd>DerAlias custom derive</dd><dt><a class="derive" href="derive.DerSequence.html" title="derive asn1_rs::DerSequence">DerSequence</a></dt><dd>DerSequence custom derive</dd><dt><a class="derive" href="derive.DerSet.html" title="derive asn1_rs::DerSet">DerSet</a></dt><dd>DerSet custom derive</dd></dl></section></div></main></body></html>