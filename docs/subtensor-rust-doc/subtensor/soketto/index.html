<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="An implementation of the RFC 6455 websocket protocol."><title>soketto - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-6c3ea77c.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="soketto" data-themes="" data-resource-suffix="" data-rustdoc-version="1.86.0 (05f9846f8 2025-03-31)" data-channel="1.86.0" data-search-js="search-581efc7a.js" data-settings-js="settings-6dad6058.js" ><script src="../static.files/storage-3a5871a4.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-4d63596a.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../soketto/index.html">soketto</a><span class="version">0.8.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#client-example" title="Client example">Client example</a></li><li><a href="#server-example" title="Server example">Server example</a></li></ul><h3><a href="#reexports">Crate Items</a></h3><ul class="block"><li><a href="#reexports" title="Re-exports">Re-exports</a></li><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>soketto</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/soketto/lib.rs.html#10-189">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>An implementation of the <a href="https://tools.ietf.org/html/rfc6455">RFC 6455</a> websocket protocol.</p>
<p>To begin a websocket connection one first needs to perform a <a href="https://tools.ietf.org/html/rfc6455#section-4">handshake</a>,
either as <a href="handshake/client/struct.Client.html" title="struct soketto::handshake::client::Client">client</a> or <a href="handshake/server/struct.Server.html" title="struct soketto::handshake::server::Server">server</a>, in order to upgrade from HTTP.
Once successful, the client or server can transition to a connection,
i.e. a <a href="connection/struct.Sender.html" title="struct soketto::connection::Sender">Sender</a>/<a href="connection/struct.Receiver.html" title="struct soketto::connection::Receiver">Receiver</a> pair and send and receive textual or
binary data.</p>
<p><strong>Note</strong>: While it is possible to only receive websocket messages it is
not possible to only send websocket messages. Receiving data is required
in order to react to control frames such as PING or CLOSE. While those will be
answered transparently they have to be received in the first place, so
calling <a href="connection/struct.Receiver.html#method.receive" title="method soketto::connection::Receiver::receive"><code>connection::Receiver::receive</code></a> is imperative.</p>
<p><strong>Note</strong>: None of the <code>async</code> methods are safe to cancel so their <code>Future</code>s
must not be dropped unless they return <code>Poll::Ready</code>.</p>
<h2 id="client-example"><a class="doc-anchor" href="#client-example">§</a>Client example</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>soketto::handshake::{Client, ServerResponse};

<span class="comment">// First, we need to establish a TCP connection.
</span><span class="kw">let </span>socket = tokio::net::TcpStream::connect(<span class="string">"..."</span>).<span class="kw">await</span><span class="question-mark">?</span>;

<span class="comment">// Then we configure the client handshake.
</span><span class="kw">let </span><span class="kw-2">mut </span>client = Client::new(socket.compat(), <span class="string">"..."</span>, <span class="string">"/"</span>);

<span class="comment">// And finally we perform the handshake and handle the result.
</span><span class="kw">let </span>(<span class="kw-2">mut </span>sender, <span class="kw-2">mut </span>receiver) = <span class="kw">match </span>client.handshake().<span class="kw">await</span><span class="question-mark">? </span>{
    ServerResponse::Accepted { .. } =&gt; client.into_builder().finish(),
    ServerResponse::Redirect { status_code, location } =&gt; <span class="macro">unimplemented!</span>(<span class="string">"follow location URL"</span>),
    ServerResponse::Rejected { status_code } =&gt; <span class="macro">unimplemented!</span>(<span class="string">"handle failure"</span>)
};

<span class="comment">// Over the established websocket connection we can send
</span>sender.send_text(<span class="string">"some text"</span>).<span class="kw">await</span><span class="question-mark">?</span>;
sender.send_text(<span class="string">"some more text"</span>).<span class="kw">await</span><span class="question-mark">?</span>;
sender.flush().<span class="kw">await</span><span class="question-mark">?</span>;

<span class="comment">// ... and receive data.
</span><span class="kw">let </span><span class="kw-2">mut </span>data = Vec::new();
receiver.receive_data(<span class="kw-2">&amp;mut </span>data).<span class="kw">await</span><span class="question-mark">?</span>;

</code></pre></div>
<h2 id="server-example"><a class="doc-anchor" href="#server-example">§</a>Server example</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>soketto::{handshake::{Server, ClientRequest, server::Response}};

<span class="comment">// First, we listen for incoming connections.
</span><span class="kw">let </span>listener = tokio::net::TcpListener::bind(<span class="string">"..."</span>).<span class="kw">await</span><span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>incoming = TcpListenerStream::new(listener);

<span class="kw">while let </span><span class="prelude-val">Some</span>(socket) = incoming.next().<span class="kw">await </span>{
    <span class="comment">// For each incoming connection we perform a handshake.
    </span><span class="kw">let </span><span class="kw-2">mut </span>server = Server::new(socket<span class="question-mark">?</span>.compat());

    <span class="kw">let </span>websocket_key = {
        <span class="kw">let </span>req = server.receive_request().<span class="kw">await</span><span class="question-mark">?</span>;
        req.key()
    };

    <span class="comment">// Here we accept the client unconditionally.
    </span><span class="kw">let </span>accept = Response::Accept { key: websocket_key, protocol: <span class="prelude-val">None </span>};
    server.send_response(<span class="kw-2">&amp;</span>accept).<span class="kw">await</span><span class="question-mark">?</span>;

    <span class="comment">// And we can finally transition to a websocket connection.
    </span><span class="kw">let </span>(<span class="kw-2">mut </span>sender, <span class="kw-2">mut </span>receiver) = server.into_builder().finish();

    <span class="kw">let </span><span class="kw-2">mut </span>data = Vec::new();
    <span class="kw">let </span>data_type = receiver.receive_data(<span class="kw-2">&amp;mut </span>data).<span class="kw">await</span><span class="question-mark">?</span>;

    <span class="kw">if </span>data_type.is_text() {
        sender.send_text(std::str::from_utf8(<span class="kw-2">&amp;</span>data)<span class="question-mark">?</span>).<span class="kw">await</span><span class="question-mark">?
    </span>} <span class="kw">else </span>{
        sender.send_binary(<span class="kw-2">&amp;</span>data).<span class="kw">await</span><span class="question-mark">?
    </span>}

    sender.close().<span class="kw">await</span><span class="question-mark">?
</span>}

</code></pre></div>
<p>See <code>examples/hyper_server.rs</code> from this crate’s repository for an example of
starting up a WebSocket server alongside an Hyper HTTP server.</p>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><dl class="item-table reexports"><dt id="reexport.Mode"><code>pub use connection::<a class="enum" href="connection/enum.Mode.html" title="enum soketto::connection::Mode">Mode</a>;</code></dt><dt id="reexport.Receiver"><code>pub use connection::<a class="struct" href="connection/struct.Receiver.html" title="struct soketto::connection::Receiver">Receiver</a>;</code></dt><dt id="reexport.Sender"><code>pub use connection::<a class="struct" href="connection/struct.Sender.html" title="struct soketto::connection::Sender">Sender</a>;</code></dt><dt id="reexport.Data"><code>pub use data::<a class="enum" href="data/enum.Data.html" title="enum soketto::data::Data">Data</a>;</code></dt><dt id="reexport.Incoming"><code>pub use data::<a class="enum" href="data/enum.Incoming.html" title="enum soketto::data::Incoming">Incoming</a>;</code></dt></dl><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="base/index.html" title="mod soketto::base">base</a></dt><dd>A websocket <a href="https://tools.ietf.org/html/rfc6455#section-5.2">base frame</a> codec.</dd><dt><a class="mod" href="connection/index.html" title="mod soketto::connection">connection</a></dt><dd>A persistent websocket connection after the handshake phase, represented
as a <a href="connection/struct.Sender.html" title="struct soketto::connection::Sender"><code>Sender</code></a> and <a href="connection/struct.Receiver.html" title="struct soketto::connection::Receiver"><code>Receiver</code></a> pair.</dd><dt><a class="mod" href="data/index.html" title="mod soketto::data">data</a></dt><dd>Types describing various forms of payload data.</dd><dt><a class="mod" href="extension/index.html" title="mod soketto::extension">extension</a></dt><dd>Websocket extensions as per <a href="https://tools.ietf.org/html/rfc6455#section-9">RFC 6455</a>.</dd><dt><a class="mod" href="handshake/index.html" title="mod soketto::handshake">handshake</a></dt><dd>Websocket <a href="https://tools.ietf.org/html/rfc6455#section-4">handshake</a>s.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.Parsing.html" title="enum soketto::Parsing">Parsing</a></dt><dd>A parsing result.</dd><dt><a class="enum" href="enum.Storage.html" title="enum soketto::Storage">Storage</a></dt><dd>A buffer type used for implementing <code>Extension</code>s.</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><dl class="item-table"><dt><a class="type" href="type.BoxedError.html" title="type soketto::BoxedError">Boxed<wbr>Error</a></dt></dl><script type="text/json" id="notable-traits-data">{"&[u8]":"<h3>Notable traits for <code>&amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.86.0/std/primitive.u8.html\">u8</a>]</code></h3><pre><code><div class=\"where\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.86.0/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for &amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.86.0/std/primitive.u8.html\">u8</a>]</div>"}</script></section></div></main></body></html>