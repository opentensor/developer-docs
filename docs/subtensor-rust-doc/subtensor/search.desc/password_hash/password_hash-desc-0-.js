searchState.loadedDescShard("password_hash", 0, "RustCrypto: Password Hashing Traits\n“B64” encoding: standard Base64 without padding.\nMaximum length of <code>Output</code> when encoded as B64 string: …\nbcrypt encoding.\n<code>crypt(3)</code> encoding.\nType used to represent decimal (i.e. integer) values.\nBase64 encoding variants.\nAlgorithm or parameter identifier.\nMaximum length of <code>Output</code> string: 64-bytes.\nMaximum length of a <code>Salt</code> string: 64-bytes.\nMaximum length of an <code>Value</code> - 64 ASCII characters (i.e. …\nMinimum length of a <code>Output</code> string: 10-bytes.\nMinimum length of a <code>Salt</code> string: 4-bytes.\nTrait for password hashing algorithms which support the …\nOutput from password hashing functions, i.e. the “hash”…\nAlgorithm-specific parameters.\nAlgorithm parameter string.\nPassword hash.\nSerialized <code>PasswordHash</code>.\nTrait for password hashing functions.\nTrait for password verification.\nRecommended length of a salt: 16-bytes.\nSalt string.\nOwned stack-allocated equivalent of <code>Salt</code>.\nAlgorithm parameter value string.\nAdd the given byte value to the <code>ParamsString</code>, encoding it …\nAdd a key/value pair with a decimal value to the …\nAdd a key/value pair with a string value to the …\nPassword hashing algorithm identifier.\nPassword hashing algorithm identifier.\nBorrow the output value as a byte slice.\nBorrow the contents of this <code>ParamsString</code> as a byte slice.\nBorrow this value as bytes.\nBorrow this value as bytes.\nBorrow the contents of a <code>SaltString</code> as a <code>Salt</code>.\nBorrow this ident as a <code>str</code>\nBorrow the contents of this <code>ParamsString</code> as a <code>str</code>.\nBorrow this value as a <code>str</code>.\nBorrow the contents of a <code>SaltString</code> as a <code>str</code>.\nBorrow this value as a <code>str</code>.\nBorrow this value as a <code>str</code>.\nParse B64-encoded <code>Output</code>, i.e. using the PHC string …\nAttempt to decode a B64-encoded <code>Salt</code> into bytes, writing …\nDecode this <code>SaltString</code> from B64 into the provided output …\nAttempt to decode a B64-encoded <code>Value</code>, writing the decoded …\nWrite B64-encoded <code>Output</code> to the provided buffer, returning …\nEncode the given byte slice as B64 into a new <code>SaltString</code>.\nGet the length of this <code>Output</code> when encoded as B64.\nAttempt to parse this <code>Value</code> as a PHC-encoded decimal (i.e. …\nDecode a Base64 string into the provided destination …\nDecode the given input string using the specified <code>Encoding</code>.\nAttempt to decode a B64-encoded <code>Salt</code> into bytes, writing …\nDecode this <code>SaltString</code> from B64 into the provided output …\nEncode the input byte slice as Base64.\nEncode this <code>Output</code> using the specified <code>Encoding</code>.\nEncode the given byte slice as B64 into a new <code>SaltString</code>.\nGet the length of Base64 produced by encoding the given …\nGet the <code>Encoding</code> that this <code>Output</code> is serialized with.\nGet the <code>Encoding</code> that this <code>PasswordHash</code> is serialized with.\nGet the <code>Encoding</code> that this <code>PasswordHashString</code> is …\nError types.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a <code>Salt</code> from the given B64-encoded input string, …\nCreate a new <code>SaltString</code> from the given B64-encoded input …\nGenerate a random B64-encoded <code>SaltString</code>.\nGenerate a password hash using the supplied algorithm.\nGet a parameter <code>Value</code> by name.\nGet a parameter as a <code>Decimal</code>.\nGet a parameter as a <code>str</code>.\nPassword hashing function <code>Output</code>, a.k.a. hash/digest.\nPassword hashing function <code>Output</code>, a.k.a. hash/digest.\nSimple API for computing a <code>PasswordHash</code> from a password and\nSimple API for computing a <code>PasswordHash</code> from a password and\nCompute a <code>PasswordHash</code> from the provided password using an …\nInitialize an <code>Output</code> using the provided method, which is …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDoes this value parse successfully as a decimal?\nIs this set of parameters empty?\nIs this value empty?\nIterate over the parameters.\nGet the length of the output value as a byte slice.\nGet the count of the number ASCII characters in this …\nGet the length of this value in ASCII characters.\nGet the length of this value in ASCII characters.\nGet the length of this value in ASCII characters.\nGet the length of this value in ASCII characters.\nParse an <code>Ident</code> from a string.\nCreate a <code>Output</code> from the given byte slice, validating it …\nCreate new empty <code>ParamsString</code>.\nCreate a <code>Salt</code> from the given B64-encoded input string, …\nCreate a new <code>SaltString</code> from the given B64-encoded input …\nParse a <code>Value</code> from the provided <code>str</code>, validating it …\nParse a password hash from a string in the PHC string …\nParse a password hash from a string in the PHC string …\nParse an <code>Ident</code> from a string, panicking on parse errors.\nCreate a <code>Output</code> from the given byte slice and <code>Encoding</code>, …\nAlgorithm-specific parameters.\nAlgorithm-specific parameters.\nParse a password hash from the given <code>Encoding</code>.\nParse a password hash from the given <code>Encoding</code>.\nParse this owned string as a <code>PasswordHash</code>.\n<code>Salt</code> string for personalizing a password hash output.\n<code>Salt</code> string for personalizing a password hash output.\nSerialize this <code>PasswordHash</code> as a <code>PasswordHashString</code>.\nUpgrade an MCF hash to a PHC hash. MCF follow this rough …\nVerify a password hash in MCF format against the provided …\nVerify a password hash in MCF format against the provided …\nCompute this password hashing function against the …\nVerify this password hash using the specified set of …\nOptional version field.\nOptional version field.\nUnsupported algorithm.\n“B64” encoding error.\nGeneric error, union of <code>InvalidLengthError</code> and …\nCryptographic error.\nContains the error value\nPassword hashing errors.\nCharacter is not in the allowed set.\nInvalid encoding of provided Base64 string.\nFormat is invalid.\nInsufficient output buffer length.\nParse errors relating to invalid parameter values or salts.\nValue is malformed.\nContains the success value\nOutput size unexpected.\nDuplicate parameter name encountered.\nInvalid parameter name.\nInvalid parameter value.\nMaximum number of parameters exceeded.\nInvalid password.\nPassword hash string invalid.\nPassword hash string contains trailing data.\nResult type.\nSalt invalid.\nValue exceeds the maximum allowed length.\nValue does not satisfy the minimum length.\nInvalid algorithm version.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate an <code>Error::ParamValueInvalid</code> which warps this error.\nCreate an <code>Error::SaltInvalid</code> which wraps this error.\nExpected output size in relation to <code>provided</code>.\nIndicates why the output size is unexpected.")