searchState.loadedDescShard("mixnet", 0, "A mixnet loosely based on Loopix.\nMixnet core logic.\nA mixnode may receive the same request multiple times due …\nFor more reliable delivery, a <code>RequestManager</code> can be used …\nA packet plus the ID of the peer it should be sent to.\nAn out-of-range mixnode index was encountered.\nBad SURB.\nMixnet configuration.\nGenerate cover traffic to the current session’s mixnode …\nOnly send cover (and forwarded) traffic to the previous …\nThe current session.\nUnitless delay. Can be converted to a <code>Duration</code> with …\nDisconnect the previous session’s mixnode set.\nFlags to indicate events that have occurred. Note that …\nSize in bytes of a <code>KxPublic</code>.\nKey-exchange public key.\nAn <em>unclamped</em> key-exchange secret key.\nMaximum number of hops a packet can traverse. Sending a …\nMaximum valid mixnode index.\nSize in bytes of a <code>MessageId</code>.\nA message received over the mixnet.\nMessage identifier. Should be randomly generated. Attached …\nMixnet core state. <code>X</code> is the type of the extra data stored …\nPer-mixnode data.\nThe index of a mixnode in a session’s mixnode list. The …\nError querying the mixnodes for a session.\nThe effective deadline returned by …\nThe deadline returned by …\nA trait for querying the peer ID and connectivity of the …\nThe local node has not managed to connect to any gateway …\nNot enough space in the authored packet queue.\nSize in bytes of a <code>Packet</code>.\nSize in bytes of a <code>PeerId</code>.\nType for packets sent between nodes. Note that all packets …\nGlobally unique identifier for a network peer. This is …\nPermanent error. The query will never succeed. Disable the …\nRequest/reply posting error.\nThe previous session.\nThe reserved peers returned by <code>Mixnet::reserved_peers</code> have …\nRaw mixnode index type, not guaranteed to be &lt;= …\nRelative session index.\nA reply to a previously sent request.\nA reply to a previously sent request.\nA request from another node.\nA request from another node.\nMetrics that can be used to estimate a request’s …\nBuild requests using the current session’s mixnode set. …\nSpace has become available in an authored packet queue.\nSize in bytes of a <code>Surb</code>.\nA concatenation of multiple slices. The slices are not …\nConfiguration that can vary between sessions depending on …\nMixnet disabled for the session.\nAbsolute session index.\nMixnodes not yet known for the session.\nThe session is no longer active.\nThe session is not active yet.\nEach session should progress through these phases in order.\nThe index and phase of the current session.\nA “single-use reply block”. This should be treated as …\nThere aren’t enough mixnodes.\nMessage contents too large or too many SURBs.\nTopology error.\nTopology error.\nTransient error. The query might succeed later. Do not …\nReturns the set containing all flags.\nShould we allow pushing to and popping from the authored …\nAuthored packet queue configuration.\nA conservative estimate of the total delay through the …\nReturns the intersection between the two sets of flags.\nDisables all flags disabled in the set.\nReturns the union of the two sets of flags.\nAdds the set of flags.\nReturns the raw value of the flags currently stored.\nReturns the left flags, but with all the right flags …\nToggles the set of flags.\nReturns the complement of this set of flags.\nReturns <code>true</code> if all of the flags in <code>other</code> are contained …\nCopy all elements into <code>dst</code>. <code>dst.len()</code> must equal <code>self.len()</code>…\nIndex of the current session.\nThe message contents.\nThe message contents.\nWhich session should requests be built for by default?\nReturns the difference between the flags in <code>self</code> and <code>other</code>.\nReturns an empty set of flags.\nReturns a conservative estimate of the round-trip time, …\nReturns a random delay sampled from an exponential …\nExtra data; for use by the crate user.\nMaximum number of packets waiting for their forwarding …\nThe maximum total forwarding delay for any request …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from underlying bit representation, unless that …\nConvert from underlying bit representation, dropping any …\nConvert from underlying bit representation, preserving all …\nReturns the <code>RelSessionIndex</code> corresponding to <code>session_index</code>…\nGenerate cover packets? This option is intended for …\nGet the raw index out. This will always be &lt;= …\nHandle an incoming packet. If the packet completes a …\nMessage identifier, explicitly provided by the request …\nInserts the specified flags in-place.\nReturns the intersection between the flags in <code>self</code> and …\nReturns <code>true</code> if there are flags common to both <code>self</code> and …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if all flags are currently set.\nReturns <code>true</code> iff the local node is currently connected to …\nReturns <code>true</code> if there are no elements.\nReturns <code>true</code> if no flags are currently stored.\nKey-exchange public key for the mixnode.\nReturns the total number of elements.\nReturns the peer ID of the local node.\nThe target for log messages.\nProportion of authored packets which should be loop cover …\nMaximum number of fragments per message. This should …\nMaximum number of fragments to keep across all incomplete …\nMaximum number of incomplete messages to keep.\nSets the mixnodes for the specified session, if they are …\nMean period between authored packet dispatches for the …\nMean forwarding delay at each mixnode. This should really …\nUsed by sessions in which the local node is a mixnode. If …\nIs the previous session still needed?\nCreate a new <code>Mixnet</code>.\nReturns the delay after which <code>pop_next_authored_packet</code> …\nReturns the next instant at which <code>pop_next_forward_packet</code> …\nReturns the key-exchange public key for the next session.\nUsed by sessions in which the local node is not a mixnode. …\nReturns the complement of this set of flags.\nThe number of mixnodes to connect to when we are not a …\nThe maximum number of hops for any of the fragments to …\nNumber of hops for packets to traverse. Some packets may …\nThe packet contents.\nWhere the packet should be sent.\nPeer ID for the mixnode.\nConservative estimate of the network (and processing) …\nConservative estimate of the network (and processing) …\nCurrent session phase.\nEither generate and return a cover packet or pop and …\nPop and return the packet at the head of the forward …\nPost a reply message using SURBs. The session index must …\nPost a request message. If <code>destination_index</code> is <code>None</code>, a …\nRemoves the specified flags in-place.\nID of the request message this reply was sent in response …\nReturns the mixnodes we should try to maintain connections …\nThe key-exchange secret key to use in session 0. This …\nIndex of the session this message was received in. This …\nReturns the current session index and phase.\nInserts or removes the specified flags depending on the …\nSets the current session index and phase. The current and …\nJust like <code>slice::split_at</code>.\nReturns the set difference of the two sets of flags.\nDisables all flags enabled in the set.\nMaximum number of outstanding SURBs to keep keys for. Must …\nSURBs that were attached to the message. These can be used …\nReturns the symmetric difference between the flags in <code>self</code> …\nClear the event flags. Returns the flags that were cleared.\nConvert the unitless delay into a <code>Duration</code> by multiplying …\nCopy all elements to a new <code>Vec</code>.\nToggles the specified flags in-place.\nReturns the union of between the flags in <code>self</code> and <code>other</code>.\nReturns a delay of zero time.\nReply manager configuration.\nContext needed to reply to a request.\nReply manager state.\nAbandon a request. This should be called if you do not …\nMaximum number of requests to remember. When this limit is …\nComplete a request. This will post the reply and cache it …\nAfter replying to a request, ignore repeats of the request …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAttempt to insert a request.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe target for log messages.\nMaximum number of copies of a reply message to post in …\nReturns a reference to the request message ID.\nCreate a new <code>ReplyManager</code> with the given configuration.\nRequest manager configuration.\nOpaque context type; a <code>&amp;Context</code> is passed through …\nRequests managed by a <code>RequestManager</code> must implement this …\nRequest manager state. The user is responsible for calling …\nMaximum number of requests that can be managed at once.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalled if an unrecoverable error is encountered while …\nCalled if we cannot retry posting because the configured …\nReturns a conservative estimate of the handling delay. …\nReturns <code>true</code> iff there is space for another request.\nInsert a request. This should only be called if there is …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new <code>RequestManager</code> with the given configuration.\nReturns the next instant at which <code>pop_next_retry</code> should be …\nReturns <code>true</code> if the next retry deadline (see …\nNumber of times to attempt a destination before moving on …\nNumber of destinations to try sending a request to before …\nNumber of copies of the message to post each time we send …\nReturns the number of SURBs that should be sent along with …\nPop the next request from the internal retry queue. This …\nAttempt to post messages from the internal post queues to …\nRemove a request. Typically this would be called when a …\nUpdate the current session index and phase. This should be …\nCall <code>f</code> with the message data. The same data must be …")