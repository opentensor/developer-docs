searchState.loadedDescShard("rusticata_macros", 0, "Rusticata-macros\nType of serialization error\nCommon trait for structures serialization\nAlign input value to the next multiple of 4 bytes\nAlign input value to the next multiple of n bytes Valid …\nGeneral purpose combinators\nHelper macro for nom parsers: raise error if the condition …\nHelper functions and structures for debugging purpose\nHelper macro for nom parsers: raise error if input is not …\nHelper macro for nom parsers: raise error if the condition …\nCombination and flat_map! and take! as first combinator\nHelper macros\nHelper macro for newtypes: declare associated constants …\nRead a slice as a big-endian value.\nNom combinator that returns the given expression unchanged\nTry to serialize object\nApply combinator, trying to “upgrade” error to next …\nApply combinator, trying to “upgrade” error to next …\nAlign input value to the next multiple of 4 bytes\nAlign input value to the next multiple of n bytes Valid …\nRead the entire slice as a big endian unsigned integer, up …\nRead an entire slice as a big-endian value.\nHelper macro for nom parsers: run first parser if …\nReturn a closure that takes <code>len</code> bytes from input, and …\nTake <code>len</code> bytes from <code>input</code>, and apply <code>parser</code>.\nRead the entire slice as a little endian unsigned integer, …\nRead a slice as a big-endian value.\nCreate a combinator that returns the provided value, and …\nApply combinator, automatically converts between errors if …\nWrapper for printing slice as hex data\nWrapper for printing value as u16 hex data\nWrapper for printing value as u8 hex data\nDump the remaining bytes to stderr, formatted as hex\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRead an entire slice as a big-endian value.\nRead 3 bytes as an unsigned integer")