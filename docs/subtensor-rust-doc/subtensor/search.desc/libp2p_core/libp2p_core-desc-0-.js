searchState.loadedDescShard("libp2p_core", 0, "Transports, upgrades, multiplexing and node handling of …\nRepresentation of a Multiaddr.\nPerform IP address translation.\nCreate a new, empty multiaddress.\nChecks whether the given <code>Multiaddr</code> is a suffix of this …\nConvert a Multiaddr to a string\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if the length of this multiaddress is 0.\nReturns the components of this multiaddress.\nReturn the length in bytes of this multiaddress.\nMulti-address re-export.\nMuxing is the process of splitting a connection into …\nPops the last <code>Protocol</code> of this multiaddr, or <code>None</code> if the …\nReturns &amp;str identifiers for the protocol names themselves.\nAdds an already-parsed address component to the end of …\nReplace a <code>Protocol</code> at some position in this <code>Multiaddr</code>.\nReturn a copy of this <code>Multiaddr</code>’s byte representation.\nConnection-oriented communication channels.\nContains everything related to upgrading a connection or a …\nLike <code>Multiaddr::push</code> but consumes <code>self</code>.\nCreate a new, empty multiaddress with the given capacity.\nAppends the given <code>PeerId</code> if not yet present at the end of …\nThe endpoint roles associated with an established …\nThe socket comes from a dialer.\nWe dialed the node.\nThe endpoint roles associated with a peer-to-peer …\nThe socket comes from a listener.\nWe received the node.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the address of the remote stored in this struct.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs this endpoint a dialer?\nReturns true if we are <code>Dialer</code>.\nIs this endpoint a listener?\nReturns true if we are <code>Listener</code>.\nReturns true if the connection is relayed.\nModifies the address of the remote stored in this struct.\nTurns the <code>ConnectedPoint</code> into the corresponding <code>Endpoint</code>.\nMultiaddress that was successfully dialed.\nLocal connection address.\nWhether the role of the local node on the connection …\nAddress used to send back data to the remote.\nImplements <code>Future</code> and dispatches all method calls to …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe address of the remote has changed.\nError type of the muxer\nProvides multiplexing for a connection by allowing users …\nAbstract <code>StreamMuxer</code>.\nAn event produced by a <code>StreamMuxer</code>.\nExtension trait for <code>StreamMuxer</code>.\nType of the object that represents the raw substream where …\nAbstract type for asynchronous reading and writing.\nReturns a future for closing this <code>StreamMuxer</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTurns a stream muxer into a <code>StreamMuxerBox</code>.\nConstruct a new <code>SubstreamBox</code> from something that …\nPoll to allow the underlying connection to make progress.\nPoll to close this <code>StreamMuxer</code>.\nConvenience function for calling <code>StreamMuxer::poll_close</code> …\nPoll for new inbound substreams.\nConvenience function for calling <code>StreamMuxer::poll_inbound</code> …\nPoll for a new, outbound substream.\nConvenience function for calling <code>StreamMuxer::poll_outbound</code>…\nConvenience function for calling <code>StreamMuxer::poll</code> for …\nFailed to extract the payload from the envelope.\nFailed to decode a multi-address.\nFailed to decode the peer ID.\nFailed to decode the provided bytes as a <code>PeerRecord</code>.\nThe signer of the envelope is different than the peer id …\nRepresents a peer routing record.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAttempt to re-construct a <code>PeerRecord</code> from a <code>SignedEnvelope</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstruct a new <code>PeerRecord</code> by authenticating the provided …\nErrors that occur whilst decoding a <code>SignedEnvelope</code> from …\nDecoding the provided bytes as a signed envelope failed.\nThe public key in the envelope could not be converted to …\nThe signature on the signed envelope does not verify with …\nThe public key in the envelope could not be converted to …\nErrors that occur whilst extracting the payload of a …\nA signed envelope contains an arbitrary byte string …\nThe payload contained in the envelope is not of the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nDecode a <code>SignedEnvelope</code> using the protobuf encoding …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEncode this <code>SignedEnvelope</code> using the protobuf encoding …\nConstructs a new <code>SignedEnvelope</code>.\nExtract the payload and signing key of this <code>SignedEnvelope</code>.\nVerify this <code>SignedEnvelope</code> against the provided …\nAn address is no longer being listened on.\nA <code>Boxed</code> transport is a <code>Transport</code> whose <code>Dial</code>, <code>Listener</code> and …\nA pending <code>Output</code> for an outbound connection, obtained from …\nAn error that occurred during connection setup.\nA connection is incoming on one of the listeners.\nA listener closed.\nA listener errored.\nThe ID of a single listener.\nA pending <code>Output</code> for an inbound connection, obtained from …\nThe <code>Multiaddr</code> passed as parameter is not supported.\nA new address is being listened on.\nTransport that is possibly disabled.\nAny other error that a <code>Transport</code> may produce.\nThe result of a connection setup process, including …\nA transport provides connection-oriented communication …\nAn error during dialing or listening on a <code>Transport</code>.\nEvent produced by <code>Transport</code>s.\nPerforms a transport-specific mapping of an address …\nApplies a function producing an asynchronous result to …\nBoxes the transport, including custom transport errors.\nDials the given <code>Multiaddr</code>, returning a future for a …\nAs <code>Transport::dial</code> but has the local node act as a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTry to turn this transport event into the expire <code>Multiaddr</code>.\nTry to turn this transport event into the upgrade parts of …\nTry to turn this transport event into the listener error.\nTry to turn this transport event into the new <code>Multiaddr</code>.\nReturns <code>true</code> if this is an <code>TransportEvent::AddressExpired</code>.\nReturns <code>true</code> if this is an <code>TransportEvent::ListenerError</code> …\nReturns <code>true</code> if this is a <code>TransportEvent::NewAddress</code>.\nReturns <code>true</code> if this is an <code>Incoming</code> transport event.\nListens on the given <code>Multiaddr</code> for inbound connections …\nApplies a function on the connections created by the …\nApplies a function to the the error in …\nApplies a function on the errors generated by the futures …\nIn case this <code>TransportEvent</code> is an <code>ListenerError</code>, or …\nIn case this <code>TransportEvent</code> is an upgrade, apply the given …\nCreates a new <code>ListenerId</code>.\nCreates a new <code>ListenerId</code>.\nBuilds a disabled <code>OptionalTransport</code>.\nAdds a fallback transport that is used when encountering …\nPoll for <code>TransportEvent</code>s.\nRemove a listener.\nBuilds an <code>OptionalTransport</code> with the given transport in an …\nTransports with timeouts on the connection setup.\nConfiguration of transport protocol upgrades.\nBegins a series of protocol upgrades via an …\nThe error value.\nThe new address that is being listened on.\nThe new address that is being listened on.\nThe listener that is listening on the new address.\nThe listener that is no longer listening on the address.\nThe listener that produced the upgrade.\nThe ID of the listener that closed.\nThe ID of the listener that errored.\nLocal connection address.\nReason for the closure. Contains <code>Ok(())</code> if the stream …\nAddress used to send back data to the incoming client.\nThe produced upgrade.\nSee the <code>Transport::and_then</code> method.\nCustom <code>Future</code> to avoid boxing.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nStruct returned by <code>or_transport()</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nImplementation of <code>AsyncRead</code> and <code>AsyncWrite</code>. Not meant to …\nImplementation of <code>Transport</code> that doesn’t support any …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nBuilds a new <code>DummyTransport</code>.\nDropping all dial requests to non-global IP addresses.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSee <code>Transport::map</code>.\nCustom <code>Future</code> to avoid boxing.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSee <code>Transport::map_err</code>.\nDialing future for <code>MapErr</code>.\nListening upgrade future for <code>MapErr</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTries to listen on a port that is already in use.\nA channel represents an established, in-memory, logical …\nA channel represents an established, in-memory, logical …\nConnection to a <code>MemoryTransport</code> currently being opened.\nListener for memory connections.\nTransport that supports <code>/memory/N</code> multiaddresses.\nError that can be produced from the <code>MemoryTransport</code>.\nThere’s no listener on the given port.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nOther kind of error.\nWraps around a <code>Future</code>. Turns the error type from …\nThe transport timed out.\nAn error happened in the timer.\nA <code>TransportTimeout</code> is a <code>Transport</code> that wraps another …\nError that can be produced by the <code>TransportTimeout</code> layer.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWraps around a <code>Transport</code> to add timeouts to all the …\nWraps around a <code>Transport</code> to add timeouts to the ingoing …\nWraps around a <code>Transport</code> to add timeouts to the outgoing …\nAn upgrade that authenticates the remote peer, typically …\nAn transport with peer authentication, obtained from …\nA <code>Builder</code> facilitates upgrading of a <code>Transport</code> for use with\nThe <code>Transport::Dial</code> future of an <code>Upgrade</code>d transport.\nThe <code>Transport::ListenerUpgrade</code> future of an <code>Upgrade</code>d …\nAn upgrade that negotiates a (sub)stream multiplexer on …\nA authenticated and multiplexed transport, obtained from …\nError in the transport.\nErrors produced by a transport upgrade.\nA custom upgrade on an <code>Authenticated</code> transport.\nError while upgrading to a protocol.\nVersion 1 of the multistream-select protocol. See 1 and 2.\nA “lazy” variant of version 1 that is identical on the …\nSupported multistream-select versions.\nApplies an arbitrary upgrade.\nUpgrades the transport to perform authentication of the …\nBoxes the authenticated, multiplexed transport, including …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAdds a timeout to the setup and protocol upgrade process …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nUpgrades the transport with a (sub)stream multiplexer.\nLike <code>Authenticated::multiplex</code> but accepts a function which …\nCreates a <code>Builder</code> over the given (base) <code>Transport</code>.\nAdds a timeout to the setup and protocol upgrade process …\nAdds a timeout to the setup and protocol upgrade process …\nDummy implementation of <code>UpgradeInfo</code>/<code>InboundUpgrade</code>/…\nPossible error during the handshake.\nPossible error during the handshake.\nPossible error during the handshake.\nPossible error during the handshake.\nProtocol negotiation failed because no protocol could be …\nFuture that performs the handshake with the remote.\nFuture that performs the handshake with the remote.\nFuture that performs the handshake with the remote.\nFuture that performs the handshake with the remote.\nPossible upgrade on an inbound connection\nPossible upgrade on an inbound connection or substream.\nOpaque type representing a negotiable protocol.\nIterator returned by <code>protocol_info</code>.\nReceived an invalid message from the remote.\nA protocol (name) is invalid.\nI/O error.\nA <code>Future</code> that waits on the completion of protocol …\nError that can happen when negotiating a protocol with the …\nPossible upgrade on an outbound connection\nPossible upgrade on an outbound connection or substream.\nOutput after the upgrade has been successfully negotiated …\nOutput after the upgrade has been successfully negotiated …\nOutput after the upgrade has been successfully negotiated …\nOutput after the upgrade has been successfully negotiated …\nImplementation of <code>UpgradeInfo</code>, <code>InboundUpgrade</code> and …\nA protocol error.\nA protocol error occurred during the negotiation.\nImplementation of <code>UpgradeInfo</code>, <code>InboundUpgrade</code> and …\nUpgrade that combines two upgrades into one. Supports all …\nToo many protocols have been returned by the remote.\nCommon trait for upgrades that can be applied on inbound …\nVersion 1 of the multistream-select protocol. See 1 and 2.\nA “lazy” variant of version 1 that is identical on the …\nSupported multistream-select versions.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCombines two upgrades into an <code>SelectUpgrade</code>.\nReturns the list of protocols that are supported. Used …\nReads a length-prefixed message from the given socket.\nReads a variable-length integer from the <code>socket</code>.\nAfter we have determined that the remote supports one of …\nAfter we have determined that the remote supports one of …\nAfter we have determined that the remote supports one of …\nAfter we have determined that the remote supports one of …\nWrites a message to the given socket with a length prefix …\nWrites a variable-length integer to the <code>socket</code>.")