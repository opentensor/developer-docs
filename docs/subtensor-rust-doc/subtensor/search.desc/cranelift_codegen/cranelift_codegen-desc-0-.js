searchState.loadedDescShard("cranelift_codegen", 0, "Cranelift code generation library.\nThe ABI machine spec for this <code>MachInst</code>.\nThe code size for the function is too large.\nA compilation error.\nA convenient alias for a <code>Result</code> that uses <code>CodegenError</code> as …\nCompilation error, with the accompanying function to help …\n<code>CompiledCode</code> in its final form (i.e. after …\nPersistent data structures and compilation pipeline.\nContains the error value\nStatus of a compiled artifact ready to use.\nAn implementation limit was exceeded.\nConstant information used in <code>emit</code> invocations.\nA label-use kind: a type that describes the types of label …\nA buffer of output to be produced, fixed up, and then …\nA <code>MachBuffer</code> once emission is completed: holds generated …\nA call site record resulting from a compilation.\nA machine instruction.\nA trait describing the ability to encode a MachInst into …\nA relocation resulting from a compilation.\nA source-location mapping resulting from a compilation.\nRecord of stack map metadata: stack offsets containing …\nImplementation of the <code>TextSectionBuilder</code> trait backed by …\nA trap record resulting from a compilation.\nContains the success value\nA register named in an instruction. This register can be …\nRegister allocator internal error discovered by the …\nA failure to map Cranelift register representation to a …\nPersistent state carried across <code>emit</code> invocations.\nByte representation of a trap opcode which is inserted by …\nAn object that can be used to create the text section of …\nSomething is not supported by the code generator. This …\nVersion number of this crate.\nResulting map of Value labels and their ranges/locations.\nValue location range.\nA list of IR verifier errors.\nA type wrapper that indicates a register type is writable. …\nAdd a call-site record at the current offset.\nInform the buffer of a conditional branch at the given …\nAdd an external relocation at the current offset.\nAdd stack map metadata for this program point: a set of …\nAdd a trap record at the current offset.\nInform the buffer of an unconditional branch at the given …\nAdd an unwind record at the current offset.\nThe addend to add to the symbol value.\nAlign a basic block offset (from start of function).  By …\nAlign a basic block offset (from start of function).  By …\nAlign up to the given alignment.\nMinimum alignment for the function, derived from the use …\nAppends <code>data</code> to the text section with the <code>align</code> specified.\nGet a finalized machine buffer by applying the function’…\nBasic-block layout info: block edges. Each edge is …\nBasic-block layout info: block start offsets.\nBind a label to the current offset. A label can only be …\nBinary machine code emission.\nMachine code.\nGet the list of call sites for this code.\nGet an appropriate type that can fully hold a value in a …\nPerform NaN canonicalizing rewrites on the function.\nThe control flow graph of <code>func</code>.\nThe <code>CFGPrinter</code> utility.\nGet the class of this register.\nClear all data structures in this context.\nThe trap code.\nCompile the function.\nCompile the function, and emit machine code into a <code>Vec&lt;u8&gt;</code>.\nInternally compiles the function into a stencil.\nReturns the compilation result for this function, …\nCompute the control flow graph.\nCompute dominator tree.\nCompute the loop analysis.\nCreates unwind information for the function.\nCreates unwind information for the function.\nCurrent offset from start of buffer.\nCursor library.\nGet the code bytes.\nThis module gives users to instantiate values that …\nDebug tracing helpers.\nPerform dead-code elimination on the function.\nEmit a constant at some point in the future, binding the …\nEmit a trap at some point in the future with the specified …\nA Dominator Tree represented as mappings of Blocks to …\nDominator tree for <code>func</code>.\nDebug info: stackslots to stack pointer offsets.\nRun optimizations via the egraph infrastructure.\nPerform unreachable code elimination.\nEmit the instruction.\nEmit all pending constants and required pending veneers.\nThe end of the region of code corresponding to a source …\nThe end of the range. It is an offset in the generated …\nMark the end of the <code>SourceLoc</code> segment started at the last …\nCompletes this text section, filling out any final …\nFinish any deferred emissions and/or fixups.\nA control flow graph represented as mappings of basic …\nCompute the control flow graph and dominator tree.\nAllocate a new compilation context with an existing …\nA debug-only option which is used to for\nSize of stack frame, in bytes.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nExplicitly construct a <code>Writable&lt;T&gt;</code> from a <code>T</code>. As noted in …\nThe function we’re compiling.\nFunction we tried to compile, for display purposes.\nGenerate an instruction that must appear at the beginning …\nGenerate an instruction that must appear at the beginning …\nGenerate a dummy instruction that will keep a value alive …\nGenerate a jump to another target. Used during lowering of …\nGenerate a move.\nGenerate a NOP. The <code>preferred_size</code> parameter allows the …\nReserve appended space and return a mutable slice …\nIf available, return information about the code layout in …\nIf available, return information about the code layout in …\nAllocate a <code>Label</code> to refer to some offset. May not be bound …\nRetrieve the reserved label for a constant.\nReturn the registers referenced by this machine …\nGet a list of source location mapping tuples in …\nUnderlying <code>CodegenError</code> that triggered the error.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRepresentation of Cranelift IR functions.\nIs this an “args” pseudoinst?\nShould this instruction be included in the clobber-set?\nIf this is a simple move, return the (source, destination) …\nIs this a real (physical) reg?\nIs this a safepoint?\nIs this a terminator (branch or ret)? If so, return its …\nIs this an unconditional trap?\nIs this a virtual reg?\nInstruction Set Architectures.\nIs an island needed within the next N bytes?\nThe kind of relocation.\nRun the legalizer for <code>isa</code> on the function.\nPerform LICM on the function.\nThe source location.\nThe ValueLoc containing a ValueLabel during this range.\nA loop analysis represented as mappings of loops to their …\nLoop analysis of <code>func</code>.\nMap the underlying register to another value or type.\nThe external symbol / name to which this relocation refers.\nCreate a new section, known to start at <code>start_offset</code> and …\nCreates a new text section builder which will have …\nAllocate a new compilation context.\nThe offset at which the relocation applies, <em>relative to the</em>\nThe offset at which the trap instruction occurs, <em>relative </em>…\nThe code offset at which this stack map applies.\nThe code offset just past the “end” of the …\nThe call’s opcode.\nOptimize the function, performing all compilation steps up …\nCompact representation of <code>Option&lt;T&gt;</code> for types with a …\nPerform pre-legalization rewrites on the function.\nPretty-print the instruction.\nUtility routines for pretty-printing error messages.\nAdd a byte.\nAdd 2 bytes.\nAdd 4 bytes.\nAdd 8 bytes.\nAdd a slice of bytes.\nDetermine register class(es) to store the given Cranelift …\nWhat is the register class used for reference types …\nGet the list of external relocations for this code.\nPerform constant-phi removal on the function.\nReplace all redundant loads with the known values in …\nReserve the first N MachLabels for blocks.\nReserve the next N MachLabels for constants.\nAttempts to resolve a relocation for this function.\nThe offset of the call’s return address, <em>relative to the </em>…\nSet the flag to request a disassembly when compiling with a\nShared settings module.\nPerform simple GVN on the function.\nDebug info: stackslots to stack pointer offsets.\nThe stack map itself.\nGet the stack map metadata for this code.\nThe start of the region of code corresponding to a source …\nThe start of the range. It is an offset in the generated …\nSet the <code>SourceLoc</code> for code from this offset until the …\nReturn the code in this mach buffer as a hex string for …\nPass timing.\nGet the physical register (<code>RealReg</code>), if this register is …\nGet the underlying register, which can be read.\nGet the virtual (non-physical) register, if this register …\nGet the total required size for the code.\nEven when trace logging is disabled, the trace macro has a …\nGet the list of trap records for this code.\nAny unwind info at a given location.\nEmit a reference to the given label with the given …\nDebug info: value labels to registers/stackslots at code …\nDisassembly, if requested.\nA verifier for ensuring that functions are well formed. It …\nRun the verifier on the function.\nRun the verifier only if the <code>enable_verifier</code> setting is …\nFlag: do we want a disassembly with the CompiledCode?\nWhat is the worst-case instruction size emitted by this …\nConverting Cranelift IR to text.\nAArch64 GOT Page Set the immediate value of an ADRP to …\nAArch64 GOT Low bits Set the LD/ST immediate field to bits …\nAarch64 TLS GD Set the add immediate field to the low 12 …\nAarch64 TLS GD Set an ADRP immediate field to the top 21 …\nabsolute 4-byte\nabsolute 8-byte\nAddend to add to the symbol value.\nArm32 call target\nArm64 call target. Encoded as bottom 26 bits of …\nContainer for information about a vector of compiled code …\nOffset in bytes from the beginning of the function.\nElf x86_64 32 bit signed PC relative offset to two GOT …\nMach-O Aarch64 TLS PC-relative distance to the page of the …\nMach-O Aarch64 TLS Offset within page of TLVP slot.\nMach-O x86_64 32 bit signed PC relative offset to a …\nRelocation kinds for every ISA\nprocedure call. call symbol expands to the following …\ns390x PC-relative 4-byte offset\ns390x PC-relative 4-byte offset to PLT\ns390x TLS GD64 - 64-bit offset of tls_index for GD symbol …\ns390x TLS GDCall - marker to enable optimization of TLS …\nStack maps record which words in a stack frame contain …\nx86 call to PC-relative 4-byte\nx86 call to PLT-relative 4-byte\nx86 GOT PC-relative 4-byte\nx86 PC-relative 4-byte\nThe 32-bit offset of the target from the beginning of its …\nReturns the raw bitmap that represents this stack map.\nDisplay trait implementation drops the arch, since its …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a vec of Bitsets from a slice of bools.\nReturns a specified bit.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the number of words represented by this stack map.\nNumber of bytes in total.\nA utility for pretty-printing the CFG of a <code>Function</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new CFGPrinter.\nWrite the CFG for this function to <code>w</code>.\nCursor is pointing after the end of a block. New …\nCursor is pointing at an existing instruction. New …\nCursor is before the beginning of a block. No instructions …\nAll cursor types implement the <code>Cursor</code> which provides …\nThe possible positions of a cursor.\nFunction cursor.\nCursor is not pointing anywhere. No instructions can be …\nRebuild this cursor positioned after <code>inst</code>.\nRebuild this cursor positioned at the bottom of <code>block</code>.\nRebuild this cursor positioned at the first insertion …\nRebuild this cursor positioned at the first instruction in …\nRebuild this cursor positioned at <code>inst</code>.\nRebuild this cursor positioned at the last instruction in …\nRebuild this cursor positioned at <code>pos</code>.\nRebuild this cursor positioned at the top of <code>block</code>.\nGet the block corresponding to the current position.\nGet the instruction corresponding to the current position, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe referenced function.\nGo to the position after a specific instruction, which …\nGo to the bottom of <code>block</code> which must be inserted into the …\nGo to the position for inserting instructions at the …\nGo to the first instruction in <code>block</code>.\nGo to a specific instruction which must be inserted in the …\nGo to the last instruction in <code>block</code>.\nGo to the top of <code>block</code> which must be inserted into the …\nCreate an instruction builder that inserts an instruction …\nInsert a block at the current position and switch to it.\nInsert an instruction at the current position.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nBorrow a reference to the function layout that this cursor …\nBorrow a mutable reference to the function layout that …\nCreate a new <code>FuncCursor</code> pointing nowhere.\nGo to the top of the next block in layout order and return …\nMove to the next instruction in the same block and return …\nGet the current cursor position.\nGo to the bottom of the previous block in layout order and …\nMove to the previous instruction in the same block and …\nRemove the instruction under the cursor.\nRemove the instruction under the cursor.\nSet the current position.\nSet the source location that should be assigned to new …\nGet the source location that should be assigned to new …\nUse the source location of <code>inst</code> for future instructions.\nExchange this cursor for one with a set source location.\nRepresent a data value. Where Value is an SSA reference, …\nRecord failures to cast DataValue.\nHelper structure for printing bracket-enclosed vectors of …\nPerforms a bitwise comparison over the contents of …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTry to cast an immediate integer (a wrapped <code>i64</code> on most …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn true if the value is a vector (i.e. <code>DataValue::V128</code>…\nRead a DataValue from a slice using a given Type in …\nRead a DataValue from a slice using a given Type in …\nRead a DataValue from a slice using a given Type with …\nRead a DataValue from a memory location using a given Type …\nConverts <code>self</code> to big endian from target’s endianness.\nConverts <code>self</code> to little endian from target’s endianness.\nReturn the Cranelift IR Type for this DataValue.\nHelper function for displaying <code>Vec&lt;DataValue&gt;</code>.\nWrite a DataValue to a slice in big-endian byte order.\nWrite a DataValue to a slice in little-endian byte order.\nWrite a DataValue to a slice in native-endian byte order.\nWrite a DataValue to a memory location in native-endian …\nHelper for printing lists.\nPrefix added to the log file names, just before the thread …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAn iterator that enumerates the direct children of a block …\nThe dominator tree for a single function.\nOptional pre-order information that can be computed for a …\nGet the CFG post-order of blocks that was used to compute …\nGet an iterator over the direct children of <code>block</code> in the …\nClear the data structures used to represent the dominator …\nCompute the common dominator of two basic blocks.\nReset and compute a CFG post-order and dominator tree.\nRecompute this data structure to match <code>domtree</code>.\nReturns <code>true</code> if <code>a</code> dominates <code>b</code>.\nFast, constant time dominance check with block granularity.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the immediate dominator of <code>block</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs <code>block</code> reachable from the entry block?\nCheck if the dominator tree is in a valid state.\nFind the last instruction in <code>a</code> that dominates <code>b</code>. If no …\nAllocate a new blank dominator tree. Use <code>compute</code> to …\nCreate a new blank <code>DominatorTreePreorder</code>.\nCompare two program points according to the dominator tree …\nCompare two blocks according to the dominator pre-order.\nCompare two program points relative to a reverse …\nCompare two blocks relative to the reverse post-order.\nAllocate and compute a dominator tree.\nA basic block denoted by its enclosing Block and last …\nThe Control Flow Graph maintains a mapping of blocks to …\nAn iterator over block predecessors. The iterator type is …\nAn iterator over block successors. The iterator type is …\nEnclosing Block key.\nClear all data structures in this control flow graph.\nCompute the control flow graph of <code>func</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nLast instruction in the basic block.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if the CFG is in a valid state.\nAllocate a new blank control flow graph.\nConvenient method to construct new BlockPredecessor.\nGet an iterator over the CFG predecessors to <code>block</code>.\nRecompute the control flow graph of <code>block</code>.\nGet an iterator over the CFG successors to <code>block</code>.\nAllocate and compute the control flow graph for <code>func</code>.\nFunction parameter or return value descriptor.\nAdd\nA value alias to original value.\nAnd\nFunction argument extension options.\nThe special purpose of a function argument.\nAtomicCas(imms=(flags: ir::MemFlags), vals=3, blocks=0)\nAtomicCas(imms=(flags: ir::MemFlags), vals=3, blocks=0)\nAtomicRmw(imms=(flags: ir::MemFlags, op: ir::AtomicRmwOp), …\nAtomicRmw(imms=(flags: ir::MemFlags, op: ir::AtomicRmwOp), …\nDescribes the arithmetic operation in an atomic memory …\nFailed float-to-int conversion.\nSignature mismatch on indirect call.\nBig-endian\nBinary(imms=(), vals=2, blocks=0)\nBinary(imms=(), vals=2, blocks=0)\nBinaryImm64(imms=(imm: ir::immediates::Imm64), vals=1, …\nBinaryImm64(imms=(imm: ir::immediates::Imm64), vals=1, …\nBinaryImm8(imms=(imm: ir::immediates::Uimm8), vals=1, …\nBinaryImm8(imms=(imm: ir::immediates::Uimm8), vals=1, …\nA block header.\nBranchTable(imms=(table: ir::JumpTable), vals=1, blocks=0)\nBranchTable(imms=(table: ir::JumpTable), vals=1, blocks=0)\nBrif(imms=(), vals=1, blocks=2)\nBrif(imms=(), vals=1, blocks=2)\nCall(imms=(func_ref: ir::FuncRef), vals=0, blocks=0)\nCall(imms=(func_ref: ir::FuncRef), vals=0, blocks=0)\nCallIndirect(imms=(sig_ref: ir::SigRef), vals=1, blocks=0)\nCallIndirect(imms=(sig_ref: ir::SigRef), vals=1, blocks=0)\nceil.f32\nceil.f64\nTLS index symbol for the current thread. Used in COFF/PE …\nCondTrap(imms=(code: ir::TrapCode), vals=1, blocks=0)\nCondTrap(imms=(code: ir::TrapCode), vals=1, blocks=0)\nValue is a multiple of how many instances of <code>vector_type</code> …\nDynamicStackLoad(imms=(dynamic_stack_slot: …\nDynamicStackLoad(imms=(dynamic_stack_slot: …\nDynamicStackStore(imms=(dynamic_stack_slot: …\nDynamicStackStore(imms=(dynamic_stack_slot: …\nELF well-known linker symbol <em>GLOBAL_OFFSET_TABLE</em>\nElf __tls_get_addr\nElf __tls_get_offset\nEndianness of a memory access.\nAn external function.\nThe name of an external is either a reference to a …\nFloatCompare(imms=(cond: ir::condcodes::FloatCC), vals=2, …\nFloatCompare(imms=(cond: ir::condcodes::FloatCC), vals=2, …\nfloor.f32\nfloor.f64\nfma.f32\nfma.f64\nFuncAddr(imms=(func_ref: ir::FuncRef), vals=0, blocks=0)\nFuncAddr(imms=(func_ref: ir::FuncRef), vals=0, blocks=0)\nInformation about a global value declaration.\nA wasm atomic operation was presented with a …\nA <code>heap_addr</code> instruction detected an out-of-bounds error.\nValue is an offset from another global value.\nIndirect call to a null table entry.\nBuilder that inserts an instruction at the current …\nAn instruction in the function.\nConvenience methods for building instructions.\nBase trait for instruction builders.\nBase trait for instruction inserters.\nIntAddTrap(imms=(code: ir::TrapCode), vals=2, blocks=0)\nIntAddTrap(imms=(code: ir::TrapCode), vals=2, blocks=0)\nIntCompare(imms=(cond: ir::condcodes::IntCC), vals=2, …\nIntCompare(imms=(cond: ir::condcodes::IntCC), vals=2, …\nIntCompareImm(imms=(cond: ir::condcodes::IntCC, imm: …\nIntCompareImm(imms=(cond: ir::condcodes::IntCC, imm: …\nAn integer division by zero.\nAn integer arithmetic operation caused an overflow.\nExecution has potentially run too long and may be …\nJump(imms=(), vals=0, blocks=1)\nJump(imms=(), vals=0, blocks=1)\nMap of jump tables.\nA well-known symbol.\nA well-known symbol.\nThe particular location for a value.\nThe name of a runtime library routine.\nA well-known runtime library function.\nLittle-endian\nLoad(imms=(flags: ir::MemFlags, offset: …\nLoad(imms=(flags: ir::MemFlags, offset: …\nValue is pointed to by another global value.\nLoadNoOffset(imms=(flags: ir::MemFlags), vals=1, blocks=0)\nLoadNoOffset(imms=(flags: ir::MemFlags), vals=1, blocks=0)\nFlags for memory operations like load/store.\nlibc.memcmp\nlibc.memcpy\nlibc.memmove\nlibc.memset\nMultiAry(imms=(), vals=0, blocks=0)\nMultiAry(imms=(), vals=0, blocks=0)\nNand\nnearest.f32\nnearest.f64\nNo extension, high bits are indeterminate.\nA normal user program value passed to or from a function.\nNullAry(imms=(), vals=0, blocks=0)\nNullAry(imms=(), vals=0, blocks=0)\nOr\nprobe for stack overflow. These are emitted for functions …\nA <code>ProgramPoint</code> represents a position in a function where …\nNew-backend Reg.\nSource location relative to another base source location.\nInstruction builder that replaces an existing instruction.\nNew-backend offset from stack pointer.\nSigned extension: high bits in register replicate sign bit.\nShuffle(imms=(imm: ir::Immediate), vals=2, blocks=0)\nShuffle(imms=(imm: ir::Immediate), vals=2, blocks=0)\nFunction signature.\nSigned max\nSigned min\nA source location.\nA stack limit pointer.\nStackLoad(imms=(stack_slot: ir::StackSlot, offset: …\nStackLoad(imms=(stack_slot: ir::StackSlot, offset: …\nThe current stack space was exhausted.\nStackStore(imms=(stack_slot: ir::StackSlot, offset: …\nStackStore(imms=(stack_slot: ir::StackSlot, offset: …\nOriginal value labels assigned at transform.\nStore(imms=(flags: ir::MemFlags, offset: …\nStore(imms=(flags: ir::MemFlags, offset: …\nStoreNoOffset(imms=(flags: ir::MemFlags), vals=2, blocks=0)\nStoreNoOffset(imms=(flags: ir::MemFlags), vals=2, blocks=0)\nA C struct passed as argument.\nStruct return pointer.\nSub\nValue is symbolic, meaning it’s a name which will be …\nTableAddr(imms=(table: ir::Table, offset: …\nTableAddr(imms=(table: ir::Table, offset: …\nInformation about a table declaration.\nA <code>table_addr</code> instruction detected an out-of-bounds error.\nTernary(imms=(), vals=3, blocks=0)\nTernary(imms=(), vals=3, blocks=0)\nTernaryImm8(imms=(imm: ir::immediates::Uimm8), vals=2, …\nTernaryImm8(imms=(imm: ir::immediates::Uimm8), vals=2, …\nA test case function name of up to a hardcoded amount of …\nA name for a test case, mostly intended for Cranelift …\nTrap(imms=(code: ir::TrapCode), vals=0, blocks=0)\nTrap(imms=(code: ir::TrapCode), vals=0, blocks=0)\nA trap code describing the reason for a trap.\ntrunc.f32\nfrunc.f64\nUnsigned extension: high bits in register are 0.\nUnsigned max\nUnsigned min\nUnary(imms=(), vals=1, blocks=0)\nUnary(imms=(), vals=1, blocks=0)\nUnaryConst(imms=(constant_handle: ir::Constant), vals=0, …\nUnaryConst(imms=(constant_handle: ir::Constant), vals=0, …\nUnaryGlobalValue(imms=(global_value: ir::GlobalValue), …\nUnaryGlobalValue(imms=(global_value: ir::GlobalValue), …\nUnaryIeee32(imms=(imm: ir::immediates::Ieee32), vals=0, …\nUnaryIeee32(imms=(imm: ir::immediates::Ieee32), vals=0, …\nUnaryIeee64(imms=(imm: ir::immediates::Ieee64), vals=0, …\nUnaryIeee64(imms=(imm: ir::immediates::Ieee64), vals=0, …\nUnaryImm(imms=(imm: ir::immediates::Imm64), vals=0, …\nUnaryImm(imms=(imm: ir::immediates::Imm64), vals=0, …\nCode that was supposed to have been unreachable was …\nA user-defined name, with semantics left to the user.\nA reference to a name in a user-defined symbol table.\nA user-defined trap code.\nAn external name in a user-defined symbol table.\nAn explicit name for a user-defined function, be it …\nA VM context pointer.\nValue is the address of the VM context struct.\nMarked with a label value.\nValue label assignements: label starts or value aliases.\nA label of a Value.\nExchange\nXor\nTest if the <code>aligned</code> flag is set.\nReturns a slice with all supported AtomicRmwOp’s.\nGet a list of all known <code>LibCall</code>’s.\nReturn the raw bit encoding for this instance.\nReturn the underlying index value as a <code>u32</code>.\nPerform an atomic compare-and-swap operation on memory at <code>p</code>…\nPerform an atomic compare-and-swap operation on memory at <code>p</code>…\nAtomically load from memory at <code>p</code>.\nAtomically load from memory at <code>p</code>.\nAtomically read-modify-write memory at <code>p</code>, with second …\nAtomically read-modify-write memory at <code>p</code>, with second …\nAtomically store <code>x</code> to memory at <code>p</code>.\nAtomically store <code>x</code> to memory at <code>p</code>.\nUnsigned average with rounding: <code>a := (x + y + 1) // 2</code>\nUnsigned average with rounding: <code>a := (x + y + 1) // 2</code>\nBitwise and.\nBitwise and.\nBitwise and with immediate.\nBitwise and with immediate.\nBitwise and not.\nBitwise and not.\nGlobal value giving the address of the start of the table.\nReinterpret the bits in <code>x</code> as a different type.\nReinterpret the bits in <code>x</code> as a different type.\nReverse the bits of a integer.\nReverse the bits of a integer.\nRead the bits of this source location.\nConditional select of bits.\nConditional select of bits.\nConvert <code>x</code> to an integer mask.\nConvert <code>x</code> to an integer mask.\nBitwise not.\nBitwise not.\nBitwise or.\nBitwise or.\nBitwise or with immediate.\nBitwise or with immediate.\nBitwise or not.\nBitwise or not.\nGlobal value giving the current bound of the table, in …\nIndirect branch via jump table.\nIndirect branch via jump table.\nConditional branch when cond is non-zero.\nConditional branch when cond is non-zero.\nReverse the byte order of an integer.\nReverse the byte order of an integer.\nInsert an instruction and return a reference to it, …\nBitwise xor.\nBitwise xor.\nBitwise xor with immediate.\nBitwise xor with immediate.\nBitwise xor not.\nBitwise xor not.\nDirect function call.\nDirect function call.\nCalling convention.\nIndirect function call.\nIndirect function call.\nRound floating point round to integral, towards positive …\nRound floating point round to integral, towards positive …\nClear the signature so it is identical to a fresh one …\nCount leading sign bits.\nCount leading sign bits.\nCount leading zero bits.\nCount leading zero bits.\nWill this function be defined nearby, such that it will …\nCondition codes for the Cranelift code generator.\nConstants\nCount trailing zeros.\nCount trailing zeros.\nGet an immutable reference to the data flow graph that …\nGet an immutable reference to the data flow graph.\nGet a mutable reference to the data flow graph that will …\nGet a mutable reference to the data flow graph.\nEncodes an assembly debug trap.\nEncodes an assembly debug trap.\nData flow graph tracking Instructions, Values, and blocks.\nReturns a displayable version of the <code>ExtFuncData</code>, with or …\nReturns a display for the current <code>ExternalName</code>, with extra …\nGet the address of a dynamic stack slot.\nGet the address of a dynamic stack slot.\nLoad a value from a dynamic stack slot.\nLoad a value from a dynamic stack slot.\nStore a value to a dynamic stack slot.\nStore a value to a dynamic stack slot.\nDynamic IR types\nThe size of a table element, in bytes.\nReturn endianness of the memory access.  This will return …\nCranelift IR entity references.\nExpands the relative source location into an absolute one, …\nMethod for extending argument to a full register.\nReturn a fixed length sub vector, extracted from a dynamic …\nReturn a fixed length sub vector, extracted from a dynamic …\nExtract lane <code>Idx</code> from <code>x</code>.\nExtract lane <code>Idx</code> from <code>x</code>.\nFloating point constant.\nFloating point constant.\nFloating point constant.\nFloating point constant.\nFloating point absolute value.\nFloating point absolute value.\nFloating point addition.\nFloating point addition.\nFloating point comparison.\nFloating point comparison.\nFloating point copy sign.\nFloating point copy sign.\nConvert signed integer to floating point.\nConvert signed integer to floating point.\nConvert unsigned integer to floating point.\nConvert unsigned integer to floating point.\nConverts packed signed 32-bit integers to packed double …\nConverts packed signed 32-bit integers to packed double …\nConverts floating point scalars to signed integer.\nConverts floating point scalars to signed integer.\nConvert floating point to signed integer as fcvt_to_sint …\nConvert floating point to signed integer as fcvt_to_sint …\nConverts floating point scalars to unsigned integer.\nConverts floating point scalars to unsigned integer.\nConvert floating point to unsigned integer as fcvt_to_uint …\nConvert floating point to unsigned integer as fcvt_to_uint …\nConvert <code>x</code> to a smaller floating point format.\nConvert <code>x</code> to a smaller floating point format.\nFloating point division.\nFloating point division.\nA memory fence.  This must provide ordering to ensure …\nA memory fence.  This must provide ordering to ensure …\nRound floating point round to integral, towards negative …\nRound floating point round to integral, towards negative …\nFloating point fused multiply-and-add.\nFloating point fused multiply-and-add.\nFloating point maximum, propagating NaNs using the …\nFloating point maximum, propagating NaNs using the …\nFloating point pseudo-maximum, propagating NaNs.  This …\nFloating point pseudo-maximum, propagating NaNs.  This …\nFloating point minimum, propagating NaNs using the …\nFloating point minimum, propagating NaNs using the …\nFloating point pseudo-minimum, propagating NaNs.  This …\nFloating point pseudo-minimum, propagating NaNs.  This …\nFloating point multiplication.\nFloating point multiplication.\nFloating point negation.\nFloating point negation.\nConvert <code>x</code> to a larger floating point format.\nConvert <code>x</code> to a larger floating point format.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nSource location when it is in effect\nCreates a new <code>RelSourceLoc</code> based on the given base and …\nCreate a new instance from the raw bit encoding.\nCreate a new instance from a <code>u32</code>.\nFloating point subtraction.\nFloating point subtraction.\nGet the address of a function.\nGet the address of a function.\nIntermediate representation of a function.\nConvert <code>x</code> to a smaller floating point format.\nConvert <code>x</code> to a smaller floating point format.\nConverts packed single precision floating point to packed …\nConverts packed single precision floating point to packed …\nGet the address in the frame pointer register.\nGet the address in the frame pointer register.\nGets the content of the pinned register, when it’s …\nGets the content of the pinned register, when it’s …\nGet a function reference for the probestack function in …\nGet the PC where this function will transfer control to …\nGet the PC where this function will transfer control to …\nGet the address in the stack pointer register.\nGet the address in the stack pointer register.\nGet a <code>UserExternalName</code> if this is a user-defined name.\nReturn the type of this global.\nCompute the value of global GV.\nCompute the value of global GV.\nTest if the <code>heap</code> bit is set.\nInteger absolute value with wrapping: <code>a := |x|</code>.\nInteger absolute value with wrapping: <code>a := |x|</code>.\nWrapping integer addition: <code>a := x + y \\pmod{2^B}</code>.\nWrapping integer addition: <code>a := x + y \\pmod{2^B}</code>.\nAdd integers with carry in and out.\nAdd integers with carry in and out.\nAdd integers with carry in.\nAdd integers with carry in.\nAdd integers with carry out.\nAdd integers with carry out.\nAdd immediate integer.\nAdd immediate integer.\nDoes lane-wise integer pairwise addition on two operands, …\nDoes lane-wise integer pairwise addition on two operands, …\nInteger comparison.\nInteger comparison.\nCompare scalar integer to a constant.\nCompare scalar integer to a constant.\nConcatenate low and high bits to form a larger integer …\nConcatenate low and high bits to form a larger integer …\nInteger constant.\nInteger constant.\nImmediate operands for Cranelift instructions\nWrapping integer multiplication: <code>a := x y \\pmod{2^B}</code>.\nWrapping integer multiplication: <code>a := x y \\pmod{2^B}</code>.\nInteger multiplication by immediate constant.\nInteger multiplication by immediate constant.\nArbitrary.\nThe index type for the table.\nInteger negation: <code>a := -x \\pmod{2^B}</code>.\nInteger negation: <code>a := -x \\pmod{2^B}</code>.\nInsert a new instruction which belongs to the DFG.\nInsert <code>y</code> as lane <code>Idx</code> in x.\nInsert <code>y</code> as lane <code>Idx</code> in x.\nInstruction formats and opcodes.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert <code>x</code> to a smaller integer type by discarding the most …\nConvert <code>x</code> to a smaller integer type by discarding the most …\nImmediate reverse wrapping subtraction: …\nImmediate reverse wrapping subtraction: …\nIs this the default source location?\nIs this the default relative source location?\nReference verification.\nReference verification.\nDoes this return more than one normal value? (Pre-struct …\nReference verification.\nReference verification.\nInteger shift left. Shift the bits in <code>x</code> towards the MSB by …\nInteger shift left. Shift the bits in <code>x</code> towards the MSB by …\nInteger shift left by immediate.\nInteger shift left by immediate.\nSplit an integer into low and high parts.\nSplit an integer into low and high parts.\nStore the low 16 bits of <code>x</code> to memory at <code>p + Offset</code>.\nStore the low 16 bits of <code>x</code> to memory at <code>p + Offset</code>.\nStore the low 32 bits of <code>x</code> to memory at <code>p + Offset</code>.\nStore the low 32 bits of <code>x</code> to memory at <code>p + Offset</code>.\nStore the low 8 bits of <code>x</code> to memory at <code>p + Offset</code>.\nStore the low 8 bits of <code>x</code> to memory at <code>p + Offset</code>.\nWrapping integer subtraction: <code>a := x - y \\pmod{2^B}</code>.\nWrapping integer subtraction: <code>a := x - y \\pmod{2^B}</code>.\nSubtract integers with borrow in.\nSubtract integers with borrow in.\nSubtract integers with borrow in and out.\nSubtract integers with borrow in and out.\nSubtract integers with borrow out.\nSubtract integers with borrow out.\nJump.\nJump.\nJump table representation.\nThe label index.\nFunction layout.\nLoad from memory at <code>p + Offset</code>.\nLoad from memory at <code>p + Offset</code>.\nIf this global references a symbol, return an estimate of …\nGuaranteed minimum table size in elements. Table accesses …\nName of the external function.\nArbitrary.\nRound floating point round to integral, towards nearest …\nRound floating point round to integral, towards nearest …\nCreate a new builder which inserts instructions at <code>pos</code>. …\nCreate a <code>ReplaceBuilder</code> that will overwrite <code>inst</code>.\nCreate a new blank signature.\nCreate a parameter with default flags.\nCreates a new UserExternalName.\nCreate a new empty set of flags.\nCreate a new source location with the given bits.\nCreate a new relative source location with the given bits.\nReturns a slice of all traps except <code>TrapCode::User</code> traps\nJust a dummy instruction.\nJust a dummy instruction.\nTest if the <code>notrap</code> flag is set.\nNull constant value for reference types.\nNull constant value for reference types.\nHow many special parameters does this function have?\nHow many special returns does this function have?\nThe arguments passed to the function.\nPopulation count\nPopulation count\nSpecial purpose of argument, or <code>Normal</code>.\nTest if the <code>readonly</code> flag is set.\nReturn an estimate of the distance to the referred-to …\nA resumable trap.\nA resumable trap.\nA resumable trap to be called when the passed condition is …\nA resumable trap to be called when the passed condition is …\nReturn from the function.\nReturn from the function.\nDirect tail call.\nDirect tail call.\nIndirect tail call.\nIndirect tail call.\nValues returned from the function.\nRotate left.\nRotate left.\nRotate left by immediate.\nRotate left by immediate.\nRotate right.\nRotate right.\nRotate right by immediate.\nRotate right by immediate.\nAdd with signed saturation.\nAdd with signed saturation.\nCopies a scalar value to a vector value.  The scalar is …\nCopies a scalar value to a vector value.  The scalar is …\nSigned integer division rounded toward zero: …\nSigned integer division rounded toward zero: …\nSigned integer division by an immediate constant.\nSigned integer division by an immediate constant.\nConditional select.\nConditional select.\nConditional select intended for Spectre guards.\nConditional select intended for Spectre guards.\nSet the <code>aligned</code> flag.\nSet a flag bit by name.\nSet endianness of the memory access.\nSet the <code>heap</code> bit. See the notes about mutual exclusion with\nSet the <code>notrap</code> flag.\nSets the content of the pinned register, when it’s …\nSets the content of the pinned register, when it’s …\nSet the <code>readonly</code> flag.\nSet the <code>table</code> bit. See the notes about mutual exclusion …\nSet the <code>vmctx</code> bit. See the notes about mutual exclusion …\nConvert <code>self</code> to a parameter type with the <code>sext</code> flag set.\nConvert <code>x</code> to a larger integer type by sign-extending.\nConvert <code>x</code> to a larger integer type by sign-extending.\nSIMD vector shuffle.\nSIMD vector shuffle.\nGet a Signature for the function targeted by this LibCall.\nCall signature of function.\nLoad 16 bits from memory at <code>p + Offset</code> and sign-extend.\nLoad 16 bits from memory at <code>p + Offset</code> and sign-extend.\nLoad a 16x4 vector (64 bits) from memory at <code>p + Offset</code> and …\nLoad a 16x4 vector (64 bits) from memory at <code>p + Offset</code> and …\nLoad 32 bits from memory at <code>p + Offset</code> and sign-extend.\nLoad 32 bits from memory at <code>p + Offset</code> and sign-extend.\nLoad a 32x2 vector (64 bits) from memory at <code>p + Offset</code> and …\nLoad a 32x2 vector (64 bits) from memory at <code>p + Offset</code> and …\nLoad 8 bits from memory at <code>p + Offset</code> and sign-extend.\nLoad 8 bits from memory at <code>p + Offset</code> and sign-extend.\nLoad an 8x8 vector (64 bits) from memory at <code>p + Offset</code> and …\nLoad an 8x8 vector (64 bits) from memory at <code>p + Offset</code> and …\nSigned integer maximum.\nSigned integer maximum.\nSigned integer minimum.\nSigned integer minimum.\nSigned integer multiplication, producing the high half of a\nSigned integer multiplication, producing the high half of a\nCombine <code>x</code> and <code>y</code> into a vector with twice the lanes but …\nCombine <code>x</code> and <code>y</code> into a vector with twice the lanes but …\nCreate a special-purpose parameter that is not (yet) bound …\nFind the index of a presumed unique special-purpose …\nFind the index of a presumed unique special-purpose …\nVector splat.\nVector splat.\nFixed-point multiplication of numbers in the QN format, …\nFixed-point multiplication of numbers in the QN format, …\nFloating point square root.\nFloating point square root.\nSigned integer remainder. The result has the sign of the …\nSigned integer remainder. The result has the sign of the …\nSigned integer remainder with immediate divisor.\nSigned integer remainder with immediate divisor.\nSigned shift right. Shift bits in <code>x</code> towards the LSB by <code>y</code> …\nSigned shift right. Shift bits in <code>x</code> towards the LSB by <code>y</code> …\nSigned shift right by immediate.\nSigned shift right by immediate.\nSubtract with signed saturation.\nSubtract with signed saturation.\nGet the address of a stack slot.\nGet the address of a stack slot.\nLoad a value from a stack slot at the constant offset.\nLoad a value from a stack slot at the constant offset.\nStore a value to a stack slot at a constant offset.\nStore a value to a stack slot at a constant offset.\nStack slots.\nStore <code>x</code> to memory at <code>p + Offset</code>.\nStore <code>x</code> to memory at <code>p + Offset</code>.\nWiden the high lanes of <code>x</code> using signed extension.\nWiden the high lanes of <code>x</code> using signed extension.\nWiden the low lanes of <code>x</code> using signed extension.\nWiden the low lanes of <code>x</code> using signed extension.\nVector swizzle.\nVector swizzle.\nAssume that <code>self</code> is an <code>GlobalValueData::Symbol</code> and return …\nCompute the value of global GV, which is a symbolic value.\nCompute the value of global GV, which is a symbolic value.\nTest if the <code>table</code> bit is set.\nBounds check and compute absolute address of a table entry.\nBounds check and compute absolute address of a table entry.\nCreates a new external name from a sequence of bytes. …\nCreates a new external name from a sequence of bytes. …\nCompute the value of global GV, which is a TLS (thread …\nCompute the value of global GV, which is a TLS (thread …\nTerminate execution unconditionally.\nTerminate execution unconditionally.\nTrap when non-zero.\nTrap when non-zero.\nTrap when zero.\nTrap when zero.\nRound floating point round to integral, towards zero.\nRound floating point round to integral, towards zero.\nCreate a set of flags representing an access from a “…\nCommon types for the Cranelift code generator.\nUnsigned addition of x and y, trapping if the result …\nUnsigned addition of x and y, trapping if the result …\nAdd with unsigned saturation.\nAdd with unsigned saturation.\nUnsigned integer division: <code>a := \\lfloor {x \\over y} \\rfloor</code>…\nUnsigned integer division: <code>a := \\lfloor {x \\over y} \\rfloor</code>…\nUnsigned integer division by an immediate constant.\nUnsigned integer division by an immediate constant.\nConvert <code>self</code> to a parameter with the <code>uext</code> flag set.\nConvert <code>x</code> to a larger integer type by zero-extending.\nConvert <code>x</code> to a larger integer type by zero-extending.\nLoad 16 bits from memory at <code>p + Offset</code> and zero-extend.\nLoad 16 bits from memory at <code>p + Offset</code> and zero-extend.\nLoad a 16x4 vector (64 bits) from memory at <code>p + Offset</code> and …\nLoad a 16x4 vector (64 bits) from memory at <code>p + Offset</code> and …\nLoad 32 bits from memory at <code>p + Offset</code> and zero-extend.\nLoad 32 bits from memory at <code>p + Offset</code> and zero-extend.\nLoad an 32x2 vector (64 bits) from memory at <code>p + Offset</code> …\nLoad an 32x2 vector (64 bits) from memory at <code>p + Offset</code> …\nLoad 8 bits from memory at <code>p + Offset</code> and zero-extend.\nLoad 8 bits from memory at <code>p + Offset</code> and zero-extend.\nLoad an 8x8 vector (64 bits) from memory at <code>p + Offset</code> and …\nLoad an 8x8 vector (64 bits) from memory at <code>p + Offset</code> and …\nUnsigned integer maximum.\nUnsigned integer maximum.\nUnsigned integer minimum.\nUnsigned integer minimum.\nUnsigned integer multiplication, producing the high half …\nUnsigned integer multiplication, producing the high half …\nCombine <code>x</code> and <code>y</code> into a vector with twice the lanes but …\nCombine <code>x</code> and <code>y</code> into a vector with twice the lanes but …\nGet the instruction we know is inside.\nUnsigned integer remainder.\nUnsigned integer remainder.\nUnsigned integer remainder with immediate divisor.\nUnsigned integer remainder with immediate divisor.\nCreate a new external name from a user-defined external …\nCreate a new external name from a user-defined external …\nDoes this signature have a parameter whose <code>ArgumentPurpose</code> …\nDoes this signature have a return whose <code>ArgumentPurpose</code> is …\nDoes this signature take an struct return pointer …\nUnsigned shift right. Shift bits in <code>x</code> towards the LSB by <code>y</code> …\nUnsigned shift right. Shift bits in <code>x</code> towards the LSB by <code>y</code> …\nUnsigned shift right by immediate.\nUnsigned shift right by immediate.\nSubtract with unsigned saturation.\nSubtract with unsigned saturation.\nCombine <code>x</code> and <code>y</code> into a vector with twice the lanes but …\nCombine <code>x</code> and <code>y</code> into a vector with twice the lanes but …\nWiden the high lanes of <code>x</code> using unsigned extension.\nWiden the high lanes of <code>x</code> using unsigned extension.\nWiden the low lanes of <code>x</code> using unsigned extension.\nWiden the low lanes of <code>x</code> using unsigned extension.\nReduce a vector to a scalar boolean.\nReduce a vector to a scalar boolean.\nType of the argument value.\nReduce a vector to a scalar boolean.\nReduce a vector to a scalar boolean.\nSIMD vector constant.\nSIMD vector constant.\nReduce a vector to a scalar integer.\nReduce a vector to a scalar integer.\nTest if the <code>vmctx</code> bit is set.\nSet the <code>aligned</code> flag, returning new flags.\nSet endianness of the memory access, returning new flags.\nSet the <code>heap</code> bit, returning new flags.\nSet the <code>notrap</code> flag, returning new flags.\nSet the <code>readonly</code> flag, returning new flags.\nReuse a single result value.\nReuse result values in <code>reuse</code>.\nSet the <code>table</code> bit, returning new flags.\nSet the <code>vmctx</code> bit, returning new flags.\nA bitselect-lookalike instruction except with the …\nA bitselect-lookalike instruction except with the …\nA float-to-integer conversion instruction for …\nA float-to-integer conversion instruction for …\nAn instruction with equivalent semantics to <code>pmaddubsw</code> on …\nAn instruction with equivalent semantics to <code>pmaddubsw</code> on …\nA similar instruction to <code>sqmul_round_sat</code> except with the …\nA similar instruction to <code>sqmul_round_sat</code> except with the …\nA vector swizzle lookalike which has the semantics of …\nA vector swizzle lookalike which has the semantics of …\nThe base pointer global value.\nThe base pointer global value.\nWill this symbol be defined nearby, such that it will …\nType of the loaded value.\nType of the iadd.\nThe symbolic name.\nOffset added to the base pointer before doing the load.\nByte offset to be added to the value.\nOffset from the symbol. This can be used instead of …\nSpecifies whether the memory that this refers to is …\nDoes this symbol refer to a thread local storage value?\nBase vector type.\nSource location when it is in effect\nThe label index.\nCommon traits of condition codes.\n<code>==</code>.\nEQ\nCondition code for comparing floating point numbers.\nGT\nGT | EQ\nCondition code for comparing integers.\nLT\nLT | EQ\n<code>!=</code>.\nThe C ‘!=’ operator is the inverse of ‘==’: …\nEQ | LT | GT\nLT | GT\nSigned <code>&gt;</code>.\nSigned <code>&gt;=</code>.\nSigned <code>&lt;</code>.\nSigned <code>&lt;=</code>.\nUN\nUN | EQ\nUN | GT\nUN | GT | EQ\nUN | LT\nUN | LT | EQ\nUnsigned <code>&gt;</code>.\nUnsigned <code>&gt;=</code>.\nUnsigned <code>&lt;</code>.\nUnsigned <code>&lt;=</code>.\nReturns a slice with all possible IntCC values.\nReturns a slice with all possible FloatCC values.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the inverse condition code of <code>self</code>.\nGet the reversed condition code for <code>self</code>.\nGet the corresponding string condition code for the IntCC …\nGet the corresponding IntCC with the signed component …\nGet the corresponding IntCC with the equal component …\nThis type describes the actual constant data. Note that …\nMaintains the mapping between a constant handle (i.e.  …\nAdd new bytes to the constant data.\nReturn the data as a slice.\nReturn the combined size of all of the constant values in …\nEmpty the constant pool of all data.\nIterate over mutable entries in the constant pool in …\nExpand the size of the constant data to <code>expected_size</code> …\nPrint the constant data in hexadecimal format, e.g. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nParse a hexadecimal string to <code>ConstantData</code>. This is the …\nRetrieve the constant data given a handle.\nInsert constant data into the pool, returning a handle for …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert the data to a vector.\nCheck if the constant contains any bytes.\nIterate over the constant’s bytes.\nIterate over the constants in insertion order.\nReturn the number of bytes in the constant.\nReturn the number of constants in the pool.\nCreate a new constant pool instance.\nLink a constant handle to its value. This does not …\nContents of a basic block.\nStorage for basic blocks within the DFG.\nA data flow graph defines all instructions and basic …\nObject that can display an instruction.\nStorage for instructions within the DFG.\nValue is the n’th parameter to a block.\nValue is the n’th result of an instruction.\nValue is a union of two other values.\nWhere did a value come from?\nIterator over all Values in a DFG\nCreate a new basic block.\nInserts a <code>ValueLabelAssignments::Alias</code> for <code>to_alias</code> if …\nAppend a parameter with type <code>ty</code> to <code>block</code>.\nSimilar to <code>append_block_param</code>, append a parameter with …\nAppend a new instruction result value to <code>inst</code>.\nAppend an existing value to <code>block</code>’s parameters.\nAttach an existing value to the result value list for <code>inst</code>.\nMake a BlockCall, bundling together the block and its …\nReturns <code>true</code> if the given block reference is valid.\nGet the types of the parameters on <code>block</code>.\nGet the parameters on <code>block</code>.\nbasic blocks in the function and their parameters.\nGet the call signature of a direct or indirect call …\nTurn a value into an alias of another.\nCheck that the given concrete <code>Type</code> has been defined in the …\nClear everything.\nClear the list of result values from <code>inst</code>.\nClone an instruction, attaching new result <code>Value</code>s and …\nStarts collection of debug information.\nCompute the type of an instruction result from opcode …\nConstants used within the function\nGet the controlling type variable, or <code>INVALID</code> if <code>inst</code> isn…\nDetach all the parameters from <code>block</code> and return them as a …\nDetach the list of result values from <code>inst</code> and return it.\nReturns an object that displays <code>inst</code>.\nReturns an object that displays the given <code>value</code>’s …\nDynamic types created.\nExternal function references. These are functions that can …\nGet the first result of an instruction.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTest if <code>inst</code> has any result values currently.\nStores large immediates that otherwise will not fit on …\nGet the instruction where the value was defined, if any.\nGet all value arguments on <code>inst</code> as a slice.\nGet all value arguments on <code>inst</code> as a mutable slice.\nGet the fixed value arguments on <code>inst</code> as a slice.\nGet the fixed value arguments on <code>inst</code> as a mutable slice.\nReturns <code>true</code> if the given instruction reference is valid.\nGet the result types of the given instruction.\nReturn all the results of an instruction.\nReturn all the results of an instruction as ValueList.\nConstruct a read-only visitor context for the values of …\nGet the variable value arguments on <code>inst</code> as a slice.\nGet the variable value arguments on <code>inst</code> as a mutable …\nData about all of the instructions in the function, …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the given block reference is valid.\nJump tables used in this function.\nGet the total number of basic blocks created in this …\nCreate a new basic block.\nDeclares a dynamic vector type\nCreate a new instruction.\nCreate result values for an instruction that produces …\nCreate result values for <code>inst</code>, reusing the provided …\nCreate result values for <code>inst</code>, reusing the provided …\nCreate an invalid value, to pad the index space. This is …\nCreate a new value alias. This is only for use by the …\nMap a function over the values of the instruction.\nCreate a new empty <code>DataFlowGraph</code>.\nGet the number component of this definition.\nGet the number of parameters on <code>block</code>.\nGet the total number of basic blocks created in this …\nGet the total number of instructions created in this …\nGet the total number of values.\nThe pre-legalization signature for each entry in <code>signatures</code>…\nOverwrite the instruction’s value references with values …\nGet the parameters on <code>block</code>.\nRemoves <code>val</code> from <code>block</code>‘s parameters by a standard linear …\nCreate a <code>ReplaceBuilder</code> that will replace <code>inst</code> with a new …\nReplace a block parameter with a new value of type <code>ty</code>.\nReplace an instruction result with a new value of type …\nReplace the results of one instruction with aliases to the …\nResolve value aliases.\nResolve all aliases among inst’s arguments.\nCompute the type of an alias. This is only for use in the …\nFunction signature table. These signatures are referenced …\nRemoves <code>val</code> from <code>block</code>’s parameters by swapping it with …\nCreate a union of two values.\nUnwrap the block there the parameter is defined, or panic.\nUnwrap the instruction where the value was defined, or …\nIf <code>v</code> is already defined as an alias, return its …\nGet the definition of a value.\nDetermine if <code>v</code> is an attached instruction result / block …\nCheck if a value reference is valid.\nCheck if a value reference is valid, while being aware of …\nMemory pool of value lists.\nGet the type of a value.\nGet an iterator over all values.\nGet an iterator over all values and their definitions.\nSaves Value labels.\nA dynamic type object which has a base vector type and a …\nAll allocated dynamic types.\nBase vector type, this is the minimum size of the type.\nConvert ‘base_vector_ty’ into a concrete dynamic …\nThe dynamic scaling factor of the base vector type.\nConvert a dynamic-vector type to a fixed-vector type.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new dynamic type.\nAn opaque reference to any of the entities defined in this …\nAn opaque reference to a basic block in a <code>Function</code>.\na basic block.\nAn opaque reference to a constant.\nA constant.\nAn opaque reference to a dynamic stack slot.\nA dynamic stack slot.\nAn opaque reference to a dynamic type.\nA dynamic type\nAn opaque reference to another <code>Function</code>.\nAn external function.\nThe whole function.\nAn opaque reference to a global value.\nA Global value.\nAn opaque reference to an immediate.\nAn opaque reference to an instruction in a <code>Function</code>.\nAn instruction.\nAn opaque reference to a jump table.\nA jump table.\nAn opaque reference to a function <code>Signature</code>.\nA function call signature.\nA function’s stack limit\nAn opaque reference to a stack slot.\nA stack slot.\nAn opaque reference to a WebAssembly table.\nA table.\nA reference to an <code>UserExternalName</code>, declared with …\nAn opaque reference to an SSA value.\nAn SSA value.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new block reference from its number. This …\nCreate a value from its number representation. This is the …\nCreate a new stack slot reference from its number.\nCreate a new stack slot reference from its number.\nCreate a new dynamic type reference from its number.\nCreate a new global value reference from its number.\nCreate a const reference from its number.\nCreate an immediate reference from its number.\nCreate a new jump table reference from its number.\nCreate a new external function reference from its number.\nCreate a new function signature reference from its number.\nCreate a new table reference from its number.\nWrapper type capable of displaying a <code>Function</code> with correct …\nAdditional annotations for function display.\nFunctions can be cloned, but it is not a very fast …\nFunction parameters used when creating this function, and …\nFunction fields needed when compiling a function.\nA version marker used to ensure that serialized clif ir is …\nReturns the base <code>SourceLoc</code>.\nClear all data structures in this function.\nStarts collection of debug information.\nCreates a dynamic stack slot in the function, to be used …\nDeclares a global value accessible to the function.\nCreates a jump table in the function, to be used by …\nCreates a sized stack slot in the function, to be used by …\nDeclares a table accessible to the function.\nDeclare a user-defined external function import, to be …\nData flow graph containing the primary definition of all …\nReturn an object that can display this function with …\nReturn an object that can display this function with …\nDynamic stack slots allocated in this function.\nSets the base <code>SourceLoc</code>, if not set yet, and returns the …\nRetrieve a <code>UserExternalNameRef</code> for the given name, or add …\nSize occupied by all stack slots associated with this …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet a concrete <code>Type</code> from a user defined <code>DynamicType</code>.\nFind the global dyn_scale value associated with given …\nFind the global dyn_scale for the given stack slot.\nGlobal values referenced.\nDeclare an external function import.\nAdds a signature which can later be used to declare an …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks that the specified block can be encoded as a basic …\nReturns true if the function is function that doesn’t …\nLayout of blocks and instructions in the function body.\nName of this function.\nCreates a new <code>FunctionParameters</code> with the given name.\nCreate a new empty, anonymous function with a Fast calling …\nAll the parameters that can be applied onto the function …\nResets an already existing user function name to a new …\nRewrite the branch destination to <code>new_dest</code> if the …\nSets an absolute source location for the given instruction.\nSignature of this function.\nSized stack slots allocated in this function.\nFind a presumed unique special-purpose function parameter …\nReturns an absolute source location for the given …\nSource locations.\nAn optional global value which represents an expression …\nAll the fields required for compiling a function, …\nTables referenced.\nReplace the <code>dst</code> instruction’s data with the <code>src</code> …\nReturns the internal mapping of <code>UserExternalNameRef</code> to …\nEnable value labels annotations.\nA version marker used to ensure that serialized clif ir is …\nCreate a function with the given name and signature.\nAn IEEE binary32 immediate floating point value, …\nAn IEEE binary64 immediate floating point value, …\n64-bit immediate signed integer operand.\nConvert a type into a vector of bytes; all implementors in …\n32-bit signed immediate offset.\nA 32-bit unsigned integer immediate operand.\n64-bit immediate unsigned integer operand.\n8-bit unsigned integer immediate operand.\nA 128-bit immediate operand.\nComputes the absolute value of self.\nComputes the absolute value of self.\nConverts Self to a rust f32\nConverts Self to a rust f64\nConvert the immediate into a slice.\nReturns the value of this immediate.\nGet the bitwise representation.\nGet the bitwise representation.\nIterate over the bytes in the constant.\nReturns the smallest integer greater than or equal to <code>self</code>.\nReturns the smallest integer greater than or equal to <code>self</code>.\nReturns a number composed of the magnitude of self and the …\nReturns a number composed of the magnitude of self and the …\nCreate an <code>Ieee32</code> number representing the greatest negative …\nCreate an <code>Ieee64</code> number representing the greatest negative …\nReturns the largest integer less than or equal to <code>self</code>.\nReturns the largest integer less than or equal to <code>self</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn the little-endian byte representation of the …\nCheck if the value is a NaN.\nCheck if the value is a NaN. For Ieee64, this means …\nReturns true if self has a negative sign, including -0.0, …\nReturns true if self has a negative sign, including -0.0, …\nReturns true if self is positive or negative zero\nReturns true if self is positive or negative zero\nReturn self negated.\nReturn self negated.\nCreate a new <code>Imm64</code> representing the signed number <code>x</code>.\nCreate a new <code>Uimm64</code> representing the unsigned number <code>x</code>.\nCreate a new <code>Offset32</code> representing the signed number <code>x</code>.\nCreate an <code>Ieee32</code> number representing <code>2.0^n</code>.\nCreate an <code>Ieee64</code> number representing <code>2.0^n</code>.\nReturns the nearest integer to <code>self</code>. Rounds half-way cases …\nReturns the nearest integer to <code>self</code>. Rounds half-way cases …\nSign extend this immediate as if it were a signed integer …\nReturns the square root of self.\nReturns the square root of self.\nConvert the immediate into a vector.\nReturns the integer part of <code>self</code>. This means that …\nReturns the integer part of <code>self</code>. This means that …\nAdd in the signed number <code>x</code> if possible.\nCreate a new <code>Offset32</code> representing the signed number <code>x</code> if …\nCreate a new <code>Ieee32</code> containing the bits of <code>x</code>.\nCreate a new <code>Ieee64</code> containing the bits of <code>x</code>.\nCreate a new <code>Ieee32</code> representing the number <code>x</code>.\nCreate a new <code>Ieee64</code> representing the number <code>x</code>.\nReturn self negated.\nReturn self negated.\nAtomicCas(imms=(flags: ir::MemFlags), vals=3, blocks=0)\n<code>a = atomic_cas MemFlags, p, e, x</code>. (AtomicCas) Type …\n<code>a = atomic_load MemFlags, p</code>. (LoadNoOffset)\nAtomicRmw(imms=(flags: ir::MemFlags, op: ir::AtomicRmwOp), …\n<code>a = atomic_rmw MemFlags, AtomicRmwOp, p, x</code>. (AtomicRmw)\n<code>atomic_store MemFlags, x, p</code>. (StoreNoOffset) Type inferred …\n<code>a = avg_round x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = band x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = band_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = band_not x, y</code>. (Binary) Type inferred from <code>x</code>.\nBinary(imms=(), vals=2, blocks=0)\nBinaryImm64(imms=(imm: ir::immediates::Imm64), vals=1, …\nBinaryImm8(imms=(imm: ir::immediates::Uimm8), vals=1, …\n<code>a = bitcast MemFlags, x</code>. (LoadNoOffset)\n<code>a = bitrev x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = bitselect c, x, y</code>. (Ternary) Type inferred from <code>x</code>.\nA pair of a Block and its arguments, stored in a single …\n<code>a = bmask x</code>. (Unary)\n<code>a = bnot x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = bor x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = bor_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = bor_not x, y</code>. (Binary) Type inferred from <code>x</code>.\nThe operand is bound to a known type.\n<code>br_table x, JT</code>. (BranchTable)\nBranchTable(imms=(table: ir::JumpTable), vals=1, blocks=0)\nBrif(imms=(), vals=1, blocks=2)\n<code>brif c, block_then, block_else</code>. (Brif) Type inferred from <code>c</code>…\n<code>a = bswap x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = bxor x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = bxor_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = bxor_not x, y</code>. (Binary) Type inferred from <code>x</code>.\nCall(imms=(func_ref: ir::FuncRef), vals=0, blocks=0)\n<code>rvals = call FN, args</code>. (Call)\nCallIndirect(imms=(sig_ref: ir::SigRef), vals=1, blocks=0)\n<code>rvals = call_indirect SIG, callee, args</code>. (CallIndirect) …\nInformation about call instructions.\n<code>a = ceil x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = cls x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = clz x</code>. (Unary) Type inferred from <code>x</code>.\nCondTrap(imms=(code: ir::TrapCode), vals=1, blocks=0)\n<code>a = ctz x</code>. (Unary) Type inferred from <code>x</code>.\n<code>debugtrap</code>. (NullAry)\nThis is a direct call to an external function declared in …\nWrapper for the context needed to display a BlockCall …\n<code>addr = dynamic_stack_addr DSS</code>. (DynamicStackLoad)\nDynamicStackLoad(imms=(dynamic_stack_slot: …\n<code>a = dynamic_stack_load DSS</code>. (DynamicStackLoad)\nDynamicStackStore(imms=(dynamic_stack_slot: …\n<code>dynamic_stack_store x, DSS</code>. (DynamicStackStore) Type …\n<code>a = extract_vector x, y</code>. (BinaryImm8) Type inferred from <code>x</code>.\n<code>a = extractlane x, Idx</code>. (BinaryImm8) Type inferred from <code>x</code>.\n<code>a = f32const N</code>. (UnaryIeee32)\n<code>a = f64const N</code>. (UnaryIeee64)\n<code>a = fabs x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = fadd x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = fcmp Cond, x, y</code>. (FloatCompare) Type inferred from <code>x</code>.\n<code>a = fcopysign x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = fcvt_from_sint x</code>. (Unary)\n<code>a = fcvt_from_uint x</code>. (Unary)\n<code>a = fcvt_low_from_sint x</code>. (Unary)\n<code>a = fcvt_to_sint x</code>. (Unary)\n<code>a = fcvt_to_sint_sat x</code>. (Unary)\n<code>a = fcvt_to_uint x</code>. (Unary)\n<code>a = fcvt_to_uint_sat x</code>. (Unary)\n<code>a = fdemote x</code>. (Unary)\n<code>a = fdiv x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>fence</code>. (NullAry)\nFloatCompare(imms=(cond: ir::condcodes::FloatCC), vals=2, …\n<code>a = floor x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = fma x, y, z</code>. (Ternary) Type inferred from <code>y</code>.\n<code>a = fmax x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = fmax_pseudo x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = fmin x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = fmin_pseudo x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = fmul x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = fneg x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = fpromote x</code>. (Unary)\nThe operand type can vary freely within the given set.\n<code>a = fsub x, y</code>. (Binary) Type inferred from <code>x</code>.\nFuncAddr(imms=(func_ref: ir::FuncRef), vals=0, blocks=0)\n<code>addr = func_addr FN</code>. (FuncAddr)\n<code>a = fvdemote x</code>. (Unary)\n<code>x = fvpromote_low a</code>. (Unary)\n<code>addr = get_frame_pointer</code>. (NullAry)\n<code>addr = get_pinned_reg</code>. (NullAry)\n<code>addr = get_return_address</code>. (NullAry)\n<code>addr = get_stack_pointer</code>. (NullAry)\n<code>a = global_value GV</code>. (UnaryGlobalValue)\n<code>a = iabs x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = iadd x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a, c_out = iadd_carry x, y, c_in</code>. (Ternary) Type inferred …\n<code>a = iadd_cin x, y, c_in</code>. (Ternary) Type inferred from <code>y</code>.\n<code>a, c_out = iadd_cout x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = iadd_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = iadd_pairwise x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = icmp Cond, x, y</code>. (IntCompare) Type inferred from <code>x</code>.\n<code>a = icmp_imm Cond, x, Y</code>. (IntCompareImm) Type inferred …\n<code>a = iconcat lo, hi</code>. (Binary) Type inferred from <code>lo</code>.\n<code>a = iconst N</code>. (UnaryImm)\n<code>a = imul x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = imul_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\nThis is an indirect call with the specified signature. See …\n<code>a = ineg x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = insertlane x, y, Idx</code>. (TernaryImm8) Type inferred from …\nAn instruction format\nIntAddTrap(imms=(code: ir::TrapCode), vals=2, blocks=0)\nIntCompare(imms=(cond: ir::condcodes::IntCC), vals=2, …\nIntCompareImm(imms=(cond: ir::condcodes::IntCC, imm: …\n<code>a = ireduce x</code>. (Unary)\n<code>a = irsub_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = is_invalid x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = is_null x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = ishl x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = ishl_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>lo, hi = isplit x</code>. (Unary) Type inferred from <code>x</code>.\n<code>istore16 MemFlags, x, p, Offset</code>. (Store) Type inferred …\n<code>istore32 MemFlags, x, p, Offset</code>. (Store) Type inferred …\n<code>istore8 MemFlags, x, p, Offset</code>. (Store) Type inferred from …\n<code>a = isub x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = isub_bin x, y, b_in</code>. (Ternary) Type inferred from <code>y</code>.\n<code>a, b_out = isub_borrow x, y, b_in</code>. (Ternary) Type inferred …\n<code>a, b_out = isub_bout x, y</code>. (Binary) Type inferred from <code>x</code>.\nJump(imms=(), vals=0, blocks=1)\n<code>jump block_call</code>. (Jump)\nLoad(imms=(flags: ir::MemFlags, offset: …\n<code>a = load MemFlags, p, Offset</code>. (Load)\nLoadNoOffset(imms=(flags: ir::MemFlags), vals=1, blocks=0)\nMultiAry(imms=(), vals=0, blocks=0)\n<code>a = nearest x</code>. (Unary) Type inferred from <code>x</code>.\n<code>nop</code>. (NullAry)\nThis is not a call instruction.\n<code>a = null</code>. (NullAry)\nNullAry(imms=(), vals=0, blocks=0)\nAn instruction opcode.\nValue type constraints for a given opcode.\n<code>a = popcnt x</code>. (Unary) Type inferred from <code>x</code>.\nThe type constraint on a value argument once the …\n<code>resumable_trap code</code>. (Trap)\n<code>resumable_trapnz c, code</code>. (CondTrap) Type inferred from <code>c</code>.\n<code>return rvals</code>. (MultiAry)\n<code>return_call FN, args</code>. (Call)\n<code>return_call_indirect SIG, callee, args</code>. (CallIndirect) …\n<code>a = rotl x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = rotl_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = rotr x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = rotr_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = sadd_sat x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = scalar_to_vector s</code>. (Unary)\n<code>a = sdiv x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = sdiv_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = select c, x, y</code>. (Ternary) Type inferred from <code>x</code>.\n<code>a = select_spectre_guard c, x, y</code>. (Ternary) Type inferred …\n<code>set_pinned_reg addr</code>. (Unary) Type inferred from <code>addr</code>.\n<code>a = sextend x</code>. (Unary)\nShuffle(imms=(imm: ir::Immediate), vals=2, blocks=0)\n<code>a = shuffle a, b, mask</code>. (Shuffle)\n<code>a = sload16 MemFlags, p, Offset</code>. (Load)\n<code>a = sload16x4 MemFlags, p, Offset</code>. (Load) Type inferred …\n<code>a = sload32 MemFlags, p, Offset</code>. (Load) Type inferred from …\n<code>a = sload32x2 MemFlags, p, Offset</code>. (Load) Type inferred …\n<code>a = sload8 MemFlags, p, Offset</code>. (Load)\n<code>a = sload8x8 MemFlags, p, Offset</code>. (Load) Type inferred …\n<code>a = smax x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = smin x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = smulhi x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = snarrow x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = splat x</code>. (Unary)\n<code>a = sqmul_round_sat x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = sqrt x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = srem x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = srem_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = sshr x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = sshr_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = ssub_sat x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>addr = stack_addr SS, Offset</code>. (StackLoad)\nStackLoad(imms=(stack_slot: ir::StackSlot, offset: …\n<code>a = stack_load SS, Offset</code>. (StackLoad)\nStackStore(imms=(stack_slot: ir::StackSlot, offset: …\n<code>stack_store x, SS, Offset</code>. (StackStore) Type inferred from …\nStore(imms=(flags: ir::MemFlags, offset: …\n<code>store MemFlags, x, p, Offset</code>. (Store) Type inferred from <code>x</code>.\nStoreNoOffset(imms=(flags: ir::MemFlags), vals=2, blocks=0)\n<code>a = swiden_high x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = swiden_low x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = swizzle x, y</code>. (Binary)\n<code>a = symbol_value GV</code>. (UnaryGlobalValue)\nTableAddr(imms=(table: ir::Table, offset: …\n<code>addr = table_addr T, p, Offset</code>. (TableAddr)\nTernary(imms=(), vals=3, blocks=0)\nTernaryImm8(imms=(imm: ir::immediates::Uimm8), vals=2, …\n<code>a = tls_value GV</code>. (UnaryGlobalValue)\nTrap(imms=(code: ir::TrapCode), vals=0, blocks=0)\n<code>trap code</code>. (Trap)\n<code>trapnz c, code</code>. (CondTrap) Type inferred from <code>c</code>.\n<code>trapz c, code</code>. (CondTrap) Type inferred from <code>c</code>.\n<code>a = trunc x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = uadd_overflow_trap x, y, code</code>. (IntAddTrap) Type …\n<code>a = uadd_sat x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = udiv x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = udiv_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = uextend x</code>. (Unary)\n<code>a = uload16 MemFlags, p, Offset</code>. (Load)\n<code>a = uload16x4 MemFlags, p, Offset</code>. (Load) Type inferred …\n<code>a = uload32 MemFlags, p, Offset</code>. (Load) Type inferred from …\n<code>a = uload32x2 MemFlags, p, Offset</code>. (Load) Type inferred …\n<code>a = uload8 MemFlags, p, Offset</code>. (Load)\n<code>a = uload8x8 MemFlags, p, Offset</code>. (Load) Type inferred …\n<code>a = umax x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = umin x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = umulhi x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = unarrow x, y</code>. (Binary) Type inferred from <code>x</code>.\nUnary(imms=(), vals=1, blocks=0)\nUnaryConst(imms=(constant_handle: ir::Constant), vals=0, …\nUnaryGlobalValue(imms=(global_value: ir::GlobalValue), …\nUnaryIeee32(imms=(imm: ir::immediates::Ieee32), vals=0, …\nUnaryIeee64(imms=(imm: ir::immediates::Ieee64), vals=0, …\nUnaryImm(imms=(imm: ir::immediates::Imm64), vals=0, …\n<code>a = urem x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = urem_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = ushr x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = ushr_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = usub_sat x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = uunarrow x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = uwiden_high x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = uwiden_low x</code>. (Unary) Type inferred from <code>x</code>.\n<code>s = vall_true a</code>. (Unary) Type inferred from <code>a</code>.\nSome instructions use an external list of argument values …\nMemory pool for holding value lists. See <code>ValueList</code>.\nA value type set describes the permitted set of types for …\n<code>s = vany_true a</code>. (Unary) Type inferred from <code>a</code>.\nA variable list of <code>Value</code> operands used for function call …\n<code>a = vconst N</code>. (UnaryConst)\n<code>x = vhigh_bits a</code>. (Unary)\n<code>a = x86_blendv c, x, y</code>. (Ternary) Type inferred from <code>x</code>.\n<code>a = x86_cvtt2dq x</code>. (Unary)\n<code>a = x86_pmaddubsw x, y</code>. (Binary)\n<code>a = x86_pmulhrsw x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = x86_pshufb x, y</code>. (Binary)\nAll cranelift opcodes.\nReturn information about a call instruction.\nAppend an argument to the block args.\nReturn a slice for the arguments of this block.\nReturn a slice for the arguments of this block.\nGet the value arguments to this instruction.\nGet mutable references to the value arguments to this …\nIf this is an atomic read/modify/write instruction, return …\nReturn the block for this BlockCall.\nGet the destinations of this instruction, if it’s a …\nGet a mutable slice of the destinations of this …\nCan this instruction read from memory?\nCan this instruction write to memory?\nCan this instruction cause a trap?\nClear out the arguments list.\nIf this is a control-flow instruction depending on an …\nGet the constraint descriptor for this opcode. Panic if …\nDoes <code>typ</code> belong to this set?\nGet the typeset of allowed types for the controlling type …\nDeep-clone the underlying list in the same pool. The …\nDeep-clone an <code>InstructionData</code>, including any referenced …\nReturn a value that can display this block call.\nAllowed dynamic vectors minimum lane sizes\nCompare two <code>InstructionData</code> for equality.\nGet an example member of this type set.\nAppends multiple elements to the arguments.\nAllowed float widths\nGet the instruction format for this opcode.\nIf this is a control-flow instruction depending on a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nParse an Opcode name from a string.\nHash an <code>InstructionData</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert this to a value list in <code>pool</code> with <code>fixed</code> prepended.\nAllowed int widths\nTrue for all branch or jump instructions.\nIs this a call instruction?\nCheck if the list is empty.\nIs this instruction polymorphic?\nReturns true if the instruction is a resumable trap.\nIs this a return instruction?\nTrue for instructions that terminate the block\nAllowed lane sizes\nIf this is a load/store instruction, returns its immediate …\nIf this is a load/store instruction, return its memory …\nConstruct a BlockCall with the given block and arguments.\nCreate an empty argument list.\nGet the number of <em>fixed</em> result values produced by this …\nGet the number of <em>fixed</em> input values required by this …\nGet the opcode of this instruction.\nDoes this instruction have other side effects besides can_*…\nAdd an argument to the end.\nAllowed ref widths\nRemove the argument at ix from the argument list.\nIs it necessary to look at the designated value input …\nGet the value type of result number <code>n</code>, having resolved the …\nReplace the block for this BlockCall.\nDespite having side effects, is this instruction okay to …\nIf this instruction references a stack slot, return it\nIf this is a trapping instruction, get its trap code. …\nIf this is a trapping instruction, get an exclusive …\nGet the controlling type variable operand.\nCan the controlling type variable for this opcode be …\nGet the value type of input value number <code>n</code>, having …\nA wrapper for the context required to display a …\nContents of a jump table.\nThe jump table and default block as a single slice. The …\nThe jump table and default block as a single mutable …\nAccess the jump table as a mutable slice. This excludes …\nAccess the jump table as a slice. This excludes the …\nClears all entries in this jump table, except for the …\nFetch the default block for this jump table.\nMutable access to the default block of this jump table.\nReturn a value that can display the contents of this jump …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns an iterator to the jump table, excluding the …\nReturns an iterator that allows modifying each value, …\nCreate a new jump table with the provided blocks\nIterate over blocks in layout order. See …\nIterate over instructions in a block in layout order. See …\nThe <code>Layout</code> struct determines the layout of blocks and …\nInsert <code>block</code> as the last block in the layout.\nAppend <code>inst</code> to the end of <code>block</code>.\nReturns the capacity of the <code>BlockData</code> map.\nIterate over the instructions in <code>block</code> in layout order.\nReturn an iterator over all blocks in layout order.\nClear the layout.\nGet the function’s entry block. This is simply the first …\nFetch a block’s first instruction.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInsert <code>block</code> in the layout before the existing block <code>before</code>…\nInsert <code>block</code> in the layout <em>after</em> the existing block <code>after</code>.\nInsert <code>inst</code> before the instruction <code>before</code> in the same …\nGet the block containing <code>inst</code>, or <code>None</code> if <code>inst</code> is not …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs <code>block</code> currently part of the layout?\nIs the given block cold?\nGet the last block in the layout.\nFetch a block’s last instruction.\nCreate a new empty <code>Layout</code>.\nGet the block following <code>block</code> in the layout order.\nFetch the instruction following <code>inst</code>.\nGet the block containing the program point <code>pp</code>. Panic if <code>pp</code> …\nCompare the program points <code>a</code> and <code>b</code> in the same block …\nGet the block preceding <code>block</code> in the layout order.\nFetch the instruction preceding <code>inst</code>.\nRemove <code>block</code> from the layout.\nRemove <code>inst</code> from the layout.\nMark a block as “cold”.\nSplit the block containing <code>before</code> in two.\nContents of a dynamic stack slot.\nAll allocated dynamic stack slots.\nAn explicit stack slot for dynamic vector types. This is a …\nAn explicit stack slot. This is a chunk of stack memory …\nThe size of an object on the stack, or the size of a stack …\nContents of a stack slot.\nThe kind of a stack slot.\nAll allocated stack slots.\nGet the alignment in bytes of this stack slot given the …\nGet the alignment in bytes of this stack slot given the …\nThe type of this slot.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe kind of stack slot.\nThe kind of stack slot.\nCreate a stack slot with the specified byte size.\nCreate a stack slot with the specified byte size.\nSize of stack slot in bytes.\nA 32-bit floating point type represented in the IEEE …\nA SIMD vector with 16 lanes containing a <code>f32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 16 …\nA SIMD vector with 2 lanes containing a <code>f32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 2 lanes …\nA SIMD vector with 4 lanes containing a <code>f32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nA SIMD vector with 8 lanes containing a <code>f32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 8 lanes …\nA 64-bit floating point type represented in the IEEE …\nA SIMD vector with 2 lanes containing a <code>f64</code> each.\nA dynamically-scaled SIMD vector with a minimum of 2 lanes …\nA SIMD vector with 4 lanes containing a <code>f64</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nA SIMD vector with 8 lanes containing a <code>f64</code> each.\nA dynamically-scaled SIMD vector with a minimum of 8 lanes …\nAn integer type with 128 bits.\nA SIMD vector with 2 lanes containing a <code>i128</code> each.\nA dynamically-scaled SIMD vector with a minimum of 2 lanes …\nA SIMD vector with 4 lanes containing a <code>i128</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nAn integer type with 16 bits. WARNING: arithmetic on 16bit …\nA SIMD vector with 16 lanes containing a <code>i16</code> each.\nA dynamically-scaled SIMD vector with a minimum of 16 …\nA SIMD vector with 32 lanes containing a <code>i16</code> each.\nA dynamically-scaled SIMD vector with a minimum of 32 …\nA SIMD vector with 4 lanes containing a <code>i16</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nA SIMD vector with 8 lanes containing a <code>i16</code> each.\nA dynamically-scaled SIMD vector with a minimum of 8 lanes …\nAn integer type with 32 bits.\nA SIMD vector with 16 lanes containing a <code>i32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 16 …\nA SIMD vector with 2 lanes containing a <code>i32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 2 lanes …\nA SIMD vector with 4 lanes containing a <code>i32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nA SIMD vector with 8 lanes containing a <code>i32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 8 lanes …\nAn integer type with 64 bits.\nA SIMD vector with 2 lanes containing a <code>i64</code> each.\nA dynamically-scaled SIMD vector with a minimum of 2 lanes …\nA SIMD vector with 4 lanes containing a <code>i64</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nA SIMD vector with 8 lanes containing a <code>i64</code> each.\nA dynamically-scaled SIMD vector with a minimum of 8 lanes …\nAn integer type with 8 bits. WARNING: arithmetic on 8bit …\nA SIMD vector with 16 lanes containing a <code>i8</code> each.\nA dynamically-scaled SIMD vector with a minimum of 16 …\nA SIMD vector with 32 lanes containing a <code>i8</code> each.\nA dynamically-scaled SIMD vector with a minimum of 32 …\nA SIMD vector with 64 lanes containing a <code>i8</code> each.\nA dynamically-scaled SIMD vector with a minimum of 64 …\nA SIMD vector with 8 lanes containing a <code>i8</code> each.\nA dynamically-scaled SIMD vector with a minimum of 8 lanes …\nNot a valid type. Can’t be loaded or stored. Can’t be …\nAn opaque reference type with 32 bits.\nAn opaque reference type with 64 bits.\nThe type of an SSA value.\nGet a type with the same number of lanes as this type, but …\nGet the type of a comparison result for the given type. …\nGet a type with the same number of lanes as this type, but …\nGet the total number of bits used to represent this type.\nGet the (minimum, maximum) values represented by each lane …\nGet a SIMD vector type with <code>n</code> times more lanes than this …\nGet the number of bytes used to store this type in memory.\nGet a type with the same number of lanes as this type, but …\nConvert a dynamic vector type to a fixed one.\nReturns the argument unchanged.\nGet a type with the same number of lanes as this type, but …\nIndex of this type, for use with hash tables etc.\nGet an integer type with the requested number of bits.\nGet an integer type with the requested number of bytes.\nCalls <code>U::from(self)</code>.\nIs this a SIMD vector type with a runtime number of lanes?\nIs this a scalar floating point type?\nIs this a scalar integer type?\nIs this the INVALID type?\nIs this a lane type?\nIs this a ref type?\nIs this a special type?\nIs this a SIMD vector type?\nGet the number of bits in a lane.\nGet the number of lanes in this SIMD vector type.\nThe type transformation that returns the lane type of a …\nGet the lane type of this SIMD vector type.\nGet log_2 of the number of bits in a lane.\nGet log_2 of the number of lanes in this SIMD vector type.\nGet log_2 of the number of lanes in this vector/dynamic …\nMerge lanes to half the number of lanes and double the …\nGet the minimum number of bits used to represent this type.\nGet the minimum of lanes in this SIMD vector type, this …\nSplit the lane width in half and double the number of …\nReturn the pointer type for the given target triple.\nConvert a fixed vector type to a dynamic one.\nTrue iff:\nThe string names of all the supported, but possibly not …\nMac aarch64 calling convention, which is a tweaked aarch64 …\nType alias of <code>IsaBuilder</code> used for building Cranelift’s …\nCalling convention identifiers.\nSmallest caller code size, not ABI-stable.\nBest performance, not ABI-stable.\nBuilder for a <code>TargetIsa</code>. Modify the ISA-specific settings …\nAfter determining that an instruction doesn’t have an …\nDescribes reason for target lookup failure\nThe type of a polymorphic TargetISA object which is ’…\nSpecialized convention for the probestack function.\nSupport for this target was disabled in the current build.\nSystem V-style convention used on many platforms.\nSupports tail calls, not ABI-stable.\nThis struct provides information that a frontend may need …\nMethods that are specialized to a target ISA.\nSupport for this target has not yet been implemented.\nWasmtime equivalent of AppleAarch64, not ABI-stable.\nWasmtime equivalent of WindowsFastcall, not ABI-stable.\nWasmtime equivalent of SystemV, not ABI-stable.\nWindows “fastcall” convention, also used for x64 and …\nCompile the given function.\nCreates a new System V Common Information Entry for the …\nGet the default calling convention of this target.\nThe default calling convention of the target.\nGet the ISA-dependent maximum vector register size, in …\nCreates unwind information for the function.\nGet the endianness of this ISA.\nIs the calling convention extending the Apple aarch64 ABI?\nIs the calling convention extending the Wasmtime ABI?\nIs the calling convention extending the Windows Fastcall …\nCombine the ISA-specific settings with the provided …\nGet the ISA-independent flags that were used to make this …\nReturns the calling convention used for libcalls according …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the information needed by frontends producing …\nThe function alignment required by this ISA.\nReturns whether this ISA has a native …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet a flag indicating whether branch protection is enabled.\nGet the ISA-dependent flag values that were used to make …\nIterates the available settings in the builder.\nLook for an ISA for the given <code>triple</code>. Return a builder …\nLook for a supported ISA with the given <code>name</code>. Return a …\nGet the ISA-dependent MachineEnv for managing register …\nMap a regalloc::Reg to its corresponding DWARF register.\nGet the name of this ISA.\nCreates a new ISA-builder from its components, namely the …\nGet the width of pointers on this ISA, in units of bits.\nGet the width of pointers on this target, in units of bits.\nGet the width of pointers on this ISA, in units of bytes.\nGet the width of pointers on this target, in units of …\nGet the pointer type of this ISA.\nGet the pointer type of this target.\nThe pointer width of the target.\nDoes this calling convention support tail calls?\nReturns the minimum symbol alignment for this ISA.\nReturns an object that can be used to build the text …\nGet the target triple that was used to make this trait …\nGets the triple for the builder.\nReturn the default calling convention for the given target …\nIntCC condition for Unsigned Addition Overflow (Carry).\nRepresents information relating to function unwinding.\nCreate a polymorphic TargetIsa from this specific …\nX86_64-bit Instruction Set Architecture.\nDefines if the aarch64-specific pointer authentication …\nThe frame-pointer register for this architecture has just …\nThe frame-pointer register for this architecture has just …\nThe stack slot at the given offset from the clobber-area …\nThe stack pointer was adjusted to allocate the stack.\nSystem V ABI unwind information.\nRepresents unwind information for a single function.\nUnwind pseudoinstruction used in VCode backends: …\nWindows x64 ABI unwind information.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSystem V ABI unwind information.\nWindows x64 ABI unwind information.\nThe offset from the start of the clobber area to this …\nThe offset from the current SP and FP value downward to …\nThe offset from the current SP (after push) to the SP at …\nThe offset from the current SP and FP value upward to the …\nThe saved register.\nWhether return addresses (hold in LR) contain a …\nSize to allocate.\nEnumerate the errors possible in mapping Cranelift …\nRepresents unwind information for a single System V ABI …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts the unwind information into a …\nRepresents Windows x64 unwind information.\nEmits the unwind information into the given mutable byte …\nGets the emit size of the unwind information, in bytes.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nOut-of-line data for calls, to keep the size of <code>Inst</code> down.\nConstant state used during emissions of a sequence of …\nState carried between emissions of a sequence of …\nInternal type MInst: defined at src/isa/x64/inst.isle line …\nInstruction operand sub-components (aka “parts”): …\nRegisters clobbered by this call, as per its calling …\nRegister defs of this call.\nContains the encoding machinery for the various x64 …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a constant state for emission of instructions.\nThe opcode of this call.\nx86 Settings.\nRegister uses of this call.\nAdd with carry.\nAdd operation.\nALU operations that don’t accept intermediates.\nSome basic ALU operations.\nInternal type Amode: defined at src/isa/x64/inst.isle line …\nBitwise AND operation.\nAnd with negated second operand.\nInternal type AvxOpcode: defined at src/isa/x64/inst.isle …\n&lt; unsigned\n&lt;= unsigned\nByte -&gt; Longword.\nByte -&gt; Quadword.\nBit-scan forward.\nBit-scan reverse.\nThese indicate condition code tests.  Not all are …\nCMP instruction: compute <code>a - b</code> and set flags from result.\nComparison operations.\nA virtual offset to a constant that will be emitted in the …\nInternal type DivSignedness: defined at …\nEqual comparison.\nThis defines the ways a value can be extended: either …\nThese indicate ways of extending (widening) a value, using …\nEncode the ways that floats can be compared. This is used …\nAn x64 memory fence kind.\nAn extension trait for converting <code>Writable&lt;Reg&gt;</code> to …\nA newtype wrapper around <code>Reg</code>.\nA newtype wrapper around <code>RegMem</code> for general-purpose …\nA newtype wrapper around <code>RegMemImm</code>.\nAn immediate operand.\n8-bit immediate operand.\nA newtype wrapper around <code>Imm8Reg</code>.\nAn operand which is either an 8-bit integer immediate or a …\nA newtype wrapper around <code>Imm8Reg</code>.\n&lt; signed\n&lt;= signed\n<code>lfence</code> instruction (“Load Fence”)\nLongword -&gt; Quadword.\nLess than comparison.\nLess than or equal comparison.\nCounts leading zeroes (Leading Zero CouNT).\n<code>mfence</code> instruction (“Memory Fence”)\nA memory operand.\nA memory operand.\nThe signless, non-extending (N x N -&gt; N, for N in {32,64}) …\n= unsigned\nunsigned\n= signed\nsigned\nno overflow\nnot parity\nnot-negative\nnot-zero\nA (virtual) offset to the “nominal SP” value, which …\nNo value.\nNo value.\nNo extension.\nNot equal comparison.\noverflow\nAn operand’s size in bits.\nOptional writable Gpr.\nOptional writable Gpr.\nBitwise inclusive OR.\nOrdered.\nparity\nCounts the number of ones (POPulation CouNT).\nA real amode.\nA register operand.\nA register operand.\nA register operand.\nAn operand which is either an integer Register or a value …\nAn operand which is either an integer Register, a value in …\nLeft rotation.\nRight rotation.\nRound down mode.\nEncode the rounding modes used as part of the Rounding …\nRound to nearest mode.\nRound up mode.\nRound to zero mode.\nnegative\n<code>sfence</code> instruction (“Store Fence”)\nInteger subtraction with borrow.\nThese indicate the form of a scalar shift/rotate: left, …\nLeft shift.\nReplicates the sign bit in the most significant bits.\nInserts zeros in the most significant bits.\nSign-extend.\n16-bit.\n32-bit.\n64-bit.\n8-bit.\nSome value of type <code>T</code>.\nSome value of type <code>T</code>.\nSome SSE operations requiring 2 operands r/m and r.\nInteger subtraction.\nA Memory Address. These denote a 64-bit value only. Used …\nTEST instruction: compute <code>a &amp; b</code> and set flags from result.\nAn extenstion trait for converting <code>Writable{Xmm,Gpr}</code> to …\nCounts trailing zeroes (Trailing Zero CouNT).\nUnary operations requiring register or memory and register …\nUnordered.\nUnordered or greater than comparison.\nUnordered of greater than or equal comparison.\nWord -&gt; Longword.\nWord -&gt; Quadword.\nWritable Gpr.\nWritable Gpr.\nA newtype wrapper around <code>Reg</code>.\nA newtype wrapper around <code>RegMem</code> for general-purpose …\nA newtype wrapper around <code>RegMem</code> for general-purpose …\nA newtype wrapper around <code>RegMemImm</code>.\nA newtype wrapper around <code>RegMemImm</code>.\nBitwise exclusive OR.\nzero\nZero-extend.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert <code>Writable&lt;Reg&gt;</code> to <code>Writable{Xmm,Gpr}</code>.\nCreate an immediate operand.\nCreate an immediate sign-extended and register addressing …\nCreate a sign-extended-32-to-64 with register and shift …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a memory operand.\nCreate a memory operand.\nCreate this newtype from the given register, or return <code>None</code>…\nConstruct a <code>RegMem</code> newtype from the given <code>RegMem</code>, or return\nConstruct this newtype from the given <code>RegMemImm</code>, or return …\nConstruct this newtype from the given <code>Imm8Reg</code>, or return …\nCreate this newtype from the given register, or return <code>None</code>…\nConstruct a <code>RegMem</code> newtype from the given <code>RegMem</code>, or return\nConstruct a <code>RegMem</code> newtype from the given <code>RegMem</code>, or return\nConstruct this newtype from the given <code>RegMemImm</code>, or return …\nConstruct this newtype from the given <code>RegMemImm</code>, or return …\nConstruct this newtype from the given <code>Imm8Reg</code>, or return …\nCreate a real addressing mode.\nCreate a register operand.\nCreate a register operand.\nConvert this newtype into its underlying <code>Imm8Reg</code>.\nConvert this newtype into its underlying <code>Imm8Reg</code>.\nGet this newtype’s underlying <code>Reg</code>.\nGet this newtype’s underlying <code>Reg</code>.\nConvert this newtype into its underlying <code>RegMem</code>.\nConvert this newtype into its underlying <code>RegMem</code>.\nConvert this newtype into its underlying <code>RegMem</code>.\nConvert this newtype into its underlying <code>RegMemImm</code>.\nConvert this newtype into its underlying <code>RegMemImm</code>.\nConvert this newtype into its underlying <code>RegMemImm</code>.\nConvert <code>Writable{Xmm,Gpr}</code> to <code>Writable&lt;Reg&gt;</code>.\nThe 8-bit immediate value.\nThe underlying register.\nThe memory address.\nThe underlying register.\nThe memory address.\nThe underlying register.\nThe immediate value.\nThe nominal stack pointer value.\nThe encoding formats in this module all require a way of …\nEncodes EVEX instructions. These instructions are those …\nAdd 1 byte to the code section.\nAdd 2 bytes to the code section.\nAdd 4 bytes to the code section.\nAdd 8 bytes to the code section.\nEncodes instructions in the standard x86 encoding mode. …\nEncodes VEX instructions. These instructions are those …\nDefines the EVEX context for the <code>L&#39;</code>, <code>L</code>, and <code>b</code> bits (bits …\nConstructs an EVEX-encoded instruction using a builder …\nDefines the EVEX masking behavior; masking support is …\nThe EVEX format allows defining rounding control in the <code>L&#39;</code> …\nThe EVEX format allows choosing a vector length in the <code>L&#39;</code> …\nDescribe the register index to use. This wrapper is a …\nEncode the <code>aaa</code> bits for merging with the P2 byte.\nEncode the <code>L&#39;</code>, <code>L</code>, and <code>b</code> bits (bits 6:4 of EVEX P2 byte) …\nEmit the EVEX-encoded instruction to the code sink:\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSet the length of the instruction . Note that there are …\nSet the opcode map byte of the instruction: None | 0F | …\nSet the mask to use. See section 2.6 in the Intel Software …\nConstruct a default EVEX instruction.\nSet the instruction opcode byte.\nSet the legacy prefix byte of the instruction: None | 66 | …\nSet the register to use for the <code>reg</code> bits; many …\nSet the register to use for the <code>rm</code> bits; many instructions …\nSet the <code>vvvvv</code> register; some instructions allow using this …\nSet the W bit, typically used to indicate an instruction …\nEncode the <code>z</code> bit for merging with the P2 byte.\nWe may need to include one or more legacy prefix bytes …\nNo prefix bytes.\nAllows using the same opcode byte in different “opcode …\nOperand Size Override – here, denoting “16-bit …\nOperand size override and Lock.\nOperand size override and same effect as F3.\nThe Lock prefix.\nREPNE, but no specific meaning here – is just an opcode …\nREP/REPE, but no specific meaning here – is just an …\nEncode the ModR/M byte.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstructs a VEX-encoded instruction using a builder …\nThe VEX format allows choosing a vector length in the <code>L</code> …\nEmit the VEX-encoded instruction to the provided buffer.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nSet the imm byte. Overrides a previously set Self::imm_reg …\nSet the imm byte when used for a register. The reg bits …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSet the length of the instruction.\nSet the opcode map byte of the instruction: None | 0F | …\nConstruct a default VEX instruction.\nSet the instruction opcode byte.\nSome instructions use the ModRM.reg field as an opcode …\nSet the legacy prefix byte of the instruction: None | 66 | …\nSet the register to use for the <code>reg</code> bits; many …\nSet the register to use for the <code>rm</code> bits; many instructions …\nSet the <code>vvvv</code> register; some instructions allow using this …\nSet the W bit, denoted by <code>.W1</code> or <code>.W0</code> in the instruction …\nFlags group <code>x86</code>.\nCreate a <code>settings::Builder</code> for the x86 settings group.\nReturns the argument unchanged.\nHas support for AVX. AVX: CPUID.01H:ECX.AVX[bit 28]\nHas support for AVX2. AVX2: CPUID.07H:EBX.AVX2[bit 5]\nHas support for AVX512BITALG. AVX512BITALG: …\nHas support for AVX512DQ. AVX512DQ: CPUID.07H:EBX.AVX512DQ[…\nHas support for AVX512F. AVX512F: CPUID.07H:EBX.AVX512F[…\nHas support for AVX512VMBI. AVX512VBMI: …\nHas support for AVX512VL. AVX512VL: CPUID.07H:EBX.AVX512VL[…\nHas support for BMI1. BMI1: CPUID.(EAX=07H, …\nHas support for BMI2. BMI2: CPUID.(EAX=07H, …\nHas support for FMA. FMA: CPUID.01H:ECX.FMA[bit 12]\nHas support for LZCNT. LZCNT: CPUID.EAX=80000001H:ECX.LZCNT…\nHas support for POPCNT. POPCNT: CPUID.01H:ECX.POPCNT[bit 23…\nHas support for SSE3. SSE3: CPUID.01H:ECX.SSE3[bit 0]\nHas support for SSE4.1. SSE4.1: CPUID.01H:ECX.SSE4_1[bit 19…\nHas support for SSE4.2. SSE4.2: CPUID.01H:ECX.SSE4_2[bit 20…\nHas support for SSSE3. SSSE3: CPUID.01H:ECX.SSSE3[bit 9]\nCalls <code>U::from(self)</code>.\nIterates the setting values.\nCreate flags x86 settings group.\nGet a view of the boolean predicates.\nComputed predicate …\nComputed predicate …\nComputed predicate …\nComputed predicate …\nComputed predicate …\nComputed predicate …\nComputed predicate <code>shared.enable_simd() &amp;&amp; x86.has_avx()</code>.\nComputed predicate <code>x86.has_bmi1()</code>.\nComputed predicate <code>x86.has_avx() &amp;&amp; x86.has_fma()</code>.\nComputed predicate <code>x86.has_lzcnt()</code>.\nComputed predicate <code>x86.has_popcnt() &amp;&amp; x86.has_sse42()</code>.\nComputed predicate <code>x86.has_sse41()</code>.\nComputed predicate <code>shared.enable_simd() &amp;&amp; x86.has_sse41()</code>.\nComputed predicate <code>x86.has_sse41() &amp;&amp; x86.has_sse42()</code>.\nComputed predicate …\nComputed predicate <code>x86.has_ssse3()</code>.\nComputed predicate <code>shared.enable_simd() &amp;&amp; x86.has_ssse3()</code>.\nA opaque reference to a code loop.\nLoop tree information for a single function.\nA level in a loop nest.\nReturn the raw bit encoding for this instance.\nReturn the underlying index value as a <code>u32</code>.\nA clamped loop level from a larger-width (usize) depth.\nClear all the data structures contained in the loop …\nDetects the loops in a function. Needs the control flow …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from a <code>u32</code>.\nOne loop level deeper.\nReturn the innermost loop for a given block.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInvalid loop level.\nDetermines if a loop is contained in another loop.\nDetermine if a Block belongs to a loop by running a finger …\nDetermine if a Block is a loop header. If so, return the …\nCheck if the loop analysis is in a valid state.\nGet the loop level.\nReturns the header block of a particular loop.\nReturns the loop-nest level of a given block.\nReturn the eventual parent of a loop in the loop tree.\nReturns all the loops contained in a function.\nAllocate a new blank loop analysis struct. Use <code>compute</code> to …\nGet the root level (no loop).\nPacked representation of <code>Option&lt;T&gt;</code>.\nTypes that have a reserved value which can’t be created …\nCreate a default packed option representing <code>None</code>.\nExpand the packed option into a normal <code>Option</code>.\nUnwrap a packed <code>Some</code> value or panic.\nConvert <code>t</code> into a packed <code>Some(x)</code>.\nConvert an option into its packed equivalent.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the packed option is a <code>None</code> value.\nChecks whether value is the reserved one.\nReturns <code>true</code> if the packed option is a <code>Some</code> value.\nMaps a <code>PackedOption&lt;T&gt;</code> to <code>Option&lt;U&gt;</code> by applying a function …\nCreate an instance of the reserved value.\nTakes the value out of the packed option, leaving a <code>None</code> …\nUnwrap a packed <code>Some</code> value or panic.\nPretty-print a Cranelift error.\nPretty-print a verifier error.\n<code>apple_aarch64</code>.\nNo setting by this name exists.\nType mismatch for setting (e.g., setting an enum setting …\nThis is not a valid value for this setting.\nThe setting is a boolean.\nCollect settings values based on a template.\n<code>coff</code>.\n<code>cold</code>.\nA string-based configurator for settings groups.\n<code>elf_gd</code>.\nThe setting is an enumeration.\nContains the error value\n<code>fast</code>.\nFlags group <code>shared</code>.\nWrapper containing flags and optionally a <code>TargetIsa</code> trait …\n<code>inline</code>.\n<code>isa_default</code>.\nValues for <code>shared.libcall_call_conv</code>.\n<code>macho</code>.\n<code>none</code>.\n<code>none</code>.\nThe setting is a number.\nContains the success value\nValues for <code>shared.opt_level</code>.\n<code>outline</code>.\nA reference to just the boolean predicates of a settings …\nThe setting is a preset.\n<code>probestack</code>.\nValues for <code>shared.probestack_strategy</code>.\nAn error produced when changing a setting.\nA result returned when changing a setting.\nRepresents an available builder setting.\nRepresents the kind of setting.\n<code>speed</code>.\n<code>speed_and_size</code>.\n<code>system_v</code>.\nValues for <code>shared.tls_model</code>.\nRepresents a setting value.\n<code>windows_fastcall</code>.\nReturns a slice with all possible OptLevel values.\nReturns a slice with all possible TlsModel values.\nReturns a slice with all possible LibcallCallConv values.\nReturns a slice with all possible ProbestackStrategy …\nGets the boolean value if the value is from a boolean …\nGets the enum value if the value is from an enum setting.\nGets the numerical value if the value is from a num …\nCreate a <code>settings::Builder</code> for the shared settings group.\nThe description of the setting.\nImplementation details for generated code.\nEnable a boolean setting or apply a preset.\nDo redundant-load optimizations with alias analysis.\nEnable the use of atomic instructions\nEnable the use of floating-point instructions.\nEnable Spectre mitigation on heap bounds checks.\nEnable additional checks for debugging the incremental …\nEnable the use of jump tables in generated machine code.\nEnable various ABI extensions defined by LLVM’s behavior.\nEnable NaN canonicalization.\nEnable the use of the pinned register.\nEnable the use of stack probes for supported calling …\nEnable safepoint instruction insertions.\nEnable the use of SIMD instructions.\nEnable Spectre mitigation on table bounds checks.\nRun the Cranelift IR verifier at strategic times during …\nFlags are always present.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEnable Position-Independent Code generation.\nThe ISA may not be present.\nIterates the available settings in the builder.\nIterates the setting values.\nGets the kind of setting.\nThe kind of the setting.\nDefines the calling convention to use for LibCalls call …\nGenerate CFG metadata for machine code.\nThe name of the setting associated with this value.\nThe name of the setting.\nCreate a new builder with defaults and names from the …\nCreate a new view of a precomputed predicate vector.\nCreate flags shared settings group.\nOptimization level for generated code.\nGet a view of the boolean predicates.\nPreserve frame pointers\nEnable if the stack probe adjusts the stack pointer.\nThe log2 of the size of the stack guard region.\nControls what kinds of stack probes are emitted.\nEnable the symbolic checker for register allocation.\nEnable verbose debug logs for regalloc2.\nSet the string value of any setting by name.\nExtract contents of builder once everything is configured.\nCheck a numbered predicate.\nDefines the model used to perform TLS accesses.\nGenerate unwind information.\nUse colocated libcalls.\nEnable egraph-based optimization.\nBuilds a string from the current value\nThe supported values of the setting (for enum values).\nA boolean setting only uses one bit, numbered from LSB.\nA setting descriptor holds the information needed to …\nThe different kind of settings along with descriptor bits …\nAn Enum setting uses a range of enumerators.\nA numerical setting uses the whole byte.\nA preset is not an individual setting, it is a collection …\nAn instruction group template.\nDefault values.\nThe description of the setting.\nList of setting descriptors.\nAdditional details, depending on the kind of setting.\nUnion of all enumerators.\nGet enumerators corresponding to a <code>Details::Enum</code>.\nFormat a setting value as a TOML string. This is mostly …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nHash table of settings.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if a detail is a Detail::Preset. Useful because the …\nName of the instruction group.\nLower snake-case name of setting as defined in meta.\nOffset of byte containing this setting.\nPairs of (mask, value) for presets.\n0-7.\nFirst enumerator in the ENUMERATORS table.\nNumerical value of last enumerator, allowing for 1-256 …\nThe default profiler. You can get the results using …\nThe amount of profiled passes.\nNo active pass.\nA single profiled pass.\nAccumulated timing for all passes.\nA profiler.\nAdd <code>other</code> to the timings of this <code>PassTimes</code>.\nCanonicalization of NaNs\nCanonicalization of NaNs\nCompilation passes\nCompilation passes\nDead code elimination\nDead code elimination\nDescription of the pass.\nDominator tree\nDominator tree\nEgraph based optimizations\nEgraph based optimizations\nControl flow graph\nControl flow graph\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGlobal value numbering\nGlobal value numbering\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLayout full renumbering\nLayout full renumbering\nLoop invariant code motion\nLoop invariant code motion\nLoop analysis\nLoop analysis\nParsing textual Cranelift IR\nParsing textual Cranelift IR\nPre-legalization rewriting\nPre-legalization rewriting\nProcessing test file\nProcessing test file\nRegister allocation\nRegister allocation\nRegister allocation symbolic verification\nRegister allocation symbolic verification\nRemove constant phi-nodes\nRemove constant phi-nodes\nSet the profiler for the current thread.\nStart a profiling pass.\nStore in incremental cache\nStore in incremental cache\nTake the current accumulated pass timings and reset the …\nReturns the total amount of time taken by all the passes …\nTry loading from incremental cache\nTry loading from incremental cache\nRemove unreachable blocks\nRemove unreachable blocks\nVCode emission\nVCode emission\nVCode emission finalization\nVCode emission finalization\nVCode lowering\nVCode lowering\nVerify Cranelift IR\nVerify Cranelift IR\nTranslate WASM function\nTranslate WASM function\nTranslate WASM module\nTranslate WASM module\nContains the error value\nContains the error value\nContains the success value\nContains the success value\nA verifier error.\nList of verifier errors.\nResult of a verification operation.\nResult of a step in the verification process.\nReturn a <code>VerifierStepResult</code> that is fatal if at least one …\nOptionally provide some context for the given location; …\nReport a fatal error and return <code>Err</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn whether one or more errors were reported.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn whether no errors were reported.\nThe entity causing the verifier error.\nThe error message.\nReturn a new <code>VerifierErrors</code> struct.\nReport a non-fatal error and return <code>Ok</code>.\nReport an error, adding it to the list of errors.\nVerify <code>func</code> after checking the integrity of associated …\nVerify <code>func</code>.\nA <code>FuncWriter</code> used to decorate functions during printing.\nA <code>PlainWriter</code> that doesn’t decorate the function.\nWrites <code>func</code> to <code>w</code> as text. write_function_plain is passed …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nDefault impl of <code>write_entity_definition</code>\nDefault impl of <code>write_preamble</code>\nWrite out the basic block header, outdented:\nWrite the basic block header for the current function.\nWrite an entity definition defined in the preamble to <code>w</code>.\nWrite <code>func</code> to <code>w</code> as equivalent text. Use <code>isa</code> to emit …\nWrite the given <code>inst</code> to <code>w</code>.\nWrite the operands of <code>inst</code> to <code>w</code> with a prepended space.\nWrite the preamble to <code>w</code>. By default, this uses …")