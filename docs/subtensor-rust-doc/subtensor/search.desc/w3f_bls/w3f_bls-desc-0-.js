searchState.loadedDescShard("w3f_bls", 0, "Aggregate BLS signature library with extensive tuning …\nInternal message hash type.  Short for frequent rehashing …\nIterator over, messages and public key reference pairs.\nProofOfPossion trait which should be implemented by secret\nRepresentation of an aggregated BLS signature.\nBLS key pair with public key in both G1 and G2\nImplementation of ProofofPossion trait for Double BLS …\nAdaptation of <code>ark_ec::PairingEngine</code> to BLS-like signatures.\nReturns the argument unchanged.\nThe proof of possession generator is supposed to to …\nCalls <code>U::from(self)</code>.\nReturns an iterator over messages and public key reference …\nAggregation of BLS signatures using proofs-of-possession\nImplementation of ProofofPossion trait for BLS keys using …\nReturn the aggregated signature\nUnaggreagated BLS signatures\nAggregation of BLS signatures using proofs-of-possession\nAlgorithms for optimized verification of aggregate and …\nAppropriate BLS signature verification for the <code>Self</code> type.\nProofOfPossion trait which should be implemented by secret\nThis should be implemented by public key\nThe proof of possession generator is supposed to to …\nBLS Public Key with sub keys in both groups.\nDetached BLS Signature containing DLEQ\nMessage with attached BLS signature\nWrapper for a point in the signature group which is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn a double public object containing public keys both …\nVerify a single BLS signature using DLEQ proof\nProof Of Possession of the secret key as the secret scaler …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nverify the validity of PoP by performing the following …\nTrait to add extra config for a curve which is not in …\nA weakening of <code>pairing::Engine</code> to permit transposing the …\nGroup where BLS public keys live\nGroup where BLS signatures live\nInfrequently used BLS variant with tiny 48 byte signatures …\nUsual aggregate BLS signature scheme on ZCash’s …\nUsual aggregate BLS signature scheme on ZCash’s …\nPerform final exponentiation on the result of a Miller …\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate a random scalar for use as a secret key.\nreturn the generator of signature group\ngetter function for the hash to curve map\nHash one message to the signature curve.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRun the Miller loop from <code>Engine</code> but orients its arguments …\nPrepared negative of the generator of the public key curve.\nPrepared negative of the generator of the public key curve.\nPrepared negative of the generator of the public key curve.\nPerforms a pairing operation <code>e(p, q)</code> by calling …\nProcess the public key to be use in pairing. This has to be\nProcess the signature to be use in pairing. This has to be …\nSerialization helper for various sigma protocols\nImplement verification equation for aggregate BLS …\nProofOfPossion trait which should be implemented by secret\nAdd only a <code>Message</code> and <code>PublicKey&lt;E&gt;</code> to our internal data.\nAdd only a <code>Signature&lt;E&gt;</code> to our internal signature.\nAggregage BLS signatures assuming they have …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nverify the validity of schnoor proof for a given publick …\nSerialization code that is used by multiple modules.\nBLS Keypair\nBLS Keypair\nBLS Public Key\nSecret signing key that is split to provide side channel …\nSecret signing key lacking the side channel protections …\nbecause SecretKey is not canonically serializable and that …\nMessage with attached BLS signature\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate a secret key that is already split for side …\nGenerate a <code>Keypair</code>\nGenerate a <code>Keypair</code>\nGenerate a secret key without side channel protections.\nGenerate a secret key that is already split for side …\nInitialize the signature curve signed point mutation.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDerive our public key from our secret key\nDerive our public key from our secret key\nConvert into a <code>SecretKey</code> applying side channel protections.\nConvert into a <code>SecretKey</code> applying side channel protections.\nConvert into a <code>SecretKey</code> that supports side channel …\nCreate a representative usable for operations lacking side …\nCreate a representative usable for operations lacking side …\nRaw bytes output from a BLS signature regarded as a VRF.\nVRF output converted into a <code>ChaChaRng</code>.\nRandomly adjust how we split our secret signing key.\nSign after respliting the secret key for side channel …\nSign a message using a Seedabale RNG created from a seed …\nSign a message creating a <code>SignedMessage</code> using a user …\nSign a message using a Seedabale RNG created from a seed …\nSign a message using a Seedabale RNG created from a seed …\nSign without side channel protections from key mutation.\nSign a message using a Seedabale RNG created from a seed …\nSign without doing the key resplit mutation that provides …\nSign a message creating a <code>Signature</code> using the default …\nSign a message using a Seedabale RNG created from user …\nSign a message creating a <code>Signature</code> using a user supplied …\nSign a message creating a <code>SignedMessage</code> using a user …\nCreate a <code>SignedMessage</code> using the default <code>ThreadRng</code>.\nVerify a single BLS signature\nHash output from a BLS signature regarded as a VRF.\nAggregate the auxiliary public keys in the signature group …\nAdd only a <code>PublicKey&lt;E&gt;</code> to our internal data.\nAdd only a <code>Signature&lt;E&gt;</code> to our internal signature.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nConvenience type alias for affine form of <code>PublicKeyGroup</code>\nConvenience type alias for projective form of …\nConvenience type alias for affine form of <code>SignatureGroup</code>\nConvenience type alias for projective form of …\nSimple universal BLS signature verification\nSimple unoptimized BLS signature verification.  Useful for …\nBLS signature verification optimized for all unique …\nBLS signature verification optimized for all unique …")