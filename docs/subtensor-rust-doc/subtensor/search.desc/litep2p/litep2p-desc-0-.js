searchState.loadedDescShard("litep2p", 0, "Bandwidth sink which provides metering for …\nConnection closed to remote peer.\nConnection established to peer.\nFailed to dial peer.\nContains the error value\n<code>Litep2p</code> object.\nLitep2p events.\nContains the success value\nIdentifier of a peer of the network.\nPublic result type used by the crate.\nAdd one ore more known addresses for peer.\nGet handle to bandwidth sink.\nProtocol codecs.\n<code>Litep2p</code> configuration.\nCrypto-related code.\nDial peer.\nDial address.\n<code>Litep2p</code> error types.\nBehavior defining how futures running in the background …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nParses a <code>PeerId</code> from bytes.\nTries to turn a <code>Multihash</code> into a <code>PeerId</code>.\nBuilds a <code>PeerId</code> from a public key.\nGet total the number of bytes received.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks whether the public key passed as parameter matches …\nGet listen address of litep2p.\nGet local peer ID.\nCreate new <code>Litep2p</code>.\nPoll next event.\nGet total the nubmer of bytes sent.\nProtocol-related defines.\nGenerates a random peer ID from a cryptographically secure …\nSubstream-related helper code.\nReturns a base-58 encoded string of this <code>PeerId</code>.\nReturns a raw bytes representation of this <code>PeerId</code>.\nTransport protocol implementations provided by <code>Litep2p</code>.\nTries to extract a <code>PeerId</code> from the given <code>Multiaddr</code>.\nTypes used by <code>Litep2p</code> protocols/transport.\nThis crate implements the Yamux specification.\nAddress of the peer.\nConnection ID.\nEndpoint.\nDial error.\nRemote peer ID.\nPeer ID.\nIdentity codec where the argument denotes the payload size.\nSupported protocol codecs.\nUnsigned varint where the argument denotes the maximum …\nProtocol doens’t need framing for its messages or is …\nReturns the argument unchanged.\nIdentity codec that reads/writes <code>N</code> bytes from/to …\nCalls <code>U::from(self)</code>.\n<code>unsigned-varint</code> codec.\nIdentity codec.\nEncode <code>payload</code> using identity codec.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate new <code>Identity</code> codec.\nUnsigned varint codec.\nDecode <code>payload</code> into <code>BytesMut</code>.\nEncode <code>payload</code> using <code>unsigned-varint</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate new <code>UnsignedVarint</code> codec.\nSet maximum size for encoded/decodes values.\nConfiguration builder for <code>Litep2p</code>.\nDialer.\nListener.\nConfiguration for <code>Litep2p</code>.\nConnection role.\nBuild <code>Litep2pConfig</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate empty <code>ConfigBuilder</code>.\nAdd executor for running futures spawned by <code>litep2p</code>.\nAdd keypair.\nAdd known address(es) for one or more peers.\nEnable IPFS Bitswap protocol.\nEnable IPFS Identify protocol.\nEnable IPFS Kademlia protocol.\nEnable IPFS Ping protocol.\nHow many addresses should litep2p attempt to dial in …\nEnable mDNS for peer discoveries in the local network.\nEnable notification protocol.\nAdd QUIC transport configuration, enabling the transport.\nEnable request-response protocol.\nAdd TCP transport configuration, enabling the transport.\nEnable user protocol.\nAdd WebRTC transport configuration, enabling the transport.\nAdd WebSocket transport configuration, enabling the …\nA public Ed25519 key.\nThe public key of a node’s identity keypair.\nEd25519 keys.\nReturns the argument unchanged.\nDecode a public key from a protobuf structure, e.g. read …\nCalls <code>U::from(self)</code>.\nConvert the <code>PublicKey</code> into the corresponding <code>PeerId</code>.\nEncode the public key into a protobuf structure for …\nVerify a signature for a message using this public key, …\nAn Ed25519 keypair.\nAn Ed25519 public key.\nAn Ed25519 secret key.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate a new random Ed25519 keypair.\nGenerate a new Ed25519 secret key.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the public key of this keypair.\nGet the secret key of this keypair.\nSign a message using the private key of this keypair.\nConvert the keypair into a byte array by concatenating the …\nConvert the public key to a byte array in compressed form, …\nConvert this secret key to a byte array.\nConvert public key to <code>PeerId</code>.\nTry to parse a keypair from the binary format produced by …\nTry to parse a public key from a byte array containing the …\nTry to parse an Ed25519 secret key from a byte slice …\nVerify the Ed25519 signature on a message using the public …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTrait which defines the interface the executor must …\nStart executing a future in the background.\nStart executing a future in the background and give the …\nConnection closed to peer.\nConnection established to <code>peer</code>.\nFailed to dial peer.\nSubstream direction.\nSubstream was opened by the remote peer.\nSubstream was opened by the local peer.\nFailed to open substream.\nSubstream opened for <code>peer</code>.\nEvents emitted by one of the installed transports to …\nProvides an interfaces for <code>Litep2p</code> protocols to interact …\nTrait defining the interface for a user protocol.\nAdd one or more addresses for <code>peer</code>.\nGet user protocol codec.\nDial <code>peer</code> using <code>PeerId</code>.\nDial peer using a <code>Multiaddr</code>.\nForcibly close the connection, even if other protocols …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSupported <code>libp2p</code> protocols.\nMulticast DNS implementation.\nNotification protocol implementation.\nOpen substream to <code>peer</code>.\nGet user protocol name.\nRequest-response protocol implementation.\nStart the the user protocol event loop.\nDialed address.\nSubstream direction.\nEndpoint.\nError that occurred when the substream was being opened.\nFallback protocol.\nPeer ID.\nPeer ID.\nPeer ID.\nPeer ID.\nProtocol name.\nSubstream.\nSubstream ID.\n<code>/ipfs/bitswap/1.2.0</code> implementation.\n<code>/ipfs/identify/1.0.0</code> implementation.\n<code>/ipfs/kad/1.0.0</code> implementation.\n<code>/ipfs/ping/1.0.0</code> implementation.\nEvents emitted by the bitswap protocol.\nHandle for communicating with the bitswap protocol.\nBlock.\nA Cid that contains a multihash with an allocated size of …\nBitswap configuration.\nPresense.\nBitswap request.\nResponse type for received bitswap request.\nString value of the enum field names used in the ProtoBuf …\nString value of the enum field names used in the ProtoBuf …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts an <code>i32</code> to a <code>WantType</code>, or <code>None</code> if <code>value</code> is not a …\nConverts an <code>i32</code> to a <code>BlockPresenceType</code>, or <code>None</code> if <code>value</code> …\nCreates an enum from field names used in the ProtoBuf …\nCreates an enum from field names used in the ProtoBuf …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if <code>value</code> is a variant of <code>WantType</code>.\nReturns <code>true</code> if <code>value</code> is a variant of <code>BlockPresenceType</code>.\nCreate new <code>Config</code>.\nSend <code>request</code> to <code>peer</code>.\nSend <code>response</code> to <code>peer</code>.\nRequested CIDs.\nPeer ID.\nFound block.\nCID.\nCID.\nWhether the requested block exists or not.\nIdentify configuration.\nEvents emitted by Identify protocol.\nPeer identified.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate new <code>Config</code>.\nListen addresses.\nObserved address.\nPeer ID.\nProtocol version.\nSupported protocols.\nUser agent.\nAll peers must be successfully contacted.\nAutomatically add all discovered peers to routing tables.\nAutomatically accept all incoming records.\nKademlia configuration.\nConfiguration builder for Kademlia.\nResult for the issued <code>FIND_NODE</code> query.\n<code>GET_VALUE</code> query succeeded.\nIncoming <code>PUT_VALUE</code> request received.\nIncoming record validation mode.\nKademlia events.\nHandle for communicating with the Kademlia protocol.\nRecord was found in the local store.\nDon’t insert discovered peers automatically to the …\nDon’t insert incoming records automatically to the local …\n<code>N</code> peer must be successfully contacted.\nRecords found in the network.\nOne peer must be successfully contacted.\nA record received by the given peer.\n<code>PUT_VALUE</code> query succeeded.\nQuery failed.\nType representing a query ID.\nQuorum.\nA record stored in the DHT.\nThe (opaque) key of a record.\nThe type of the DHT records.\nRouting table update.\nRouting table update mode.\nAdd known peer.\nBuild Kademlia <code>Config</code>.\nBuild default Kademlia configuration.\nThe expiration time as measured by a local, monotonic …\nSend <code>FIND_NODE</code> query to known peers.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet record from DHT.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks whether the record is expired w.r.t. the given …\nKey of the record.\nCreate new <code>ConfigBuilder</code>.\nCreates a new key from the bytes of the input.\nCreates a new record for insertion into the DHT.\nThe peer from whom the record was received\nThe (original) publisher of the record.\nStore record to DHT.\nStore record to DHT to the given peers.\nThe provided record.\nStore the record in the local store. Used in combination …\nCopies the bytes of the key into a new vector.\nTry to add known peer and if the channel is clogged, …\nTry to initiate <code>FIND_NODE</code> query and if the channel is …\nTry to initiate <code>GET_VALUE</code> query and if the channel is …\nTry to initiate <code>PUT_VALUE</code> query and if the channel is …\nTry to initiate <code>PUT_VALUE</code> query to the given peers and if …\nTry to store the record in the local store, and if the …\nValue of the record.\nSet incoming records validation mode.\nSeed Kademlia with one or more known peers.\nSet Kademlia protocol names, overriding the default …\nSet default TTL for the records.\nSet replication factor.\nSet routing table update mode.\nRecord key.\nFound nodes and their addresses.\nDiscovered peers.\nQuery ID.\nQuery ID.\nQuery ID.\nQuery ID.\nRecord.\nFound records.\nTarget of the query\nPing configuration.\nPing configuration builder.\nPing time with remote peer.\nEvents emitted by the ping protocol.\nBuild <code>Config</code>.\nCreate new <code>Config</code> with default values.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate new default <code>Config</code> which can be modified by the …\nSet maximum failures the protocol.\nPeer ID.\nMeasured ping time with the peer.\nmDNS configuration.\nOne or more addresses discovered.\nEvents emitted by mDNS.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate new <code>Config</code>.\nAccept the inbound substream.\nSynchronous notification channel is clogged.\nNotification configuration.\nNotification configuration builder.\nFailed to dial peer.\nDirection of the connection.\nNotification protocol has been closed.\nConnection is considered inbound, i.e., it was initiated …\nConnection to peer doesn’t exist.\nNotification error.\nNotification events.\nHandle allowing the user protocol to interact with the …\nNotification received.\nNotification sink.\nNotification stream closed.\nFailed to open notification stream.\nNotification stream opened.\nConnection is considered outbound, i.e., it was initiated …\nReject the inbound substream.\nRemote rejected the substream.\nValidate substream.\nValidation for a previous substream still pending.\nValidation result.\nBuild notification configuration.\nClose substream to <code>peer</code>.\nClose substream to multiple peers.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate new <code>ConfigBuilder</code>.\nCreate new <code>Config</code>.\nGet a copy of the underlying notification sink for the …\nOpen substream to <code>peer</code>.\nOpen substreams to multiple peers.\nSend notification to <code>peer</code> asynchronously, waiting for the …\nSend notification to <code>peer</code> asynchronously, waiting for the …\nSend notification to <code>peer</code> synchronously.\nSend notification to <code>peer</code> synchronously.\nSend validation result to the notification protocol for an …\nSet handshake for the protocol.\nSet new handshake.\nTry close substream to multiple peers.\nTry to open substreams to multiple peers.\nConfigure size of the channel for sending asynchronous …\nAuto-accept inbound substreams for those connections which …\nShould <code>NotificationProtocol</code> attempt to dial the peer if an …\nSet fallback names.\nSet handshake.\nSet maximum notification size.\nConfigure size of the channel for sending synchronous …\nDirection of the substream.\nError.\nFallback, if the substream was negotiated using a fallback …\nFallback, if the substream was negotiated using a fallback …\nHandshake.\nHandshake.\nNotification.\nPeer ID.\nPeer ID.\nPeer ID.\nPeer ID.\nPeer ID.\nProtocol name.\nProtocol name.\nRequest was canceled by the local node.\nRequest-response protocol configuration.\nBuilder for <code>Config</code>.\nIf the peer is not currently connected, attempt to dial …\nDial behavior when sending requests.\nLitep2p isn’t connected to the peer.\nIf the peer is not connected, immediately reject the …\nRequest was rejected.\nRequest failed.\nRequest received from remote\nRequest-response error.\nRequest-response events.\nHandle given to the user protocol which allows it to …\nResponse received.\nRequest timed out.\nToo large payload.\nProtocol not supported.\nBuild <code>Config</code>.\nCancel an outbound request.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate new <code>Config</code>.\nCreate new <code>ConfigBuilder</code>.\nReject an inbound request.\nSend request to remote peer.\nSend request to remote peer with fallback.\nSend response to remote peer.\nSend response to remote peer with feedback.\nAttempt to send request to peer and if the channel is …\nAttempt to send request to peer with fallback and if the …\nSet fallback names.\nSpecify the maximum number of concurrent inbound requests. …\nSet maximum message size.\nSet timeout for outbound requests.\nRequest-response error.\nFallback protocol, if the substream was negotiated using a …\nFallback protocol, if the substream was negotiated using a …\nPeer Id.\nPeer Id.\nPeer Id.\nReceived request.\nRequest ID.\nRequest ID.\nRequest ID.\nReceived request.\n<code>Litep2p</code> substream type.\nSubstream set.\nSubstream set key.\nClose the substream.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAdd new substream to the set.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if <code>SubstreamSet</code> is empty.\nGet size of <code>SubstreamSet</code>.\nCreate new <code>SubstreamSet</code>.\nRemove substream from the set.\nSend framed data to remote peer.\nSuccessfully established outbound connection.\nConnection endpoint.\nSuccessfully established inbound connection.\nGet <code>Multiaddr</code> of the <code>Endpoint</code>.\nGet <code>ConnectionId</code> of the <code>Endpoint</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nIs this a listener endpoint?\nQUIC transport.\nTCP transport.\nWebRTC transport.\nWebSocket transport.\nAddress that was dialed.\nLocal connection address.\nConnection ID.\nConnection ID.\nQUIC transport configuration.\nQUIC transport configuration.\nConnection open timeout.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nListen address for the transport.\nSubstream open timeout.\nTCP transport configuration.\nTCP transport configuration.\nConnection open timeout.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nListen address for the transport.\nEnable <code>TCP_NODELAY</code>.\nNoise read-ahead frame count.\nNoise write buffer size.\nWhether to set <code>SO_REUSEPORT</code> and bind a socket to the …\nSubstream open timeout.\nYamux configuration.\nWebRTC transport configuration.\nWebRTC transport configuration.\nConnection datagram buffer size.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWebRTC listening address.\nWebSocket transport configuration.\nWebSocket transport configuration.\nConnection open timeout.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nListen address address for the transport.\nEnable <code>TCP_NODELAY</code>.\nNoise read-ahead frame count.\nNoise write buffer size.\nWhether to set <code>SO_REUSEPORT</code> and bind a socket to the …\nSubstream open timeout.\nYamux configuration.\nConnection ID.\nRequest ID.\nSubstream ID.\nGet <code>SubstreamId</code> from a number that can be converted into a …\nReturns the argument unchanged.\nGet <code>RequestId</code> from a number that can be converted into a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate new <code>SubstreamId</code>.\nCreate new <code>ConnectionId</code>.\nProtocol name.\nGenerate random <code>ConnectionId</code>.\nError types\nIterator over <code>Multiaddr</code> <code>Protocol</code>s.\nContains the “port” to contact. Similar to TCP or UDP, …\nRepresentation of a Multiaddr.\nRepresents an Onion v3 address\n<code>Protocol</code> describes all possible multiaddress protocols.\nConsume this instance and create an owned version …\nTurn this <code>Protocol</code> into one that owns its data, thus being …\nCreate a new, empty multiaddress.\nChecks whether the given <code>Multiaddr</code> is a suffix of this …\nConvert a Multiaddr to a string\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nParse a single <code>Protocol</code> value from its byte slice …\nParse a protocol value from the given iterator of string …\nReturn the hash of the public key as bytes\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if the length of this multiaddress is 0.\nReturns the components of this multiaddress.\nReturn the length in bytes of this multiaddress.\nPops the last <code>Protocol</code> of this multiaddr, or <code>None</code> if the …\nReturn the port\nReturns &amp;str identifiers for the protocol names themselves.\nAdds an already-parsed address component to the end of …\nReplace a <code>Protocol</code> at some position in this <code>Multiaddr</code>.\nReturn a copy of this <code>Multiaddr</code>’s byte representation.\nLike <code>Multiaddr::push</code> but consumes <code>self</code>.\nCreate a new, empty multiaddress with the given capacity.\nEncode this protocol by writing its binary representation …\nBLAKE2b-256 (32-byte hash size)\nBLAKE2b-512 (64-byte hash size)\nBLAKE2s-128 (16-byte hash size)\nBLAKE2s-256 (32-byte hash size)\nBLAKE3-256 (32-byte hash size)\nDefault (cryptographically secure) Multihash …\nMultihash error.\nIdentity hash (max. 64 bytes)\nInvalid multihash size.\nIo error.\nKeccak-224 (28-byte hash size)\nKeccak-256 (32-byte hash size)\nKeccak-384 (48-byte hash size)\nKeccak-512 (64-byte hash size)\nA Multihash with the same allocated size as the …\nTrait that implements hashing.\nSHA-256 (32-byte hash size)\nSHA-512 (64-byte hash size)\nSHA3-224 (28-byte hash size)\nSHA3-256 (32-byte hash size)\nSHA3-384 (48-byte hash size)\nSHA3-512 (64-byte hash size)\nUnsupported multihash code.\nInvalid varint.\nCalculate the hash of some input data.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a multihash from an existing multihash digest.\nProtocol name.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nClient to server connection.\nAn operation fails because the connection is closed.\nYamux configuration.\nThe various error cases a connection may encounter.\nA Yamux <code>Connection</code> controller.\nWraps a <code>Connection</code> which can be controlled with a <code>Control</code>.\nDecoding a Yamux message frame failed.\nContains the error value\nPossible errors while decoding a message frame.\nA data frame body length is larger than the configured …\nDecoding the frame header failed.\nPossible errors while decoding a message frame header.\nAn underlying I/O error occured.\nAn I/O error.\nHow the connection is used.\nThe whole range of stream IDs has been used up.\nContains the success value\nSend window updates only when data is read on the …\nSend window updates as soon as a <code>Stream</code>’s receive window …\nByte data produced by the <code>futures::stream::Stream</code> impl of …\nServer to client connection.\nA multiplexed Yamux stream.\nThe ID of a stream.\nToo many streams are open, so no further ones can be …\nAn unknown frame type.\nUnknown version.\nSpecifies when window update frames are sent.\nClose the connection.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet this stream’s identifier.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether we are still waiting for the remote to acknowledge …\nOpen a new stream to the remote.\nClose the connection.\nPoll for a new outbound stream.\nPoll for the next inbound stream.\nSet the max. buffer size per stream.\nSet the max. number of streams.\nAllow or disallow streams to read from buffered data after …\nSet the receive window per stream (must be &gt;= 256 KiB).\nSet the max. payload size used when sending data frames. …\nSet the window update mode to use.")