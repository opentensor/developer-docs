searchState.loadedDescShard("netlink_packet_core", 0, "<code>netlink-packet-core</code> provides a generic netlink message …\nThe message terminates a multipart message. Data lost\nThe message signals an error and the payload contains a …\nThe message is ignored.\nA <code>NetlinkDeserializable</code> type can be deserialized from a …\nRepresent a netlink message.\nReturn the length of the serialized data.\nReturn the length of this message in bytes\nDeserialize the given buffer into <code>Self</code>.\nParse the given buffer as a netlink message\nEnsure the header (<code>NetlinkHeader</code>) is consistent with the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nMessage header (this is common to all the netlink …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsume this message and return its header and payload\nCreate a new netlink message from the given header and …\nInner message, which depends on the netlink protocol being …\nSerialize this types and write the serialized data into …\nSerialize this message and write the serialized data into …\nLength of a Netlink packet header\nA raw Netlink buffer that provides getters and setter for …\nReturn the <code>flags</code> field\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nConsume the packet, returning the underlying buffer.\nReturn the <code>length</code> field\nReturn the <code>type</code> field\nCreate a new <code>NetlinkBuffer</code> that uses the given buffer as …\nCheck the length of the given buffer and make sure it’s …\nReturn a pointer to the packet payload.\nReturn the payload length.\nReturn a mutable pointer to the payload.\nReturn the <code>port_number</code> field\nReturn the <code>sequence_number</code> field\nSet the packet header <code>flags</code> field\nSet the packet header <code>length</code> field\nSet the packet header <code>message_type</code> field\nSet the packet header <code>port_number</code> field\nSet the packet header <code>sequence_number</code> field\nRequest for an acknowledgment on success. Typical …\nextended ACK TVLs were included\nAdd to the end of the object list.\nReturn an atomic snapshot of the table. Requires …\nrequest was capped\nCreate object if it doesn’t already exist.\nDump was filtered as requested\nDump was inconsistent due to sequence change\nEcho this request.  Typical direction of request is from …\nDon’t replace if the object already exists.\nReturn all entries matching criteria passed in message …\nIndicates the message is part of a multipart message …\nDo not delete recursively\nReplace existing matching object.\nMust be set on all request messages (typically from user …\nReturn the complete table instead of a single entry.\nReturn the error code\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsume the packet, returning the underlying buffer.\nReturn a pointer to the payload.\nReturn a mutable pointer to the payload.\nset the error code field\nAccording to <code>netlink(7)</code> the <code>NLMSG_ERROR</code> return Negative …\nA Netlink header representation. A netlink header has the …\nFlags. It should be set to one of the <code>NLM_F_*</code> constants.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nLength of the netlink packet, including the header and the …\nNetlinkMessage type. The meaning of this field depends on …\nPort number (usually set to the the process ID)\nSequence number of the packet")