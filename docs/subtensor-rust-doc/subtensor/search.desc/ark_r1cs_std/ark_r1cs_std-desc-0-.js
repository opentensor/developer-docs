searchState.loadedDescShard("ark_r1cs_std", 0, "This crate implements common “gadgets” that make …\nA utility trait to convert <code>Self</code> to …\nThis trait describes some core functionality that is …\nSpecifies how to convert a variable of type <code>Self</code> to …\nThe type of the “native” value that <code>Self</code> represents in …\nThis module describes a trait for allocating new variables …\nThis module implements gadgets related to bit …\nReturns the underlying <code>ConstraintSystemRef</code>.\nThis module describes a trait for checking equality of …\nThis module implements gadgets related to field arithmetic.\nConverts <code>self</code> to <code>Result</code>.\nThis module implements gadgets related to group …\nImplements arithmetic traits (eg: <code>Add</code>, <code>Sub</code>, <code>Mul</code>) for the …\nImplements arithmetic traits (eg: <code>Add</code>, <code>Sub</code>, <code>Mul</code>) for the …\nReturns <code>true</code> if <code>self</code> is a circuit-generation-time constant.\nSome utility macros for making downstream impls easier.\nThis module implements gadgets related to computing …\nThis module implements functions for manipulating …\nThis module describes traits for conditionally selecting a …\nConverts <code>self</code> to <code>FpVar&lt;ConstraintF&gt;</code> variables.\nReturns the value that is assigned to <code>self</code> in the …\nSpecifies how variables of type <code>Self</code> should be allocated …\nDescribes the mode that a variable should be allocated in …\nIndicate to the <code>ConstraintSystem</code> that the high-level …\nIndicate to the <code>ConstraintSystem</code> that the high-level …\nIndicate to the <code>ConstraintSystem</code> that the high-level …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nOutputs the maximum according to the relation …\nAllocates a new constant of type <code>Self</code> in the …\nAllocates a new public input of type <code>Self</code> in the …\nAllocates a new variable of type <code>Self</code> in the …\nAllocates a new private witness of type <code>Self</code> in the …\nSpecifies constraints for conversion to a little-endian …\nSpecifies constraints for conversion to a little-endian …\nThis module contains <code>Boolean</code>, a R1CS equivalent of the <code>bool</code>…\nOutputs the canonical big-endian bit-wise representation …\nOutputs the canonical little-endian bit-wise …\nOutputs a canonical, little-endian, byte decomposition of …\nOutputs a possibly non-unique big-endian bit-wise …\nOutputs a possibly non-unique little-endian bit-wise …\nOutputs a possibly non-unique byte decomposition of <code>self</code>.\nThis module contains a macro for generating <code>UIntN</code> types, …\nThis module contains the <code>U128</code> type, which is the R1CS …\nThis module contains the <code>U16</code> type, which is the R1CS …\nThis module contains the <code>U32</code> type, which is the R1CS …\nThis module contains the <code>U64</code> type, which is the R1CS …\nThis module contains <code>UInt8</code>, a R1CS equivalent of the <code>u8</code> …\nRepresents a variable in the constraint system which is …\nRepresents a boolean value in the constraint system which …\nConstant (not an allocated variable).\nThe constant <code>false</code>.\nExistential view of the boolean variable.\nNegated view of the boolean variable.\nThe constant <code>true</code>.\nPerforms an AND operation over the two operands, returning …\nOutputs <code>self &amp; other</code>.\nCalculates <code>a AND (NOT b)</code>.\nConstructs a constant <code>Boolean</code> with value <code>b</code>.\nConstructs a <code>Boolean</code> vector from a slice of constant <code>u8</code>. …\nEnforces that <code>bits</code>, when interpreted as a integer, is less …\nEnforces that <code>bits</code> is less than or equal to <code>element</code>, when …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nOutputs <code>bits[0] &amp; bits[1] &amp; ... &amp; bits.last().unwrap()</code>.\nOutputs …\nOutputs <code>bits[0] | bits[1] | ... | bits.last().unwrap()</code>.\nConstructs a <code>LinearCombination</code> from <code>Self</code>’s variables …\nConvert a little-endian bitwise representation of a field …\nProduces a new variable of the appropriate kind (instance …\nCalculates <code>(NOT a) AND (NOT b)</code>.\nNegates <code>self</code>.\nPerforms an OR operation over the two operands, returning …\nOutputs <code>self | other</code>.\nConditionally selects one of <code>first</code> and <code>second</code> based on the …\nOutputs <code>1u8</code> if <code>self</code> is true, and <code>0u8</code> otherwise.\nGet the assigned value for <code>self</code>.\nGet the R1CS variable for <code>self</code>.\nPerforms an XOR operation over the two operands, returning …\nOutputs <code>self ^ other</code>.\nThis struct represent an unsigned 128 bit integer as a …\nPerform modular addition of <code>operands</code>.\nConstruct a constant <code>U128</code> from the native <code>u128</code> type.\nReturns the argument unchanged.\nConstruct <code>Self</code> from a slice of <code>Boolean</code>s.\nCalls <code>U::from(self)</code>.\nRotates <code>self</code> to the right by <code>by</code> steps, wrapping around.\nTurns <code>self</code> into the underlying little-endian bits.\nOutputs <code>self ^ other</code>.\nThis struct represent an unsigned 16 bit integer as a …\nPerform modular addition of <code>operands</code>.\nConstruct a constant <code>U16</code> from the native <code>u16</code> type.\nReturns the argument unchanged.\nConstruct <code>Self</code> from a slice of <code>Boolean</code>s.\nCalls <code>U::from(self)</code>.\nRotates <code>self</code> to the right by <code>by</code> steps, wrapping around.\nTurns <code>self</code> into the underlying little-endian bits.\nOutputs <code>self ^ other</code>.\nThis struct represent an unsigned 32 bit integer as a …\nPerform modular addition of <code>operands</code>.\nConstruct a constant <code>U32</code> from the native <code>u32</code> type.\nReturns the argument unchanged.\nConstruct <code>Self</code> from a slice of <code>Boolean</code>s.\nCalls <code>U::from(self)</code>.\nRotates <code>self</code> to the right by <code>by</code> steps, wrapping around.\nTurns <code>self</code> into the underlying little-endian bits.\nOutputs <code>self ^ other</code>.\nThis struct represent an unsigned 64 bit integer as a …\nPerform modular addition of <code>operands</code>.\nConstruct a constant <code>U64</code> from the native <code>u64</code> type.\nReturns the argument unchanged.\nConstruct <code>Self</code> from a slice of <code>Boolean</code>s.\nCalls <code>U::from(self)</code>.\nRotates <code>self</code> to the right by <code>by</code> steps, wrapping around.\nTurns <code>self</code> into the underlying little-endian bits.\nOutputs <code>self ^ other</code>.\nRepresents an interpretation of 8 <code>Boolean</code> objects as an …\nConstruct a constant <code>UInt8</code> from a <code>u8</code>\nConstruct a constant vector of <code>UInt8</code> from a vector of <code>u8</code>\nReturns the argument unchanged.\nConverts a little-endian byte order representation of bits …\nCalls <code>U::from(self)</code>.\nAllocates a slice of <code>u8</code>’s as public inputs by first …\nAllocates a slice of <code>u8</code>’s as private witnesses.\nOutputs <code>self ^ other</code>.\nSpecifies how to generate constraints that check for …\nIf <code>should_enforce == true</code>, enforce that <code>self</code> and <code>other</code> are …\nIf <code>should_enforce == true</code>, enforce that <code>self</code> and <code>other</code> are …\nEnforce that <code>self</code> and <code>other</code> are equal.\nEnforce that <code>self</code> and <code>other</code> are <em>not</em> equal.\nOutput a <code>Boolean</code> value representing whether …\nOutput a <code>Boolean</code> value representing whether …\nThis trait is a hack used to work around the lack of …\nA variable representing a field. Corresponds to the native …\nReturns a constant with value <code>v</code>.\nThis module contains a generic implementation of cubic …\nComputes <code>self + self</code>.\nSets <code>self = self + self</code>.\nThis module contains a generic implementation of prime …\nThis module contains a generic implementation of the …\nThis module contains a generic implementation of the …\nThis module contains a generic implementation of the …\nThis module contains a generic implementation of the …\nThis module contains a generic implementation of the …\nThis module contains a generic implementation of the …\nComputes the frobenius map over <code>self</code>.\nSets <code>self = self.frobenius_map()</code>.\nComputes <code>result</code> such that <code>self * result == Self::one()</code>.\nReturns a <code>Boolean</code> representing whether <code>self == Self::one()</code>.\nReturns a <code>Boolean</code> representing whether <code>self == Self::zero()</code>…\nReturns <code>(self / d)</code>. The constraint system will be …\nReturns <code>(self / d)</code>.\nEnforces that <code>self * other == result</code>.\nCoputes <code>-self</code>.\nSets <code>self = -self</code>.\nThis module contains a generic implementation of “…\nReturns the constant <code>F::one()</code>.\nComputes <code>self^S</code>, where S is interpreted as an little-endian\nComptues <code>self^bits</code>, where <code>bits</code> is a <em>little-endian</em> bit-wise …\nThis module contains a generic implementation of quadratic …\nComputes <code>self * self</code>.\nEnforces that <code>self * self == result</code>.\nSets <code>self = self.square()</code>.\nReturns the constant <code>F::zero()</code>.\nThis struct is the <code>R1CS</code> equivalent of the cubic extension …\nThis trait describes parameters that are used to implement …\nThe zero-th coefficient of this field element.\nThe first coefficient of this field element.\nThe second coefficient of this field element.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSets <code>self = self.mul_by_base_field_constant(fe)</code>.\nMultiplies a variable of the base field by the cubic …\nMultiply the base field of the <code>CubicExtVar</code> by the …\nMultiplies <code>self</code> by a sparse element which has …\nMultiplies <code>self</code> by a constant from the base field.\nMultiplies <code>self</code> by a sparse element which has <code>c2 == zero</code>.\nConstructs a <code>CubicExtVar</code> from the underlying coefficients.\nUse the Chung-Hasan asymmetric squaring formula.\nRepresents a variable in the constraint system whose value …\nRepresents a constant in the constraint system, which …\nRepresent variables corresponding to a field element in <code>F</code>.\nRepresents an allocated variable constant in the …\nOutputs <code>self + other</code>.\nOutput <code>self + other</code>\nAdd many allocated Fp elements together.\nEnforces that self == other if …\nEnforces that self != other if …\nThe constraint system that <code>self</code> was allocated in.\nOutput <code>self + self</code>\nThis function enforces the ordering between <code>self</code> and <code>other</code>…\nThis function enforces the ordering between <code>self</code> and <code>other</code>…\nHelper function to enforce that <code>self &lt;= (p-1)/2</code>.\nThis is a no-op for prime fields.\nConstructs <code>Self</code> from a <code>Boolean</code>: if <code>other</code> is false, this …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nOutputs <code>result</code> such that <code>result * self = 1</code>.\nThis function checks the ordering between <code>self</code> and <code>other</code>. …\nThis function checks the ordering between <code>self</code> and <code>other</code>. …\nOutputs the bit <code>self == other</code>.\nOutputs the bit <code>self != other</code>.\nOutputs <code>self * other</code>.\nOutput <code>self * other</code>\nEnforces that <code>self * other = result</code>.\nEnforce that <code>self * other == result</code>.\nOutput <code>-self</code>\nSets <code>self = -self</code>\nConstructs a new <code>AllocatedFp</code> from a (optional) value, a …\nOutputs <code>self * self</code>\nEnforces that <code>self * self = result</code>.\nEnforce that <code>self * self == result</code>.\nOutputs <code>self - other</code>.\nOutput <code>self - other</code>\nOutputs the unique bit-wise decomposition of <code>self</code> in …\nOutputs the unique byte decomposition of <code>self</code> in …\nOutputs the unique byte decomposition of <code>self</code> in …\nReturns the value assigned to <code>self</code> in the underlying …\nThe allocated variable corresponding to <code>self</code> in <code>self.cs</code>.\nA degree-12 extension field constructed as the tower of a …\nThe zero-th coefficient of this field element.\nThe first coefficient of this field element.\nSquares <code>self</code> when <code>self</code> is in the cyclotomic subgroup.\nMultiplies by a sparse element of the form …\nMultiplies by a sparse element of the form …\nLike <code>Self::cyclotomic_exp</code>, but additionally uses …\nA quadratic extension field constructed over a prime field.\nThe zero-th coefficient of this field element.\nThe first coefficient of this field element.\nA cubic extension field constructed over a prime field. …\nThe zero-th coefficient of this field element.\nThe first coefficient of this field element.\nThe second coefficient of this field element.\nA quartic extension field constructed as the tower of a …\nThe zero-th coefficient of this field element.\nThe first coefficient of this field element.\nA sextic extension field constructed as the tower of a …\nThe zero-th coefficient of this field element.\nThe first coefficient of this field element.\nA sextic extension field constructed as the tower of a …\nThe zero-th coefficient of this field element.\nThe first coefficient of this field element.\nThe second coefficient of this field element.\nMultiplies <code>self</code> by a sparse element which has …\nMultiplies <code>self</code> by a sparse element which has <code>c2 == zero</code>.\nThe allocated form of <code>NonNativeFieldMulResultVar</code> …\nThe allocated version of <code>NonNativeFieldVar</code> (introduced …\nConstant\nas a constant\nParameters for a specific <code>NonNativeFieldVar</code> instantiation\nAn intermediate representation especially for the result …\nA gadget for representing non-native (<code>TargetField</code>) field …\nAllocated gadget\nas an allocated gadget\nAdd a nonnative field element\nAdd unreduced elements.\nAdd a constant\nAdd native constant elem\nThe number of bits of the limb\nObtain the nonnative field element of a constant value\nCreate an <code>NonNativeFieldMulResultVar</code> from a constant\nReturn cs\nGet the CS\nConstraint system reference\nConstraint system reference\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert a <code>TargetField</code> element into limbs (not constraints) …\nObtain the limbs directly from a big int\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCompute the inverse of a nonnative field element\nWhether the limb representation is the normal form (using …\nThe limbs, each of which is a BaseField gadget.\nLimbs of the intermediate representations\nObtain the value of limbs\nMultiply a nonnative field element\nMultiply a constant\nfor advanced use, multiply and output the intermediate …\nThe <code>mul_without_reduce</code> for <code>NonNativeFieldVar</code>\nCompute the negate of a nonnative field element\nAllocates a new non-native field witness with value given …\nThe number of limbs (<code>BaseField</code> elements) used to represent …\nNumber of additions done over this gadget, using which the …\nObtain the nonnative field element of one\nUtilities for sampling parameters for non-native field …\nThe cumulative num of additions\nConstraints for reducing the result of a multiplication …\nReduce the <code>NonNativeFieldMulResultVar</code> back to …\nSubtract a nonnative field element\nSubtract a constant\nSubtract a nonnative field element, without the final …\nOutputs the unique byte decomposition of <code>self</code> in …\nObtain the value of a nonnative field element\nGet the value of the multiplication result\nObtain the nonnative field element of zero\nCreate a zero <code>NonNativeFieldMulResultVar</code> (used for …\nOptimized for constraints\nThe type of optimization target for the parameters …\nOptimized for weight\nA function to search for parameters for nonnative field …\nReturns the argument unchanged.\nObtain the parameters from a <code>ConstraintSystem</code>’s cache or …\nCalls <code>U::from(self)</code>.\nThis struct is the <code>R1CS</code> equivalent of the quadratic …\nThis trait describes parameters that are used to implement …\nThe zero-th coefficient of this field element.\nThe first coefficient of this field element.\nThis is only to be used when the element is <em>known</em> to be in …\nSquares <code>self</code> when <code>self</code> is in the cyclotomic subgroup.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSets <code>self = self.mul_by_base_field_constant(fe)</code>.\nMultiplies a variable of the base field by the quadratic …\nMultiply the base field of the <code>QuadExtVar</code> by the …\nMultiplies by a sparse element of the form …\nMultiplies by a sparse element of the form …\nMultiplies <code>self</code> by a constant from the base field.\nConstructs a <code>QuadExtVar</code> from the underlying coefficients.\nLike <code>Self::cyclotomic_exp</code>, but additionally uses …\nThis is only to be used when the element is <em>known</em> to be in …\nA variable that represents a curve point for the curve <code>C</code>.\nA hack used to work around the lack of implied bounds.\nReturns a constant with value <code>v</code>.\nThis module contains implementations of arithmetic for …\nComputes <code>self + self</code>.\nSets <code>self = self + self</code>.\nEnforce that <code>self</code> is in the prime-order subgroup.\nReturns a <code>Boolean</code> representing whether <code>self == Self::zero()</code>…\nCoputes <code>-self</code>.\nAllocates a variable in the subgroup without checking if it…\nComputes <code>Σⱼ(scalarⱼ * baseⱼ)</code> for all j, where …\nComputes a <code>I * self</code> in place, where <code>I</code> is a <code>Boolean</code> …\nComputes <code>bits * self</code>, where <code>bits</code> is a little-endian <code>Boolean</code>…\nReturns the constant <code>F::zero()</code>. This is the identity of …\nThis module generically implements arithmetic for Short …\nThis module generically implements arithmetic for Twisted …\nAn affine representation of a curve point.\nAn implementation of arithmetic for Short Weierstrass …\nThis module provides a generic implementation of G1 and G2 …\nEnforce that <code>self</code> is in the prime-order subgroup.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIs <code>self</code> the point at infinity.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis module provides a generic implementation of G1 and G2 …\nThis module provides a generic implementation of G1 and G2 …\nConstructs <code>Self</code> from an <code>(x, y, z)</code> coordinate triple.\nAllocates a new variable without performing an on-curve …\nThis module provides a generic implementation of elliptic …\nComputes <code>bits * self</code>, where <code>bits</code> is a little-endian <code>Boolean</code>…\nConvert this point into affine form.\nReturns the value assigned to <code>self</code> in the underlying …\nThe x-coordinate.\nThe x-coordinate.\nThe y-coordinate.\nThe y-coordinate.\nThe z-coordinate.\nRepresents an affine point on G1. Should be used only for …\nRepresents the cached precomputation that can be performed …\nRepresents a projective point in G1.\nRepresents an affine point on G2. Should be used only for …\nRepresents the cached precomputation that can be performed …\nRepresents a projective point in G2.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstructs <code>Self</code> from a <code>G1Var</code>.\nConstructs <code>Self</code> from a <code>G2Var</code>.\nIs <code>self</code> the point at infinity.\nIs <code>self</code> the point at infinity.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the value assigned to <code>self</code> in the underlying …\nThe x-coordinate.\nThe x-coordinate.\nThe x-coordinate.\nThe x-coordinate.\nThe y-coordinate.\nThe y-coordinate.\nThe y-coordinate.\nThe y-coordinate.\nThe z-coordinate.\nThe z-coordinate.\nRepresents the cached precomputation that can be performed …\nRepresents a projective point in G1.\nRepresents the cached precomputation that can be performed …\nRepresents a projective point in G2.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstructs <code>Self</code> from a <code>G1Var</code>.\nConstructs <code>Self</code> from a <code>G2Var</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the value assigned to <code>self</code> in the underlying …\nReturns the value assigned to <code>self</code> in the underlying …\nThe x-coordinate.\nThe x-coordinate.\nThe y-coordinate.\nThe y-coordinate.\nThe z-coordinate.\nThe z-coordinate.\nRepresents the cached precomputation that can be performed …\nRepresents a projective point in G1.\nRepresents the cached precomputation that can be performed …\nRepresents a projective point in G2.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstructs <code>Self</code> from a <code>G1Var</code>.\nConstructs <code>Self</code> from a <code>G2Var</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the value assigned to <code>self</code> in the underlying …\nReturns the value assigned to <code>self</code> in the underlying …\nThe x-coordinate.\nThe x-coordinate.\nThe y-coordinate.\nThe y-coordinate.\nThe z-coordinate.\nThe z-coordinate.\nAn affine representation of a prime order curve point that …\nPerforms an addition without checking that other != ±self.\nDoubles <code>self</code>. As this is a prime order curve point, the …\nComputes <code>(self + other) + self</code>. This method requires only 5\nDoubles <code>self</code> in place.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nConverts self into a non-zero projective point.\nThe x-coordinate.\nThe y-coordinate.\nAn implementation of arithmetic for Twisted Edwards curves …\nAn implementation of arithmetic for Montgomery curves that …\nEnforce that <code>self</code> is in the prime-order subgroup.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts a Twisted Edwards curve point to coordinates for …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts <code>self</code> into a Twisted Edwards curve point variable.\nConstructs <code>Self</code> from an <code>(x, y)</code> coordinate pair.\nConstructs <code>Self</code> from an <code>(x, y)</code> coordinate triple.\nAllocates a new variable without performing an on-curve …\nConverts a Twisted Edwards curve point to coordinates for …\nCompute a scalar multiplication of <code>bases</code> with respect to …\nThe x-coordinate.\nThe x-coordinate.\nThe y-coordinate.\nThe y-coordinate.\nAn variable representing cached precomputation  that can …\nAn variable representing an element of <code>G1</code>. This is the …\nAn variable representing cached precomputation  that can …\nAn variable representing an element of <code>G2</code>. This is the …\nAn variable representing an element of <code>GT</code>. This is the …\nSpecifies the constraints for computing a pairing in the …\nThis module implements pairings for BLS12 bilinear groups.\nComputes a final exponentiation over <code>p</code>.\nComputes a multi-miller loop between elements of <code>p</code> and <code>q</code>.\nThis module implements pairings for MNT4 bilinear groups.\nThis module implements pairings for MNT6 bilinear groups.\nComputes a pairing over <code>p</code> and <code>q</code>.\nPerforms the precomputation to generate <code>Self::G1PreparedVar</code>…\nPerforms the precomputation to generate <code>Self::G2PreparedVar</code>…\nComputes a product of pairings over the elements in <code>p</code> and <code>q</code>…\nSpecifies the constraints for computing a pairing in a …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA variable corresponding to <code>ark_ec::mnt4::GT</code>.\nSpecifies the constraints for computing a pairing in a …\nThe zero-th coefficient of this field element.\nThe first coefficient of this field element.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA variable corresponding to <code>ark_ec::mnt6::GT</code>.\nSpecifies the constraints for computing a pairing in a …\nThe zero-th coefficient of this field element.\nThe first coefficient of this field element.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nModules for working with polynomials in coefficient forms.\nDefines an evaluation domain over a prime field. The …\ndimension of evaluation domain, which is log2(size of …\nReturns offset, offset<em>g, offset</em>g^2, …, offset*…\nReturns the argument unchanged.\ngenerator of subgroup g\nCalls <code>U::from(self)</code>.\nConstruct an evaluation domain with the given offset.\nWhat is the offset of <code>self</code>?\norder of the domain\nFor domain <code>h&lt;g&gt;</code> with dimension <code>n</code>, <code>position</code> represented by …\nFor domain <code>h&lt;g&gt;</code> with dimension <code>n</code>, <code>position</code> represented by …\nSize of the domain\nStruct describing vanishing polynomial for a …\nh^|H|\nlog_2(|H|)\nEvaluates the vanishing polynomial without generating the …\nEvaluates the constraints and just gives you the gadget …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nreturns a VanishingPolynomial of coset <code>H = h&lt;g&gt;</code>.\n|H|\nStores a UV polynomial in evaluation form.\nPerforms the <code>+=</code> operations, assuming <code>domain.offset</code> is …\nPerforms the <code>/=</code> operations, assuming <code>domain.offset</code> is …\nEvaluations of univariate polynomial over domain\nReturns the argument unchanged.\nConstruct <code>Self</code> from evaluations and a domain. <code>interpolate</code> …\nPrecompute necessary calculation for lagrange …\nReturns constraints for Interpolating and evaluating at …\nCalls <code>U::from(self)</code>.\nOptional Lagrange Interpolator. Useful for lagrange …\nPerforms the <code>*</code> operations, assuming <code>domain.offset</code> is equal.\nPerforms the <code>*=</code> operations, assuming <code>domain.offset</code> is …\nPerforms the <code>-=</code> operations, assuming <code>domain.offset</code> is …\nStruct describing Lagrange interpolation for a …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns a lagrange interpolator, given the domain …\nModule defining data structures for univariate polynomials.\nA dense univariate polynomial represented in coefficient …\nStores a polynomial in coefficient form, where coeffcient …\nThe coefficient of <code>x^i</code> is stored at location <code>i</code> in …\nEvaluates <code>self</code> at the given <code>point</code> and just gives you the …\nReturns the argument unchanged.\nConstructs a new polynomial from a list of coefficients.\nConstructs a new polynomial from a list of coefficients.\nCalls <code>U::from(self)</code>.\nGenerates constraints for selecting between one of two …\nThe type of values being looked up.\nThe type of values being looked up.\nUses three bits to perform a lookup into a table, where …\nPerforms a lookup in a 4-element table using two bits.\nIf <code>cond == &amp;Boolean::TRUE</code>, then this returns <code>true_value</code>; …\nReturns an element of <code>values</code> whose index in represented by …\nInterprets the slice <code>bits</code> as a two-bit integer …\nInterprets the slice <code>bits</code> as a two-bit integer …")