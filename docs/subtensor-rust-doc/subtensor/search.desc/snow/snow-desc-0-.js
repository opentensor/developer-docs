searchState.loadedDescShard("snow", 0, "The <code>snow</code> crate is a straightforward, Hard To Fuck Up™ …\nGenerates a <code>HandshakeState</code> and also validates that all the …\nA state machine encompassing the handshake phase of a …\nA keypair object returned by <code>Builder::generate_keypair()</code>\nA state machine encompassing the transport phase of a …\nA state machine encompassing the transport phase of a …\nBuild a <code>HandshakeState</code> for the side who will initiate the …\nBuild a <code>HandshakeState</code> for the side who will be responder …\nAll error types used by Snow operations.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate a new asymmetric keypair (for use as a static …\nGet the handshake hash.\nGet the remote party’s static public key, if available.\nGet the remote party’s static public key, if available.\nGet the remote party’s static public key, if available.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert this <code>HandshakeState</code> into a <code>StatelessTransportState</code> …\nConvert this <code>HandshakeState</code> into a <code>TransportState</code> with an …\nCheck if the handshake is finished and …\nCheck if this session was started with the “initiator” …\nCheck if this session was started with the “initiator” …\nCheck if this session was started with the “initiator” …\nCheck whether it is our turn to send in the handshake …\nYour static private key (can be generated with …\nAll structures related to Noise parameter definitions …\nThe private asymmetric key\nArbitrary data to be hashed in to the handshake hash value.\nSpecify a PSK (only used with <code>NoisePSK</code> base parameter)\nThe public asymmetric key\nReads a noise message from <code>input</code>\nReads a noise message from <code>input</code>\nReads a noise message from <code>input</code>\nGet the forthcoming inbound nonce value.\nGenerates a new key for the ingress symmetric cipher …\nGenerates a new key for the ingress symmetric cipher …\nSet a new key for the initiator-egress symmetric cipher.\nSet a new key for the initiator-egress symmetric cipher.\nSet a new key for the one or both of the initiator-egress …\nSet a new key for the one or both of the initiator-egress …\nGenerates a new key for the egress symmetric cipher …\nGenerates a new key for the egress symmetric cipher …\nSet a new key for the responder-egress symmetric cipher.\nSet a new key for the responder-egress symmetric cipher.\nThe responder’s static public key.\nThe wrappers around the default collection of cryptography …\nGet the forthcoming outbound nonce value.\nSet the preshared key at the specified location. It is up …\nSets the <em>receiving</em> CipherState’s nonce. Useful for using …\nThe traits for cryptographic implementations that can be …\nThis method will return <code>true</code> if the <em>previous</em> write payload …\nCreate a Builder with a custom crypto resolver.\nConstruct a message from <code>payload</code> (and pending handshake …\nConstruct a message from <code>payload</code> (and pending handshake …\nConstruct a message from <code>payload</code> (and pending handshake …\nDecryption failed.\nDiffie-hellman failed.\nAll errors in snow will include an <code>ErrorKind</code>.\nThe nonce counter attempted to go higher than (2^64) - 1\nInitialization failure, at a provided stage.\nThe various stages of initialization used to help identify …\nInvalid input.\nThe noise pattern failed to parse.\nThe various stages of initialization used to help identify …\nMissing prerequisite.\nA prerequisite that may be missing.\nA state error.\nSpecific errors in the state machine.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nI recommend you choose <code>Noise</code>.\nOne of <code>ChaChaPoly</code> or <code>AESGCM</code>, per the spec.\nOne of <code>25519</code> or <code>448</code>, per the spec.\nModify the base pattern to its “fallback” form\nThe pattern/modifier combination choice (no primitives …\nA modifier applied to the base pattern as defined in the …\nHandshake modifiers that will be used during key exchange …\nOne of the patterns as defined in the Handshake Pattern …\nOne of the supported SHA-family or BLAKE-family hash …\nThe set of choices (as specified in the Noise spec) that …\nInsert a PSK to mix at the associated position\nThe equivalent of the <code>ToString</code> trait, but for <code>&amp;&#39;static str</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether the handshake choice includes the fallback …\nIf the protocol is one-way only\nWhether the handshake choice includes one or more PSK …\nList of parsed modifiers.\nThe modifier(s) requested for the base pattern\nWhether this pattern demands a remote public key …\nWhether this pattern requires a long-term static key.\nConstruct a new NoiseParams via specifying enums directly.\nThe base pattern itself\nBoxed CryptoResolver\nAn object that resolves the providers of Noise crypto …\nA helper resolver that can opportunistically use one …\nA resolver that chooses ring-backed primitives when …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new <code>FallbackResolver</code> that holds the primary and …\nProvide an implementation of the Cipher trait for the …\nProvide an implementation of the Dh trait for the given …\nProvide an implementation of the Hash trait for the given …\nProvide an implementation of the Random trait or None if …\nCipher operations\nDiffie-Hellman operations\nHashing operations\nCSPRNG operations\nThe block length for the primitive\nDecrypt (with associated data) a given ciphertext.\nCalculate a Diffie-Hellman exchange.\nEncrypt (with associated data) a given plaintext.\nGenerate a new private key\nThe final hash digest length for the primitive\nDerive keys as specified in the Noise spec.\nCalculate HMAC, as specified in the Noise spec.\nProvide input to the internal state\nThe string that the Noise spec defines for the primitive\nThe string that the Noise spec defines for the primitive\nThe string that the Noise spec defines for the primitive\nThe length in bytes of a private key for this primitive\nGet the private key\nThe length in bytes of a public key for this primitive\nGet the public key\nRekey according to Section 4.2 of the Noise Specification, …\nReset the internal state\nGet the resulting hash\nSet the private key\nSet the key")