searchState.loadedDescShard("evm_core", 0, "Core layer for EVM.\n<code>ADD</code>\n<code>ADDMOD</code>\n<code>ADDRESS</code>\n<code>AND</code>\nReading basic account from storage. Fixed size.\nReading address code from storage. Dynamic size.\n<code>BALANCE</code>\n<code>BASEFEE</code>\n<code>BLOCKHASH</code>\n<code>BYTE</code>\n<code>CALL</code>\n<code>CALLCODE</code>\n<code>CALLDATACOPY</code>\n<code>CALLDATALOAD</code>\n<code>CALLDATASIZE</code>\n<code>CALLER</code>\n<code>CALLVALUE</code>\n<code>CHAINID</code>\n<code>CODECOPY</code>\n<code>CODESIZE</code>\n<code>COINBASE</code>\n<code>CREATE</code>\n<code>CREATE2</code>\nThe environment explicitly set call errors as fatal error.\nCall stack is too deep (runtime).\nCapture represents the result of execution.\nCreate opcode encountered collision (runtime).\nCreate init code exceeds limit (runtime).\nAttempt to create an empty account (runtime, unused).\n<code>DELEGATECALL</code>\n<code>DIFFICULTY</code>\n<code>DIV</code>\n<code>DUPn</code>\nEncountered the designated invalid opcode.\nSee EIP-3541\n<code>EQ</code>\n<code>EXP</code>\n<code>EXTCODECOPY</code>\n<code>EXTCODEHASH</code>\n<code>EXTCODESIZE</code>\nMachine returns a normal EVM error.\nThe machine has exited. It cannot be executed again.\nExit error reason.\nExit fatal reason.\nExit reason.\nExit revert reason.\nExit succeed reason.\nOperations for recording external costs\nMachine encountered an error that is not supposed to be …\n<code>GAS</code>\n<code>GASLIMIT</code>\n<code>GASPRICE</code>\n<code>GT</code>\n<code>INVALID</code>\n<code>ISZERO</code>\nInvalid opcode during execution or starting byte is 0xef. …\nJump destination is invalid.\nAn opcode accesses memory region, but the region is …\nBasic check for account emptiness. Fixed size.\n<code>JUMP</code>\n<code>JUMPDEST</code>\n<code>JUMPI</code>\n<code>LOGn</code>\n<code>LT</code>\n<code>MLOAD</code>\n<code>MOD</code>\n<code>MSIZE</code>\n<code>MSTORE</code>\n<code>MSTORE8</code>\n<code>MUL</code>\n<code>MULMOD</code>\nCore execution layer for EVM.\nNonce reached maximum value of 2^64-1 …\nA sequencial memory. It uses Rust’s <code>Vec</code> for internal …\n<code>NOT</code>\n<code>NUMBER</code>\nThe operation is not supported.\n<code>OR</code>\n<code>ORIGIN</code>\nOpcode enum. One-to-one corresponding to an <code>u8</code> value.\nOther normal errors.\nOther fatal errors.\nNot enough fund to start the execution (runtime).\nExecution runs out of gas (runtime).\nAn opcode accesses external information, but the request …\n<code>PC</code>\nPC underflowed (unused).\n<code>POP</code>\n<code>PUSHn</code>\n<code>RETURN</code>\n<code>RETURNDATACOPY</code>\n<code>RETURNDATASIZE</code>\n<code>REVERT</code>\nMachine encountered an explicit return.\nMachine encountered an explicit revert.\nMachine encountered an explicit revert.\n<code>SAR</code>\n<code>SDIV</code>\n<code>SELFBALANCE</code>\n<code>SGT</code>\n<code>SHA3</code>\n<code>SHL</code>\n<code>SHR</code>\n<code>SIGNEXTEND</code>\n<code>SLOAD</code>\n<code>SLT</code>\n<code>SMOD</code>\n<code>SSTORE</code>\n<code>STATICCALL</code>\n<code>STOP</code>\n<code>SUB</code>\n<code>SUICIDE</code>\n<code>SWAPn</code>\nEVM stack.\nTrying to push into a stack over stack limit.\nTrying to pop from an empty stack.\nMachine encountered an explicit stop.\nMachine has succeeded.\nMachine encountered an explicit suicide.\n<code>TIMESTAMP</code>\nTrap which indicates that an <code>ExternalOpcode</code> has to be …\nThe machine has trapped. It is waiting for external …\nThe trap (interrupt) is unhandled.\nMapping of valid jump destination from code.\nWriting to storage (Number of bytes written).\n<code>XOR</code>\nCopy <code>data</code> into the memory, of given <code>len</code>.\nReturn the full memory.\nStack data.\nGet the effective length.\nExplicit exit of the machine. Further step will return …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet memory region at given offset.\nInspect the machine’s next opcode and current stack.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn true if current effective memory range is zero.\nWhether the stack is empty.\nReturns true if the valids list is empty\nWhether the exit is error.\nWhether the exit is fatal.\nWhether the opcode is a push opcode.\nWhether the exit is revert.\nWhether the exit is succeeded.\nReturns <code>true</code> if the position is a valid jump destination. …\nGet the length of the current memory range.\nStack length.\nGet the length of the valid mapping. This is the same as …\nMemory limit.\nStack limit.\nReference of machine memory.\nMutable reference of machine memory.\nCreate a new machine with given code and data.\nCreate a new memory with the given limit.\nCreate a new stack with given limit.\nCreate a new valid mapping from given code bytes.\nPeek a value at given index for the stack, where the top of\nPop a value from the stack. If the stack is already empty, …\nReturn a reference of the program counter.\nPush a new value into the stack. If it will exceed the …\nResize the memory, making it cover to <code>end</code>, with 32 bytes …\nResize the memory, making it cover the memory region of `…\nCopy and get the return value of the machine, if any.\nLoop stepping the machine, until it stops.\nSet memory region at given offset. The offset and value is …\nSet a value at given index for the stack, where the top of …\nReference of machine stack.\nMutable reference of machine stack.\nStep the machine, executing one opcode. It then returns.")