searchState.loadedDescShard("ark_models_ext", 0, "Affine coordinates for a point on a twisted Edwards curve, …\nThe affine representation of this element.\nThe canonical representation of an elliptic curve group …\nThe field over which this curve is defined.\nThe finite field over which this curve is defined.\nCoefficient <code>a</code> of the curve equation.\nCoefficient <code>a</code> of the curve equation.\nCoefficient <code>b</code> of the curve equation.\nCoefficient <code>d</code> of the curve equation.\nAn opaque representation of an elliptic curve group …\nType representing an element of the full elliptic curve …\nGenerator of the prime-order subgroup.\nRepresents (elements of) a group of prime order <code>r</code>.\nThe projective representation of points on this curve.\nConstants and convenience functions that collectively …\nModel parameters for the Montgomery curve that is …\n<code>Projective</code> implements Extended Twisted Edwards Coordinates …\nThe scalar field <code>F_r</code>, where <code>r</code> is the order of this group.\nConstants and convenience functions that collectively …\nModel parameters for the Twisted Edwards curve that is …\nFlags to be encoded into the serialization. The default …\nPerforms cofactor clearing. The default method is simply …\nPerforms cofactor clearing. The default method is simply …\nPerforms cofactor clearing. The default method is simply …\nIf <code>validate</code> is <code>Yes</code>, calls <code>check()</code> to make sure the element …\nDoubles <code>self</code>.\nDouble <code>self</code> in place.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns a group element if the set of bytes forms a valid …\nReturns a fixed generator of this group.\nReturns a fixed generator of unknown exponent.\nAttempts to construct an affine point given an …\nAttempts to recover the x-coordinate given an …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts <code>self</code> into the affine representation.\nConverts self into the projective representation.\nChecks that the current point is in the prime order …\nChecks if <code>self</code> is in the subgroup having order equaling …\nChecks that the current point is on the elliptic curve.\nIs <code>self</code> the point at infinity?\nIs this point the identity?\nDefault implementation for multi scalar multiplication\nPerforms multi-scalar multiplication, without checking …\nPerforms multi-scalar multiplication, without checking …\nOptimized implementation of multi-scalar multiplication.\nOptimized implementation of multi-scalar multiplication.\nStreaming multi-scalar multiplication algorithm with …\nStreaming multi-scalar multiplication algorithm with …\nComputes an inner product between the <code>PrimeField</code> elements …\nComputes an inner product between the <code>PrimeField</code> elements …\nDefault implementation of group multiplication for affine …\nPerforms scalar multiplication of this element.\nPerforms scalar multiplication of this element with mixed …\nComputes <code>other * self</code>, where <code>other</code> is a <em>big-endian</em> bit …\nHelper method for computing <code>elem * Self::COEFF_A</code>.\nMultiplies this element by the cofactor.\nMultiplies this element by the inverse of the cofactor in …\nMultiplies this element by the cofactor and output the …\nMultiplies this element by the cofactor and output the …\nDefault implementation of group multiplication for …\nConstruct a new group element in a way while enforcing …\nConstruct a new group element in a way while enforcing …\nConstruct a new group element without checking whether the …\nConstruct a new group element without checking whether the …\nNormalizes a slice of group elements into affine.\nIf uncompressed, serializes both x and y coordinates. If …\nReturns the x coordinate of this affine point.\nX coordinate of the point represented as a field element\nReturns the x and y coordinates of this affine point.\nReturns the y coordinate of this affine point.\nY coordinate of the point represented as a field element\nReturns the point at infinity.\nConstruct the identity of the group\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCoefficient <code>a_1</code> of <code>f(y) = a_1 * (y + a_2) * (y + a_3)</code>.\nCoefficient <code>a_2</code> of <code>f(y) = a_1 * (y + a_2) * (y + a_3)</code>.\nCoefficient <code>a_3</code> of <code>f(y) = a_1 * (y + a_2) * (y + a_3)</code>.\nCoefficient <code>b_1</code> of <code>g(y) = b_1 * (y + b_2) * (y + b_3)</code>.\nCoefficient <code>b_2</code> of <code>g(y) = b_1 * (y + b_2) * (y + b_3)</code>.\nCoefficient <code>b_3</code> of <code>g(y) = b_1 * (y + b_2) * (y + b_3)</code>.\nCoefficient <code>c_1</code> of <code>h(y) = (y + c_1) * (y + c_2)</code>.\nCoefficient <code>c_2</code> of <code>h(y) = (y + c_1) * (y + c_2)</code>.\nThe first element of the matrix for scalar decomposition.\nThe second element of the matrix for scalar decomposition.\nThe third element of the matrix for scalar decomposition.\nThe forth element of the matrix for the scalar …\nA representation of curve points that enables efficient …\nThe GLV parameters for computing the endomorphism and …\nMaps a point G to phi(G):= lambda G where psi is the …\nPerforms GLV multiplication.\nDecomposes a scalar s into k1, k2, s.t. s = k1 + lambda k2,\nBase field that the curve is defined over.\nThe cofactor of this curve, represented as a sequence of …\nElliptic curves can be represented via different “models…\nFinite prime field corresponding to an appropriate …\nWhat kind of twist is this?\nA particular BLS12 group can have G2 being either a …\nParameterizes the BLS12 family.\nIs <code>Self::X</code> negative?\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<code>X / Z</code> projection of the affine <code>X</code>\n<code>Y / Z</code> projection of the affine <code>Y</code>\nProjective multiplicative inverse. Will be <code>0</code> only at …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<code>X / Z</code> projection of the affine <code>X</code>\n<code>Y / Z</code> projection of the affine <code>Y</code>\nProjective multiplicative inverse. Will be <code>0</code> only at …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<code>X / Z</code> projection of the affine <code>X</code>\n<code>Y / Z</code> projection of the affine <code>Y</code>\nProjective multiplicative inverse. Will be <code>0</code> only at …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<code>X / Z</code> projection of the affine <code>X</code>\n<code>Y / Z</code> projection of the affine <code>Y</code>\nProjective multiplicative inverse. Will be <code>0</code> only at …\nThis is the base field of the G1 group and base prime …\nAn element in G1.\nA G1 element that has been preprocessed for use in a …\nAn element of G2.\nThe affine representation of an element in G2.\nA G2 element that has been preprocessed for use in a …\nRepresents the output of the Miller loop of the pairing.\nCollection of types (mainly fields and curves) that …\nRepresents the target group of a pairing. This struct is a …\nThis is the scalar field of the G1/G2 groups.\nThe extension field that hosts the target group of the …\nPerforms final exponentiation of the result of a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nComputes the Miller loop over <code>a</code> and <code>b</code>.\nComputes the product of Miller loops for some number of …\nComputes a “product” of pairings.\nPerforms multiple pairing operations\nPreprocesses a G1 element for use in a pairing.\nPreprocesses a G2 element for use in a pairing.\nThe identity element, or “zero”, of the group is the …\nAffine coordinates for a point on an elliptic curve in …\nCoefficient <code>a</code> of the curve equation.\nCoefficient <code>b</code> of the curve equation.\nGenerator of the prime-order subgroup.\nRepresents the point at infinity by setting the setting …\nJacobian coordinates for a point on an elliptic curve in …\nConstants and convenience functions that collectively …\nFlags to be encoded into the serialization. The default …\nRepresents a point with negative y-coordinate by setting …\nRepresents a point with positive y-coordinate by setting …\nUsing …\nHelper method for computing <code>elem + Self::COEFF_B</code>.\nPerforms cofactor clearing. The default method is simply …\nPerforms cofactor clearing. The default method is simply …\nIf <code>validate</code> is <code>Yes</code>, calls <code>check()</code> to make sure the element …\nSets <code>self = 2 * self</code>. Note that Jacobian formulae are …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAttempts to construct an affine point given an …\nReturns the two possible y-coordinates corresponding to …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if the provided curve point is in the prime-order …\nChecks if <code>self</code> is in the subgroup having order that …\nChecks if <code>self</code> is a valid point on the curve.\nChecks whether <code>self.z.is_zero()</code>.\nDefault implementation for multi scalar multiplication\nDefault implementation of group multiplication for affine …\nHelper method for computing <code>elem * Self::COEFF_A</code>.\nMultiplies this element by the cofactor and output the …\nDefault implementation of group multiplication for …\nIf <code>self.is_zero()</code>, returns <code>self</code> (<code>== Self::zero()</code>). Else, …\nConstructs a group element from x and y coordinates. …\nConstructs a new group element in a way while enforcing …\nConstructs a group element from x and y coordinates.\nConstructs a new group element without checking whether …\nNormalizes a slice of projective elements so that …\nIf uncompressed, serializes both x and y coordinates as …\n<code>X / Z</code> projection of the affine <code>X</code>\n<code>Y / Z</code> projection of the affine <code>Y</code>\nProjective multiplicative inverse. Will be <code>0</code> only at …\nReturns the point at infinity, which always has Z = 0.\nAffine coordinates for a point on a twisted Edwards curve, …\nCoefficient <code>a</code> of the curve equation.\nCoefficient <code>a</code> of the curve equation.\nCoefficient <code>b</code> of the curve equation.\nCoefficient <code>d</code> of the curve equation.\nGenerator of the prime-order subgroup.\nConstants and convenience functions that collectively …\nModel parameters for the Montgomery curve that is …\n<code>Projective</code> implements Extended Twisted Edwards Coordinates …\nConstants and convenience functions that collectively …\nModel parameters for the Twisted Edwards curve that is …\nFlags to be encoded into the serialization. The default …\nPerforms cofactor clearing. The default method is simply …\nIf <code>validate</code> is <code>Yes</code>, calls <code>check()</code> to make sure the element …\nChecks that the current point is in the prime order …\nDefault implementation for multi scalar multiplication\nDefault implementation of group multiplication for affine …\nHelper method for computing <code>elem * Self::COEFF_A</code>.\nDefault implementation of group multiplication for …\nIf uncompressed, serializes both x and y coordinates. If …\nX coordinate of the point represented as a field element\nY coordinate of the point represented as a field element\nCoefficient <code>a_1</code> of <code>f(y) = a_1 * (y + a_2) * (y + a_3)</code>.\nCoefficient <code>a_2</code> of <code>f(y) = a_1 * (y + a_2) * (y + a_3)</code>.\nCoefficient <code>a_3</code> of <code>f(y) = a_1 * (y + a_2) * (y + a_3)</code>.\nCoefficient <code>b_1</code> of <code>g(y) = b_1 * (y + b_2) * (y + b_3)</code>.\nCoefficient <code>b_2</code> of <code>g(y) = b_1 * (y + b_2) * (y + b_3)</code>.\nCoefficient <code>b_3</code> of <code>g(y) = b_1 * (y + b_2) * (y + b_3)</code>.\nCoefficient <code>c_1</code> of <code>h(y) = (y + c_1) * (y + c_2)</code>.\nCoefficient <code>c_2</code> of <code>h(y) = (y + c_1) * (y + c_2)</code>.\nThe first element of the matrix for scalar decomposition.\nThe second element of the matrix for scalar decomposition.\nThe third element of the matrix for scalar decomposition.\nThe forth element of the matrix for the scalar …\nA representation of curve points that enables efficient …\nThe GLV parameters for computing the endomorphism and …\nMaps a point G to phi(G):= lambda G where psi is the …\nPerforms GLV multiplication.\nDecomposes a scalar s into k1, k2, s.t. s = k1 + lambda k2,\nStruct for the chunked Pippenger algorithm.\nHash map struct for Pippenger algorithm.\nPerforms multi-scalar multiplication, without checking …\nOptimized implementation of multi-scalar multiplication.\nStreaming multi-scalar multiplication algorithm with …\nComputes an inner product between the <code>PrimeField</code> elements …\nA space-efficient implementation of Pippenger’s …\nStruct for the chunked Pippenger algorithm.\nHash map struct for Pippenger algorithm.\nA helper type that contains all the context required for …\nAffine coordinates for a point on a twisted Edwards curve, …\nCoefficient <code>a</code> of the curve equation.\nCoefficient <code>a</code> of the curve equation.\nCoefficient <code>b</code> of the curve equation.\nCoefficient <code>d</code> of the curve equation.\nGenerator of the prime-order subgroup.\nConstants and convenience functions that collectively …\nModel parameters for the Montgomery curve that is …\n<code>Projective</code> implements Extended Twisted Edwards Coordinates …\nConstants and convenience functions that collectively …\nModel parameters for the Twisted Edwards curve that is …\nFlags to be encoded into the serialization. The default …\nPerforms cofactor clearing. The default method is simply …\nIf <code>validate</code> is <code>Yes</code>, calls <code>check()</code> to make sure the element …\nChecks that the current point is in the prime order …\nDefault implementation for multi scalar multiplication\nDefault implementation of group multiplication for affine …\nHelper method for computing <code>elem * Self::COEFF_A</code>.\nDefault implementation of group multiplication for …\nIf uncompressed, serializes both x and y coordinates. If …\nX coordinate of the point represented as a field element\nY coordinate of the point represented as a field element\nStruct for the chunked Pippenger algorithm.\nHash map struct for Pippenger algorithm.\nAdd a new (base, scalar) pair into the instance.\nAdd a new (base, scalar) pair into the hash map.\nOutput the final Pippenger algorithm result.\nUpdate the final result with (base, scalar) pairs in the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInitialize a chunked Pippenger instance with default …\nProduce a new hash map with the maximum msm buffer size.\nA space-efficient implementation of Pippenger’s …\nInitialize a chunked Pippenger instance with the given …\nStruct for the chunked Pippenger algorithm.\nHash map struct for Pippenger algorithm.\nA helper type that contains all the context required for …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nComputes scalar multiplication of a group element <code>g</code> by …\nComputes scalar multiplication of a group element by <code>scalar</code>…\nConstructs a new context for a window of size <code>window_size</code>.")