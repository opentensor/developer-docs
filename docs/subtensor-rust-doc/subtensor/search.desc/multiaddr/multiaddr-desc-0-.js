searchState.loadedDescShard("multiaddr", 0, "Implementation of multiaddr in Rust.\nFailed to parse the URL.\nContains the error value\nError types\nError while parsing an URL.\nSome information in the URL would be lost. Never returned …\nIterator over <code>Multiaddr</code> <code>Protocol</code>s.\nContains the “port” to contact. Similar to TCP or UDP, …\nRepresentation of a Multiaddr.\nContains the success value\nRepresents an Onion v3 address\nIdentifier of a peer of the network.\nIterator over the string idtenfiers of the protocols (not …\n<code>Protocol</code> describes all possible multiaddress protocols.\nThe URL scheme was not recognized.\nConsume this instance and create an owned version …\nTurn this <code>Protocol</code> into one that owns its data, thus being …\nCreate a new, empty multiaddress.\nChecks whether the given <code>Multiaddr</code> is a suffix of this …\nConvert a Multiaddr to a string\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nParse a single <code>Protocol</code> value from its byte slice …\nParses a <code>PeerId</code> from bytes.\nTries to turn a <code>Multihash</code> into a <code>PeerId</code>.\nBuilds a <code>PeerId</code> from a public key.\nParse a protocol value from the given iterator of string …\nAttempts to parse an URL into a multiaddress.\nAttempts to parse an URL into a multiaddress. Ignores …\nReturn the hash of the public key as bytes\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if the length of this multiaddress is 0.\nReturns the components of this multiaddress.\nReturn the length in bytes of this multiaddress.\nEasy way for a user to create a <code>Multiaddr</code>.\nPops the last <code>Protocol</code> of this multiaddr, or <code>None</code> if the …\nReturn the port\nReturns &amp;str identifiers for the protocol names themselves.\nAdds an already-parsed address component to the end of …\nGenerates a random peer ID from a cryptographically secure …\nReplace a <code>Protocol</code> at some position in this <code>Multiaddr</code>.\nReturns a base-58 encoded string of this <code>PeerId</code>.\nReturns a raw bytes representation of this <code>PeerId</code>.\nReturn a copy of this <code>Multiaddr</code>’s byte representation.\nLike <code>Multiaddr::push</code> but consumes <code>self</code>.\nCreate a new, empty multiaddress with the given capacity.\nAppends the given <code>PeerId</code> if not yet present at the end of …\nEncode this protocol by writing its binary representation …")