searchState.loadedDescShard("quinn", 0, "QUIC transport protocol support for Tokio\nFuture produced by <code>Endpoint::accept</code>\nFuture produced by <code>Connection::accept_bi</code>\nFuture produced by <code>Connection::accept_uni</code>\nReason given by an application for closing the connection\nThe peer closed the connection\nAbstract implementation of an async timer for runtime …\nAbstract implementation of a UDP socket for runtime …\nA chunk of data from the receive stream\nConfiguration for outgoing connections\nErrors in the configuration of an endpoint\nErrors in the parameters being used to create a new …\nIn-progress connection attempt future\nA QUIC connection.\nReason given by the transport for closing the connection\nThe peer’s QUIC stack aborted the connection …\nReasons why a connection might be lost\nThe connection was lost\nThe connection was lost\nThe connection was lost\nThe connection was lost\nDatagram support is disabled locally\nA QUIC endpoint.\nGlobal configuration for the endpoint, affecting all …\nThe endpoint can no longer create new connections\nThe stream finished before all bytes were read\nMaximum duration of inactivity to accept before timing out …\nAttempted an ordered read following an unordered read\nThe domain name supplied was malformed\nThe remote <code>SocketAddr</code> supplied was malformed\nThe local application closed the connection\nThe largest representable value\nThe largest encoded value length\nNo default client configuration was set up\nFuture produced by <code>Connection::open_bi</code>\nFuture produced by <code>Connection::open_uni</code>\nValue exceeds supported bounds\nAn error occurred during reading\nFuture produced by <code>Connection::read_datagram</code>\nErrors that arise from reading from a stream.\nA read error occurred\nErrors that arise from reading from a stream.\nErrors from <code>RecvStream::read_to_end</code>\nA stream that can only be used to receive data\nThe peer abandoned transmitting data on this stream\nThe peer is unable to continue processing this connection, …\nAbstracts I/O and timer operations for runtime independence\nErrors that can arise when sending a datagram\nA stream that can only be used to send data\nParameters governing incoming connections\nThe peer is no longer accepting data on this stream\nErrors that arise while monitoring for a send stream stop …\nIdentifier for a stream within a particular connection\nCommunication with the peer has lapsed for longer than the …\nA Quinn runtime for Tokio\nThe datagram is larger than the connection can currently …\nThe stream is larger than the user-supplied limit\nThe number of active connections on the local endpoint is …\nAn outgoing packet\nParameters governing the core QUIC state machine\nThe peer violated the QUIC specification as understood by …\nError indicating that a stream has already been finished …\nThe stream has already been stopped, finished, or reset\nThe stream has already been finished or reset\nThe stream has already been finished or reset\nThe peer does not support receiving datagram frames\nThe cryptographic layer does not support the specified …\nAn integer less than 2^62\nThe peer doesn’t implement any supported version\nErrors that arise from writing to a stream\nFuture that completes when a connection is fully …\nThis was a 0-RTT stream and the server rejected it\nThis was a 0-RTT stream and the server rejected it\nThis was a 0-RTT stream and the server rejected it\nGet the next incoming connection attempt from a client\nAccept the next incoming bidirectional stream\nAccept the next incoming uni-directional stream\nWhether the implementation is permitted to set the spin …\nThe contents of the chunk\nSupply a custom connection ID generator factory\nHelper to construct an endpoint for use with outgoing …\nClose the connection immediately.\nClose all of this endpoint’s connections immediately and …\nIf the connection is closed, the reason why.\nWait for the connection to be closed for any reason\nMaximum number of simultaneous connections to accept.\nLogic for controlling the rate at which data is sent\nHow to construct new <code>congestion::Controller</code>s\nCurrent state of the congestion control algorithm, for …\nConnect to a remote endpoint\nConnect to a remote endpoint using a custom configuration.\nContents of the datagram\nTraits and implementations for the QUIC cryptography …\nTLS configuration used for incoming connections.\nMaximum quantity of out-of-order crypto layer data to …\nMaximum number of incoming application datagram bytes to …\nMaximum number of outgoing application datagram bytes to …\nBytes available in the outgoing datagram buffer\nAutomatically select an appropriate runtime from those …\nThe socket this datagram should be sent to\nWhich directions data flows in\nExplicit congestion notification bits to set on the packet\nWhether to use “Generic Segmentation Offload” to …\nClass of error as encoded in the specification\nApplication-specific reason code\nDerive keying material from this connection’s TLS …\nShut down the send stream gracefully.\nType of frame that caused the close\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstruct a <code>VarInt</code> infallibly\nSucceeds iff <code>x</code> &lt; 2^62\nCreate a VarInt without ensuring it’s in range\nWhether to accept QUIC packets containing any value for …\nParameters negotiated during the handshake\nParameters negotiated during the handshake\nGet the identity of this stream\nGet the identity of this stream\nDistinguishes streams of the same initiator and …\nUDP payload size that the network must be capable of …\nThe RTT used before an RTT sample is taken\nWhich side of a connection initiated the stream\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert into a 0-RTT or 0.5-RTT connection at the cost of …\nExtract the integer value\nCheck if this stream has been opened during 0-RTT.\nPeriod of inactivity before sending a keep-alive packet\nLook up the local IP address and port used by this socket\nGet the local <code>SocketAddr</code> the underlying socket is bound to\nThe local IP address which was used when the peer …\nThe local IP address which was used when the peer …\nMaximum number of incoming bidirectional streams that may …\nVariant of <code>max_concurrent_bidi_streams</code> affecting …\nCompute the maximum size of datagrams that may be passed …\nMaximum duration of inactivity to accept before timing out …\nMaximum number of tail loss probes before an RTO fires.\nMaximum UDP payload size accepted from peers. Excludes UDP …\nWhether to allow clients to migrate to new addresses\nConstruct an endpoint with arbitrary configuration and …\nCreate a default config with a particular <code>reset_key</code>\nCreate a default config with a particular handshake token …\nCreate a default config with a particular cryptographic …\nCreate a new StreamId\nConstruct a timer that will expire at <code>i</code>\nConstruct an endpoint with arbitrary configuration and …\nThe offset in the stream\nInitiate a new outgoing bidirectional stream.\nInitiate a new outgoing unidirectional stream.\nMaximum reordering in packet number space before FACK …\nCryptographic identity of the peer\nNumber of consecutive PTOs after which network is …\nCheck whether the timer has expired, and register to be …\nReceive UDP datagrams, or register to be woken if …\nSend UDP datagrams from <code>transmits</code>, or register to be woken …\nGet the priority of the send stream\nRead data contiguously from the stream.\nRead the next segment of data\nRead the next segments of data\nReceive an application datagram\nRead an exact number of bytes contiguously from the stream.\nConvenience method to read all remaining data into a buffer\nHuman-readable reason for the close\nHuman-readable reason for the close\nSwitch to a new UDP socket\nMaximum number of bytes the peer may transmit across all …\nThe peer’s UDP address.\nThe peer’s UDP address\nUpdate the timer to expire at <code>i</code>\nClose the send stream immediately.\nPrivate key used to send authenticated connection resets …\nDuration after a stateless retry token was issued for …\nCurrent best estimate of this connection’s latency …\nThe segment size if this transmission contains multiple …\nTransmit <code>data</code> as an unreliable, unordered application …\nMaximum number of bytes to transmit to a peer without …\nHelper to construct an endpoint for use with both incoming …\nSet the client configuration used by <code>connect</code>\nModify the number of remotely initiated bidirectional …\nModify the number of remotely initiated unidirectional …\nSet the priority of the send stream\nSee <code>proto::TransportConfig::receive_window()</code>\nReplace the server configuration, affecting new incoming …\nDrive <code>future</code> to completion in the background\nOptional source IP address for the datagram\nA stable identifier for this connection\nReturns connection statistics\nStop accepting data\nCompletes if/when the peer stops the stream, yielding the …\nMaximum number of bytes the peer may transmit without …\nOverride supported QUIC versions\nMaximum reordering in time space before time based loss …\nPrivate key used to authenticate data included in …\nTransport configuration to use for incoming connections\nSet a custom <code>TransportConfig</code>\nSet a custom <code>TransportConfig</code>\nSucceeds iff <code>x</code> &lt; 2^62\nSucceeds iff <code>x</code> &lt; 2^62\nSucceeds iff <code>x</code> &lt; 2^62\nWhether to require clients to prove ownership of an …\nSet the QUIC version to use\nWait for all connections on the endpoint to be cleanly …\nCreate a server config with the given <code>crypto::ServerConfig</code>\nCreate a client configuration that trusts specified trust …\nCreate a server config with the given certificate chain to …\nConvert <code>t</code> into the socket type used by this runtime\nWrite bytes to the stream\nConvenience method to write an entire buffer to the stream\nConvenience method to write an entire list of chunks to …\nConvenience method to write a single chunk in its entirety …\nWrite chunks to the stream\nExperimental! Use at your own risk.\nConfiguration for the <code>Bbr</code> congestion controller\nCommon interface for different congestion controllers\nConstructs controllers on demand\nThe RFC8312 congestion controller, as widely used for TCP\nConfiguration for the <code>Cubic</code> congestion controller\nA simple, standard congestion controller\nConfiguration for the <code>NewReno</code> congestion controller\nConstruct a fresh <code>Controller</code>\nDuplicate the controller’s state\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInitial congestion window\nDefault limit on the amount of outstanding data in bytes.\nDefault limit on the amount of outstanding data in bytes.\nDefault limit on the amount of outstanding data in bytes.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns Self for use in down-casting to extract …\nReduction in congestion window when a new loss event is …\nThe sender’s maximum UDP payload size. Does not include …\nThe sender’s maximum UDP payload size. Does not include …\nThe sender’s maximum UDP payload size. Does not include …\nDefault minimum congestion window.\nDefault minimum congestion window.\nDefault minimum congestion window.\nConstruct a state using the given <code>config</code> and current time …\nConstruct a state using the given <code>config</code> and current time …\nConstruct a state using the given <code>config</code> and current time …\nPacket deliveries were confirmed\nPackets were deemed lost or marked congested\nPackets are acked in batches, all with the same <code>now</code> …\nOne or more packets were just sent\nNumber of ack-eliciting bytes that may be in flight\nA key for sealing data with AEAD-based algorithms\nClient-side configuration for the crypto protocol\nGeneric crypto errors\nError returned by Session::export_keying_material.\nA pseudo random key for HKDF\nKeys used to protect packet headers\nA key for signing with HMAC-based algorithms\nA pair of keys for bidirectional communication\nA complete set of keys for a certain packet space\nKeys used to protect packet payloads\nServer-side configuration for the crypto protocol\nA cryptographic session (commonly TLS)\nError indicating that the specified QUIC version is not …\nDerive AEAD using hkdf\nMaximum number of packets that may be sent using a single …\nDecrypt the packet payload with the given packet number\nDecrypt the given packet’s header\nGet the 0-RTT keys if available (clients only)\nIf the 0-RTT-encrypted data has been accepted by the peer\nEncrypt the packet payload with the given packet number\nEncrypt the given packet’s header\nFill <code>output</code> with <code>output.len()</code> bytes of keying material …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet data negotiated during the handshake, if available\nHeader protection keys\nCreate the initial set of keys given the client’s …\nCreate the initial set of keys given the client’s …\nMaximum number of incoming packets that may fail …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> until the connection is fully established.\nVerify the integrity of a retry packet\nKey for encrypting data\nCompute keys for the next key update\nMethod for opening a sealed message <code>data</code>\nPacket protection keys\nGet the peer’s identity, if available\nRead bytes of handshake data\nKey for decrypting data\nGenerate the integrity tag for a retry packet\nTLS interface based on rustls\nThe sample size used for this key’s algorithm\nMethod for sealing message <code>data</code>\nMethod for signing a message\nLength of <code>sign</code>’s output\nStart a client session with this configuration\nStart a server session with this configuration\nThe length of the AEAD tag appended to packets on …\nThe peer’s QUIC transport parameters\nMethod for verifying a message\nWrites handshake bytes into the given buffer and …\nWe received a fatal alert.  This means the peer is unhappy.\nThe <code>max_fragment_size</code> value supplied in configuration was …\nThe peer sent us a syntactically incorrect TLS message.\nThe peer sent us a TLS message with invalid contents.\nWe couldn’t decrypt a message.  This is invariably fatal.\nWe couldn’t encrypt a message because it was larger than …\nrustls reports protocol errors using this type.\nWe failed to figure out what time it currently is.\nWe failed to acquire random bytes from the system.\nA catch-all error for unlikely errors.\nAuthentication data for (rustls) TLS session\nThis function doesn’t work until the TLS handshake is …\nWe received a TLS handshake message that isn’t valid …\nWe received a TLS message that isn’t valid right now. …\nWe received a certificate which includes invalid data.\nWe received an invalidly encoded certificate from the peer.\nWe received a certificate with invalid signature.\nWe received a certificate with invalid signature type.\nThe presented SCT(s) were invalid.\nAn incoming connection did not support any known …\nThe peer didn’t give us any certificates.\nThe peer doesn’t support a protocol version/feature we …\nThe peer deviated from the standard TLS protocol. The …\nThe peer sent an oversized record/fragment.\nA rustls TLS session\nThe certificate verifier doesn’t support the given type …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe negotiated application protocol, if ALPN is in use\nThe server name specified by the client, if any\nWhich types we expected\nWhich handshake type we expected\nWhat type we received\nWhat handshake type we received")