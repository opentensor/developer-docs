searchState.loadedDescShard("trie_db", 0, "Trie interface and implementation.\nIf true, the trie will allow empty values into <code>TrieDBMut</code>\nA container for storing bytes.\nA weak reference of <code>Bytes</code>.\nAlias accessor to <code>NodeCodec</code> associated <code>Error</code> type from a …\nA value as cached by the <code>TrieCache</code>.\nCodec to use (needs to match hasher and nibble ops).\nDatabase value\nCorrupt Trie item.\nEscape header byte sequence to indicate next node is a …\nEscape header byte sequence to indicate next node is a …\nThe given <code>encoded_node</code> was accessed using its <code>hash</code>.\nContains the error value\nContains the error value\nContains the error value\nCodec error type.\nThe value exists in the trie.\nWe cached the hash, because we did not yet accessed the …\nA fat trie db.\nSecure trie with fat database.\nA <code>Trie</code> implementation which hashes keys and uses a generic …\nIterator over inserted pairs of key values.\nA mutable <code>Trie</code> implementation which hashes keys and uses a …\nA generic trie db.\nGeneric trie.\nThe hash of the value for the given <code>full_key</code> was accessed.\nWe recorded all trie nodes up to the value hash for a …\nThe merkle value is the hash of the node.\nHasher to use for this trie.\nTrait modelling datastore keyed by a hash defined by the …\nTrait for immutable reference of HashDB.\nOutput type of encoded node hasher.\nTrait describing an object that can hash a slice of bytes. …\nTrie item not found in the database,\nA value was accessed that is stored inline a node.\nHash is not value.\nAttempted to create a trie with a state root not in the DB.\nOutput item.\nThe length in bytes of the <code>Hasher</code> output.\nTrie lookup helper object.\nThreshold above which an external node should be use to …\nEither the <code>hash</code> or <code>value</code> of a node depending on its size.\nNibble-orientated view onto byte-slice, allowing …\nOwning, nibble-oriented byte vector. Counterpart to …\nThe merkle value is the node data itself when the node …\nTrait for trie node encoding/decoding. Uses a type …\nThe given <code>NodeOwned</code> was accessed using its <code>hash</code>.\nThe value/hash for <code>full_key</code> was accessed, but it couldn’…\nThe value doesn’t exist in the trie.\nWe haven’t recorded any trie nodes yet for a storage key.\nContains the success value\nContains the success value\nContains the success value\nThe output type of the <code>Hasher</code>\nRepresentation of a nible slice (right aligned). It …\nVisitor trait to implement when using <code>trie_visit</code>.\nDescription of what kind of query will be made to the trie.\nResult of <code>TrieRecorder::trie_nodes_recorded_for_key</code>.\nTrie result type. Boxed to avoid copying around extra …\nA secure trie db.\nSecure trie.\nWhat to use to build <code>HashMap</code>s with this <code>Hasher</code>.\nA key-value datastore implemented as a database-backed …\nUsed to report the trie access to the <code>TrieRecorder</code>.\nGet trie root and insert visited node in a hash_db. As for …\nA cache that can be used to speed-up certain operations …\nThis trait associates a trie definition with preferred …\nDouble ended iterator for going through all nodes in the …\nIterator for going through all nodes in the trie in …\nIterator for going through all nodes in the trie in …\nExtending the <code>TrieIterator</code> trait with <code>DoubleEndedIterator</code> …\nTrie Errors.\nTrie factory.\nAlias accessor to hasher hash output type from a <code>TrieLayout</code>…\nTrie-Item type used for iterators over trie data.\nA trie iterator that also supports random access (<code>seek()</code>).\nTrie-Item type used for iterators over trie key only.\nAll different kinds of tries. This is used to prevent a …\nTrait with definition of trie layout. Contains all …\nA key-value datastore implemented as a database-backed …\nA trie recorder that can be used to record all kind of …\nCalculate the trie root of the trie.\nCalculate the trie root of the trie. Print a debug trace.\nGet the trie root node encoding.\nTrie types\nIf true, the trie will use extension nodes and no partial …\nThe given <code>value</code> was accessed using its <code>hash</code>.\nWe recorded all trie nodes up to the value for a storage …\nA value was found in the trie with a nibble key that was …\nAdvance the view on the slice by <code>i</code> nibbles.\nAppend another <code>NibbleVec</code>. Can be slow (alignement of …\nAppend a <code>Partial</code>. Can be slow (alignement of partial).\nTry to treat this <code>NibbleVec</code> as a <code>NibbleSlice</code>. Works only …\nGet <code>Prefix</code> representation of this <code>NibbleVec</code>.\nTry to get the nibble at the given offset.\nGet the nibble at position <code>i</code>.\nMove back to a previously valid fix offset position.\nReturns an encoded branch node. Takes an iterator yielding …\nReturns an encoded branch node with a possible partial …\nOptional cache that should be used to speed up the lookup.\nCache the given <code>value</code> for the given <code>key</code>.\nclear\nHow many of the same nibbles at the beginning do we match …\nCheck for the existence of a hash-key.\nCheck for the existance of a hash-key.\nDoes the trie contain a given key?\nDoes the trie contain a given key?\nCreate new mutable instance of Trie.\nReturns the data of the value.\nGet the backing database.\nGet the backing database.\nAccess inner hash db.\nAccess inner hash db.\ndatabase to query from.\nGet the backing database.\nDecode a byte-slice into the desired item.\nDecode bytes to a <code>Node</code>. Returns <code>Self::E</code> on failure.\nDecode bytes to a <code>Node</code>. Returns <code>Self::E</code> on failure.\nReconstructs a partial trie DB from a compact …\nVariant of ‘decode_compact’ that accept an iterator of …\nDecode bytes to a <code>NodePlan</code>. Returns <code>Self::E</code> on failure.\nRemove then n last nibbles in a faster way than popping n …\nLike <code>insert()</code>, except you provide the key and the data is …\nCreate a new empty iterator.\nReturns an encoded empty node.\nGenerates a compact representation of the partial trie …\nEncoding of index as a key (when reusing general trie for …\nReturns an encoded extension node\nFetch value by hash at a current node height\nFetch value by hash at a current node height\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new trie with the backing database <code>db</code> and <code>root</code>.\nCreate new mutable instance of trie and check for errors.\nRestore an iterator from a raw iterator.\nRestore an iterator from a raw iterators.\nGet nibble slice from a <code>NodeKey</code>.\nLook up a given hash into the bytes that hash to it, …\nLook up a given hash into the bytes that hash to it, …\nWhat is the value of the given key in this trie?\nWhat is the value of the given key in this trie?\nReturns the hash of the value for <code>key</code>.\nGet the <code>NodeOwned</code> that corresponds to the given <code>hash</code>.\nGet or insert a <code>NodeOwned</code>.\nSearch for the key with the given query parameter. See the …\nCompute the hash of the provided slice of bytes returning …\nReturns the hash of the value.\nHash to start at\nGet the hashed null node.\nGet the underlying byte slice.\nInsert a datum item into the DB and return the datum’s …\nInsert a <code>key</code>/<code>value</code> pair into the trie. An empty value is …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert the iterator to a raw iterator.\nConvert the iterator to a raw forward iterator.\nConvert the iterator to a raw backward iterator.\nIs the trie empty?\nIs the trie empty?\nReturns true if <code>NibbleVec</code> has zero length.\nReturn true if the slice contains no nibbles.\nCheck if the provided bytes correspond to the codecs “…\nReturns true iff the trie DB is a fat DB (allows …\nIs <code>self</code> equal to <code>Self::None</code>?\nReturns a depth-first iterator over the elements of trie.\nGet an iterator for the series of nibbles.\nReturns a depth-first iterator over the keys of elemets of …\nReturns an encoded leaf node\nReturn left portion of <code>NibbleSlice</code>, if the slice …\nOwned version of a <code>Prefix</code> from a <code>left</code> method call.\nLength of the <code>NibbleVec</code>.\nGet the length (in nibbles, naturally) of this slice.\nLook up the given <code>nibble_key</code>.\nLook up the value hash for the given <code>nibble_key</code>.\nLook up the <code>MerkleValue</code> of the node that is the closest …\nLook up the merkle value (hash) of the node that is the …\nLookup value for the given <code>key</code>.\nReturn object which represents a view on to this slice …\nCreate a new trie with the backing database <code>db</code> and empty …\nCreates new iterator.\nCreate a new trie with the backing database <code>db</code> and empty …\nCreate a new iterator.\nCreate a new iterator.\nCreate a new double ended iterator.\nMake a new <code>NibbleVec</code>.\nCreate a new nibble slice with the given byte-slice.\nCreates new factory.\nCreate a new nibble slice with the given byte-slice with a …\nCreate a new iterator, but limited to a given prefix.\nCreate a new iterator, but limited to a given prefix. It …\nFetches the next trie item.\nFetches the next key.\nUtility methods to work on radix 16 nibble.\nA trie root formed from the items, with keys attached …\nGet <code>Prefix</code> representation of the inner data.\nTry to pop a nibble off the <code>NibbleVec</code>. Fails if len == 0.\nAdvance the iterator into a prefix, no value out of the …\nAdvance the iterator into a prefix, no value out of the …\nAdvance the iterator into a prefix, no value out of the …\nAdvance the iterator into a prefix, no value out of the …\nFetches the previous trie item.\nFetches the previous key.\nFunction call with prefix, encoded value and a boolean …\nCallback for hashed value in encoded node.\nGeneration and verification of compact proofs for …\nPush a nibble onto the <code>NibbleVec</code>. Ignores the high 4 bits.\nQuery object to record nodes and transform data.\nCreate new immutable instance of Trie.\nRecord the given <code>TrieAccess</code>.\nTrie query recorder.\nOptional recorder that will be called to record all trie …\nRemove a datum previously inserted. Insertions can be “…\nRemove a <code>key</code> from the trie. Equivalent to making it equal …\nReturn <code>Partial</code> representation of this slice: first encoded …\nReturn an iterator over <code>Partial</code> bytes representation.\nReturn an iterator over <code>Partial</code> bytes representation.\nReturn <code>Partial</code> bytes iterator over a range of byte.. …\nReturn the root of the trie.\nReturn the root of the trie.\nThe resulting root.\nThe resulting encoded root.\nThe resulting root.\nPosition the iterator on the first element with key &gt;= <code>key</code>\nDo we start with the same nibbles as the whole of <code>them</code>?\nDo we start with the same nibbles as the whole of <code>them</code>?\nSame as <code>Self::starts_with</code> but using <code>NibbleSlice</code>.\nSame as <code>Self::starts_with</code> but using <code>NibbleVec</code>.\nHelper function to create a owned <code>NodeKey</code> from this …\nHelper function to create a owned <code>NodeKey</code> from this …\nOperation to build a trie db from its ordered iterator …\nCheck if we have recorded any trie nodes for the given <code>key</code>.\nDetermines a trie root given its ordered contents, closed …\nDetermines a trie root node’s data given its ordered …\nFunction visiting trie from key value inputs with a …\nIn-memory trie representation.\nUpgrade to <code>Bytes</code>.\nThe actual data of the value stored as <code>BytesWeak</code>.\nThe hash of the value.\nSingle nibble length in bit.\nSize of header.\nNumber of child for a branch (trie radix).\nNumber of nibble per byte.\nNibble (half a byte).\nThe nibble shifts needed to align. We use two value, one …\nGet u8 nibble value at a given index in a <code>NibbleSlice</code>.\nGet u8 nibble value at a given index of a byte.\nCount the biggest common depth between two left aligned …\nCalculate the number of common nibble between two left …\nGet u8 nibble value at a given index in a left aligned …\nCalculate the number of needed padding a array of nibble …\nMask a byte, keeping left nibble.\nMask a byte, keeping right byte.\nPush u8 nibble value at a given index into an existing …\nShifts right aligned key to add a given left offset. …\nBranch node; has slice of child nodes (each possibly null) …\nBranch node; has slice of child nodes (each possibly null) …\nBranch node; has slice of child nodes (each possibly null) …\nNull trie node; could be an empty root or an empty branch …\nNull trie node; could be an empty root or an empty branch …\nNull trie node; could be an empty root or an empty branch …\nExtension node; has key slice and node data. Data may not …\nExtension node; has key slice and node data. Data may not …\nExtension node; has a partial key plan and child data.\nValue byte slice as stored in a trie node.\nValue bytes as stored in a trie node and its hash.\nRange for byte representation in encoded node.\nLeaf node; has key slice and value. Value may not be empty.\nLeaf node; has key slice and value. Value may not be empty.\nLeaf node; has a partial key plan and value.\nA <code>NibbleSlicePlan</code> is a blueprint for decoding a nibble …\nBranch node with support for a nibble (when extension …\nBranch node with support for a nibble (when extension …\nBranch node with support for a nibble (when extension …\nType of node in the trie and essential information thereof.\nHash byte slice as stored in a trie node.\nHash byte slice as stored in a trie node.\nRange for hash in encoded node and original value size.\nA reference to a trie node which may be stored within …\nOwned version of <code>NodeHandleOwned</code>.\nA <code>NodeHandlePlan</code> is a decoding plan for constructing a …\nPartial node key type: offset and owned value of a …\nOwned version of <code>Node</code>.\nA <code>NodePlan</code> is a blueprint for decoding a node from a byte …\nAn <code>OwnedNode</code> is an owned type from which a <code>Node</code> can be …\nValue representation in <code>Node</code>.\nNode that represents a value.\nOwned value representation in <code>Node</code>.\nPlan for value representation in <code>NodePlan</code>.\nReturns <code>self</code> as inline node.\nReturns self as <code>Value</code>.\nBuild a node handle by decoding a byte slice according to …\nBuild a nibble slice by decoding a byte slice according to …\nBuild a value slice by decoding a byte slice according to …\nBuild a node by decoding a byte slice according to the …\nReturns an iterator over all existing children with their …\nReturns the data stored in self.\nReturns the data attached to this node.\nReturns a reference to the backing data.\nReturns the hash of the data stored in self.\nReturns the hash of the data attached to this node.\nRead a hash from a slice into a Hasher output. Returns …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the nibble length of the slice.\nConstruct a nibble slice decode plan.\nConstruct an <code>OwnedNode</code> by decoding an owned data source …\nConstruct a <code>Node</code> by borrowing data from this struct.\nReturns a reference to the node decode plan.\nReturns a mutable reference to the node decode plan.\nReturns the partial key of this node.\nReturns the size in bytes of this node in memory.\nConvert to its encoded format.\nConverts this node handle into a <code>NodeHandleOwned</code>.\nConverts this node into a <code>NodeOwned</code>.\nAccess value plan from node plan, return <code>None</code> for node …\nMutable ccess value plan from node plan, return <code>None</code> for …\nOne of the proof nodes could not be decoded.\nThe statement being verified contains multiple key-value …\nThe proof contains at least one extraneous hash reference …\nThe proof contains at least one extraneous node.\nThe proof contains at least one extraneous value which …\nThe proof is missing trie nodes required to verify.\nThe proof contains an invalid child reference that exceeds …\nThe root hash computed from the proof is incorrect.\nThe proof indicates that an expected value was not found …\nErrors that may occur during proof verification. Most of …\nReturns the argument unchanged.\nGenerate a compact proof for key-value pairs in a trie …\nCalls <code>U::from(self)</code>.\nVerify a compact proof for key-value pairs in a trie given …\nThe record of a visited node.\nRecords trie nodes as they pass it.\nThe data representing the node.\nDrain all visited records.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe hash of the node.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new <code>Recorder</code> which records all given nodes.\nA <code>Trie</code> implementation which hashes keys and uses a generic …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new trie with the backing database <code>db</code> and <code>root</code>.\nGet a reference to the underlying raw <code>TrieDB</code> struct.\nGet a mutable reference to the underlying raw <code>TrieDB</code> …\nA mutable <code>Trie</code> implementation which hashes keys and uses a …\nGet the backing database.\nGet the backing database.\nReturns the argument unchanged.\nCreate a new trie with the backing database <code>db</code> and <code>root</code>.\nCalls <code>U::from(self)</code>.\nCreate a new trie with the backing database <code>db</code> and empty …\nA <code>Trie</code> implementation using a generic <code>HashDB</code> backing …\nA builder for creating a <code>TrieDB</code>.\nDouble ended iterator for going through all values in the …\nIterator for going through all values in the trie in …\nDouble ended iterator for going through all of key with …\nIterator for going through all of key with values in the …\nBuild the <code>TrieDB</code>.\nGet the backing database.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nRestore an iterator from a raw iterator.\nRestore an iterator from a raw iterator.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate <code>TrieDBDoubleEndedIterator</code> from <code>TrieDB</code>.\ncreate <code>FatDBDoubleEndedIterator</code> from <code>TrieDB</code>.\ncreate <code>TrieDBKeyDoubleEndedIterator</code> from <code>TrieDB</code>.\nCreate <code>TrieDBNodeDoubleEndedIterator</code> from <code>TrieDB</code>.\nConvert the iterator to a raw iterator.\nConvert the iterator to a raw iterator.\nCreate a new trie-db builder with the backing database <code>db</code> …\nCreate a new iterator.\nCreate a new iterator.\nCreate a new double ended iterator.\nCreate a new double ended iterator.\nCreate a new iterator, but limited to a given prefix.\nCreate a new iterator, but limited to a given prefix.\nCreate a new iterator, but limited to a given prefix.\nCreate a new iterator, but limited to a given prefix. It …\nCreate a new iterator, but limited to a given prefix. It …\nPosition the iterator on the first element with key &gt;= <code>key</code>\nPosition the iterator on the first element with key &gt;= <code>key</code>\nPosition the iterator on the first element with key &gt;= <code>key</code>\nUse the given <code>cache</code> for the db.\nUse the given optional <code>cache</code> for the db.\nUse the given optional <code>recorder</code> to record trie accesses.\nUse the given <code>recorder</code> to record trie accesses.\nUsed to build a collection of child nodes from a …\nValue bytes inlined in a trie node.\nHash of value bytes if calculated and value bytes. The …\nHash of the value.\nA <code>Trie</code> implementation using a generic <code>HashDB</code> backing …\nA builder for creating a <code>TrieDBMut</code>.\nValue representation for Node.\nBuild the <code>TrieDBMut</code>.\nCommit the in-memory changes to disk, freeing their …\nGet the backing database.\nGet the backing database mutably.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a builder for constructing a new trie with the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a builder for constructing a new trie with the …\nUse the given <code>cache</code> for the db.\nUse the given optional <code>cache</code> for the db.\nUse the given optional <code>recorder</code> to record trie accesses.\nUse the given <code>recorder</code> to record trie accesses.")