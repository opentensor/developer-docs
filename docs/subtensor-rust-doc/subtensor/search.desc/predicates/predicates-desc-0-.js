searchState.loadedDescShard("predicates", 0, "Composable first-order predicate functions.\n<code>Predicate</code> that wraps another <code>Predicate</code> as a trait object, …\nTrait for generically evaluating a type against a …\n<code>Predicate</code> extension for boxing a <code>Predicate</code>.\nDefinition of boolean logic combinators over <code>Predicate</code>s.\nReturns a <code>BoxPredicate</code> wrapper around this <code>Predicate</code> type.\nDefinition of a constant (always true or always false) …\nExecute this <code>Predicate</code> against <code>variable</code>, returning the …\nFind a case that proves this predicate as <code>expected</code> when …\nFloat Predicates\nReturns the argument unchanged.\nDefinition of <code>Predicate</code> for wrapping a <code>Fn(&amp;T) -&gt; bool</code>\nCalls <code>U::from(self)</code>.\nDefinition of <code>Predicate</code>s for comparisons of membership in …\nName predicate expressions.\nCreates a new <code>BoxPredicate</code>, a wrapper around a …\nDefinition of <code>Predicate</code>s for comparisons over <code>Ord</code> and <code>Eq</code> …\nPath Predicates\nModule that contains the essentials for working with …\nIntrospect into the state of a <code>Predicate</code>.\nString Predicates\nPredicate that combines two <code>Predicate</code>s, returning the AND …\nPredicate that returns a <code>Predicate</code> taking the logical NOT …\nPredicate that combines two <code>Predicate</code>s, returning the OR …\n<code>Predicate</code> extension that adds boolean logic.\nCompute the logical AND of two <code>Predicate</code> results, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new <code>AndPredicate</code> over predicates <code>a</code> and <code>b</code>.\nCreate a new <code>OrPredicate</code> over predicates <code>a</code> and <code>b</code>.\nCreate a new <code>NotPredicate</code> over predicate <code>inner</code>.\nCompute the logical NOT of a <code>Predicate</code>, returning the …\nCompute the logical OR of two <code>Predicate</code> results, returning …\nPredicate that always returns a constant (boolean) result.\nCreates a new <code>Predicate</code> that always returns <code>true</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreates a new <code>Predicate</code> that always returns <code>false</code>.\nPredicate that wraps a function over a reference that …\nProvide a descriptive name for this function.\nReturns the argument unchanged.\nCreates a new predicate that wraps over the given …\nCalls <code>U::from(self)</code>.\nPredicate that returns <code>true</code> if <code>variable</code> is a member of the …\nPredicate that returns <code>true</code> if <code>variable</code> is a member of the …\nPredicate that returns <code>true</code> if <code>variable</code> is a member of the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new predicate that will return <code>true</code> when the …\nCreates a new predicate that will return <code>true</code> when the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new predicate that will return <code>true</code> when the …\nAugment an existing predicate with a name.\n<code>Predicate</code> extension that adds naming predicate expressions.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nName a predicate expression.\nPredicate that returns <code>true</code> if <code>variable</code> matches the …\nPredicate that returns <code>true</code> if <code>variable</code> matches the …\nCreates a new predicate that will return <code>true</code> when the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new predicate that will return <code>true</code> when the …\nCreates a new predicate that will return <code>true</code> when the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new predicate that will return <code>true</code> when the …\nCreates a new predicate that will return <code>true</code> when the …\nCreates a new predicate that will return <code>true</code> when the …\nPredicate that compares file matches\nPredicate that checks if a file is present\nPredicate adapter that converts a <code>path</code> predicate to a byte …\nPredicate that checks the <code>std::fs::FileType</code>.\n<code>Predicate</code> extension adapting a <code>slice</code> Predicate.\nPredicate that compares string content of files\nCreates a new <code>Predicate</code> that ensures complete equality\nCreates a new <code>Predicate</code> that ensures the path exists.\nFollow symbolic links.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns a <code>FileContentPredicate</code> that adapts <code>Self</code> to a file …\nReturns a <code>FileContentPredicate</code> that adapts <code>Self</code> to a file …\nAllow to create an <code>FileTypePredicate</code> from a <code>path</code>\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new <code>Predicate</code> that ensures the path points to a …\nCreates a new <code>Predicate</code> that ensures the path points to a …\nCreates a new <code>Predicate</code> that ensures the path points to a …\nCreates a new <code>Predicate</code> that ensures the path doesn’t …\nCreates a new <code>Predicate</code> that ensures complete equality\nTrait for generically evaluating a type against a …\n<code>Predicate</code> extension for boxing a <code>Predicate</code>.\nReturns a <code>BoxPredicate</code> wrapper around this <code>Predicate</code> type.\nReturns a <code>BoxPredicate</code> wrapper around this <code>Predicate</code> type.\nExecute this <code>Predicate</code> against <code>variable</code>, returning the …\nFind a case that proves this predicate as <code>expected</code> when …\nPredicate factories\n<code>f64</code> Predicate factories\n<code>Path</code> Predicate factories\n<code>str</code> Predicate factories\nA descriptive explanation for why a predicate failed.\nIterator over a <code>Case</code>s sub-cases.\nIterator over a <code>Case</code>s by-products.\nA view of a <code>Predicate</code> child, provided by reflection.\nA view of a <code>Predicate</code> parameter, provided by reflection.\nIntrospect the state of a <code>Predicate</code>.\nA by-product of a predicate evaluation.\nAdd an additional by product to a <code>Case</code>.\nAdd an additional by product to a <code>Case</code>.\nNested <code>Predicate</code>s of the current <code>Predicate</code>.\nAccess the sub-cases.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAccess the <code>Parameter</code> name.\nAccess the <code>Child</code>’s name.\nAccess the <code>Product</code> name.\nCreate a new <code>Parameter</code>.\nCreate a new <code>Predicate</code> child.\nCreate a new <code>Case</code> describing the result of a <code>Predicate</code>.\nCreate a new <code>Product</code>.\nParameters of the current <code>Predicate</code>.\nThe <code>Predicate</code> that produced this case.\nAccess the by-products from determining this case.\nThe result of this case.\nAccess the <code>Parameter</code> value.\nAccess the <code>Child</code> <code>Predicate</code>.\nAccess the <code>Product</code> value.\nPredicate that checks for patterns.\nPredicate checks end of str\nPredicate that checks for empty strings.\nPredicate that checks for repeated patterns.\n<code>Predicate</code> extension adapting a <code>str</code> Predicate.\nPredicate checks start of str\nPredicate adaper that trims the variable being tested.\nPredicate adaper that converts a <code>str</code> predicate to byte …\nCreates a new <code>Predicate</code> that ensures a str contains <code>pattern</code>\nRequire a specific count of matches.\nCreates a new <code>Predicate</code> that ensures a str ends with …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns a <code>Utf8Predicate</code> that adapts <code>Self</code> to a <code>[u8]</code> …\nReturns a <code>Utf8Predicate</code> that adapts <code>Self</code> to a <code>[u8]</code> …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new <code>Predicate</code> that ensures a str is empty\nCreates a new <code>Predicate</code> that ensures a str starts with …\nReturns a <code>TrimPredicate</code> that ensures the data passed to …\nReturns a <code>TrimPredicate</code> that ensures the data passed to …")