searchState.loadedDescShard("quinn_proto", 0, "Low-level protocol logic for the QUIC protoocol\nthe endpoint has reached the confidentiality or integrity …\nthe application or application protocol caused the …\nReason given by an application for closing the connection\nThe peer closed the connection\nAt least one new stream of a certain directionality may be …\nData flows in both directions\nNo more data is currently available on this stream.\nThe peer is not able to accept additional data, or the …\nA source of one or more buffers which can be converted …\nthe number of connection IDs provided by the peer exceeds …\nthe server refused to accept a new connection\nreceived more data in CRYPTO frames than can be buffered\nA chunk of data from the receive stream\nChunks\nThe initiator of a connection\nConfiguration for outgoing connections\nErrors in the configuration of an endpoint\nErrors in the parameters being used to create a new …\nThe connection was successfully established\nProtocol state and logic for a single QUIC connection\nReason given by the transport for closing the connection\nThe peer’s QUIC stack aborted the connection …\nReasons why a connection might be lost\nEvents sent from an Endpoint to a Connection\nThe datagram is redirected to its <code>Connection</code>\nInternal identifier for a <code>Connection</code> currently associated …\nProtocol-level identifier for a connection.\nGenerates connection IDs for incoming connections\nThe connection was lost\nConnection statistics\nThe QUIC protocol version implemented.\nAn unreliable datagram\nEvent resulting from processing a single datagram\nOne or more application datagrams have been received\nAPI to control datagram traffic\nWhether a stream communicates data in both directions or …\nDatagram support is disabled locally\nExplicit congestion notification codepoint\nThe main entry point to the library\nGlobal configuration for the endpoint, affecting all …\nEvents sent from a Connection to an Endpoint\nThe endpoint can no longer create new connections\nEvents of interest to the application\nreceived a STREAM frame or a RESET_STREAM frame containing …\nreceived more data than permitted in advertised data limits\nreceived a frame that was badly formatted\nReasons why attempting to finish a stream might fail\nA finished stream has been fully acknowledged or stopped\nThe connection’s handshake data is ready\nthe endpoint encountered an internal error and cannot …\nreceived an invalid Retry Token in a client Initial\nMaximum duration of inactivity to accept before timing out …\nAttempted an ordered read following an unordered read\nThe domain name supplied was malformed\nThe remote <code>SocketAddr</code> supplied was malformed\nkey update error\nThe local application closed the connection\nThe largest representable value\nThe largest encoded value length\nthe connection is being closed abruptly in the absence of …\nno viable network path exists\nThe datagram has resulted in starting a new <code>Connection</code>\nNo default client configuration was set up\nOne or more new streams has been opened and might be …\nValue exceeds supported bounds\ndetected an error with protocol compliance that was not …\nGenerates purely random connection IDs of a certain length\nErrors triggered when reading from a recv stream\nA currently open stream likely has data or errors waiting …\nErrors triggered when opening a recv stream for reading\nAccess to streams\nThe peer abandoned transmitting data on this stream.\nThe peer is unable to continue processing this connection, …\nRTT estimation for a particular network path\nreceived a frame for a stream identifier that exceeded …\nreceived a frame for a stream that was not in a state that …\nErrors that can arise when sending a datagram\nAccess to streams\nThe acceptor of a connection\nParameters governing incoming connections\nWhether an endpoint was the initiator of a connection\nThe peer is no longer accepting data on this stream, and …\nThe peer is no longer accepting data on this stream. No …\nThe peer asked us to stop sending on an outgoing stream\nStream events\nApplication events about streams\nIdentifier for a stream within a particular connection\nAccess to streams\nreceived transport parameters that were badly formatted, …\nCommunication with the peer has lapsed for longer than the …\nThe datagram is larger than the connection can currently …\nThe number of active connections on the local endpoint is …\nAn outgoing packet\nParameters governing the core QUIC state machine\nTransport-level errors occur when a peer violates the …\nThe peer violated the QUIC specification as understood by …\nTransport-level error code\nData flows only from the stream’s initiator\nError indicating that a stream has not been opened or has …\nThe stream has not been opened or was already stopped, …\nThe stream has not been opened or has already been …\nThe stream has not been opened or was already finished or …\nThe peer does not support receiving datagram frames\nThe cryptographic layer does not support the specified …\nAn integer less than 2^62\nError returned when constructing a <code>VarInt</code> from a value &gt;= …\nThe peer doesn’t implement any supported version\nA formerly write-blocked stream might be ready for a write …\nErrors triggered while writing to a send stream\nIndicates how many bytes and chunks had been transferred …\nAccept a remotely initiated stream of a certain …\nFor clients, if the peer accepted the 0-RTT data packets\nWhether the implementation is permitted to set the spin …\nThe contents of the chunk\nThe amount of bytes which had been written\nThe amount of full chunks which had been written\nSupply a custom connection ID generator factory\nReturns the length of a CID for connections created by …\nProvide the length of dst_cid in short header packet\nReturns the lifetime of generated Connection IDs\nClose a connection immediately\nType of error\nMaximum number of simultaneous connections to accept.\nAccess the configuration used by this endpoint\nLogic for controlling the rate at which data is sent\nHow to construct new <code>congestion::Controller</code>s\nCurrent state of this connection’s congestion …\nInitiate a connection\nConservative estimate of RTT\nContents of the datagram\nTraits and implementations for the QUIC cryptography …\nTLS configuration used for incoming connections.\nMaximum quantity of out-of-order crypto layer data to …\nGet a session reference\nPayload\nMaximum number of incoming application datagram bytes to …\nMaximum number of outgoing application datagram bytes to …\nControl datagrams\nThe socket this datagram should be sent to\nWhich directions data flows in\nConstruct an event that indicating that a <code>Connection</code> will …\nExplicit congestion notification bits to set on the packet\nWhether to use “Generic Segmentation Offload” to …\nClass of error as encoded in the specification\nApplication-specific reason code\nFinalize\nFinish a send stream, signalling that no more data will be …\nFrame type that triggered the error\nStatistics about frames received on a connection\nStatistics about frames transmitted on a connection\nType of frame that caused the close\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate new object from the given bits\nConstruct a <code>VarInt</code> infallibly\nSucceeds iff <code>x</code> &lt; 2^62\nCreate a VarInt without ensuring it’s in range\nGenerates a new CID\nThe current best RTT estimation.\nWhether to accept QUIC packets containing any value for …\nProcess an incoming UDP datagram\nProcess <code>ConnectionEvent</code>s generated by the associated …\nProcess <code>EndpointEvent</code>s emitted from related <code>Connection</code>s\nProcess timer expirations\nWhether 0-RTT is/was possible during the handshake\nWhether there are any pending retransmits\nDistinguishes streams of the same initiator and …\nUDP payload size that the network must be capable of …\nThe RTT used before an RTT sample is taken\nWhich side of a connection initiated the stream\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nExtract the integer value\nShorthand for <code>self == Side::Client</code>\nWhether the connection is closed\nWhether there is no longer any need to keep the connection …\nDetermine whether this is the last event a <code>Connection</code> will …\nWhether the connection is in the process of being …\nShorthand for <code>self == Side::Server</code>\nPeriod of inactivity before sending a keep-alive packet\nThe local IP address which was used when the peer …\nMaximum number of incoming bidirectional streams that may …\nVariant of <code>max_concurrent_bidi_streams</code> affecting …\nMaximum duration of inactivity to accept before timing out …\nCompute the maximum size of datagrams that may passed to …\nMaximum number of tail loss probes before an RTO fires.\nMaximum UDP payload size accepted from peers. Excludes UDP …\nWhether to allow clients to migrate to new addresses\nMinimum RTT registered so far for this estimator.\nCreate a new endpoint\nCreate a default config with a particular <code>reset_key</code>\nCreate a default config with a particular handshake token …\nCreate a default config with a particular cryptographic …\nConstruct cid from byte array\nInitialize Random CID generator with a fixed CID length\nCreate a new StreamId\nNext\nThe offset in the stream\nOpen a single stream if possible\nMaximum reordering in packet number space before FACK …\nStatistics related to the current transmission path\nNumber of consecutive PTOs after which network is …\nPing the remote endpoint\nReturns application-facing events\nReturn endpoint-facing events\nReturns the next time at which <code>handle_timeout</code> should be …\nReturns packets to transmit\nGet the next packet to transmit\nReturns the next chunk from the source of owned chunks.\nGet the priority of a stream\nRead from the given recv stream\nHuman-readable reason for the close\nHuman-readable reason for the close\nHuman-readable explanation of the reason\nMaximum number of bytes the peer may transmit across all …\nReceive an unreliable, unordered datagram\nProvide control over streams\nUnconditionally reject future incoming connections\nThe latest socket address for this connection’s peer\nAbandon transmitting data on a stream\nPrivate key used to send authenticated connection resets …\nDuration after a stateless retry token was issued for …\nCurrent best estimate of this connection’s latency …\nThe segment size if this transmission contains multiple …\nQueue an unreliable, unordered datagram for immediate …\nBytes available in the outgoing datagram buffer\nProvide control over streams\nThe number of streams that may have unacknowledged data.\nMaximum number of bytes to transmit to a peer without …\nSet the lifetime of CIDs created by this generator\nModify the number of remotely initiated streams that may …\nSet the priority of a stream\nSee <code>TransportConfig::receive_window()</code>\nReplace the server configuration, affecting new incoming …\nSet the <code>socket_buffer_fill</code> to the input <code>len</code>\nLook up whether we’re the client or server of this …\nOptional source IP address for the datagram\nReturns connection statistics\nStop accepting data on the given receive stream\nCheck if this stream was stopped, get the reason if it was\nMaximum number of bytes the peer may transmit without …\nProvide control over streams\nOverride supported QUIC versions\nMaximum reordering in time space before time based loss …\nPrivate key used to authenticate data included in …\nTransport configuration to use for incoming connections\nSet a custom <code>TransportConfig</code>\nSet a custom <code>TransportConfig</code>\nQUIC connection transport parameters\nSucceeds iff <code>x</code> &lt; 2^62\nSucceeds iff <code>x</code> &lt; 2^62\nSucceeds iff <code>x</code> &lt; 2^62\nStatistics about UDP datagrams received on a connection\nStatistics about UDP datagrams transmitted on a connection\nWhether to require clients to prove ownership of an …\nSet the QUIC version to use\nCreate a server config with the given <code>crypto::ServerConfig</code>\nCreate a client configuration that trusts specified trust …\nCreate a server config with the given certificate chain to …\nSend data on the given stream\nSend data on the given stream\nReason that the connection was closed\nDirectionality for which streams have been opened\nDirectionality for which streams are newly available\nError code supplied by the peer\nWhich stream is now readable\nWhich stream is now writable\nWhich stream has been finished\nWhich stream has been stopped\nExperimental! Use at your own risk.\nConfiguration for the <code>Bbr</code> congestion controller\nCommon interface for different congestion controllers\nConstructs controllers on demand\nThe RFC8312 congestion controller, as widely used for TCP\nConfiguration for the <code>Cubic</code> congestion controller\nA simple, standard congestion controller\nConfiguration for the <code>NewReno</code> congestion controller\nConstruct a fresh <code>Controller</code>\nDuplicate the controller’s state\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInitial congestion window\nDefault limit on the amount of outstanding data in bytes.\nDefault limit on the amount of outstanding data in bytes.\nDefault limit on the amount of outstanding data in bytes.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns Self for use in down-casting to extract …\nReduction in congestion window when a new loss event is …\nThe sender’s maximum UDP payload size. Does not include …\nThe sender’s maximum UDP payload size. Does not include …\nThe sender’s maximum UDP payload size. Does not include …\nDefault minimum congestion window.\nDefault minimum congestion window.\nDefault minimum congestion window.\nConstruct a state using the given <code>config</code> and current time …\nConstruct a state using the given <code>config</code> and current time …\nConstruct a state using the given <code>config</code> and current time …\nPacket deliveries were confirmed\nPackets were deemed lost or marked congested\nPackets are acked in batches, all with the same <code>now</code> …\nOne or more packets were just sent\nNumber of ack-eliciting bytes that may be in flight\nA key for sealing data with AEAD-based algorithms\nClient-side configuration for the crypto protocol\nGeneric crypto errors\nError returned by Session::export_keying_material.\nA pseudo random key for HKDF\nKeys used to protect packet headers\nA key for signing with HMAC-based algorithms\nA pair of keys for bidirectional communication\nA complete set of keys for a certain packet space\nKeys used to protect packet payloads\nServer-side configuration for the crypto protocol\nA cryptographic session (commonly TLS)\nError indicating that the specified QUIC version is not …\nDerive AEAD using hkdf\nMaximum number of packets that may be sent using a single …\nDecrypt the packet payload with the given packet number\nDecrypt the given packet’s header\nGet the 0-RTT keys if available (clients only)\nIf the 0-RTT-encrypted data has been accepted by the peer\nEncrypt the packet payload with the given packet number\nEncrypt the given packet’s header\nFill <code>output</code> with <code>output.len()</code> bytes of keying material …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet data negotiated during the handshake, if available\nHeader protection keys\nCreate the initial set of keys given the client’s …\nCreate the initial set of keys given the client’s …\nMaximum number of incoming packets that may fail …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> until the connection is fully established.\nVerify the integrity of a retry packet\nKey for encrypting data\nCompute keys for the next key update\nMethod for opening a sealed message <code>data</code>\nPacket protection keys\nGet the peer’s identity, if available\nRead bytes of handshake data\nKey for decrypting data\nGenerate the integrity tag for a retry packet\nTLS interface based on rustls\nThe sample size used for this key’s algorithm\nMethod for sealing message <code>data</code>\nMethod for signing a message\nLength of <code>sign</code>’s output\nStart a client session with this configuration\nStart a server session with this configuration\nThe length of the AEAD tag appended to packets on …\nThe peer’s QUIC transport parameters\nMethod for verifying a message\nWrites handshake bytes into the given buffer and …\nWe received a fatal alert.  This means the peer is unhappy.\nThe <code>max_fragment_size</code> value supplied in configuration was …\nThe peer sent us a syntactically incorrect TLS message.\nThe peer sent us a TLS message with invalid contents.\nWe couldn’t decrypt a message.  This is invariably fatal.\nWe couldn’t encrypt a message because it was larger than …\nrustls reports protocol errors using this type.\nWe failed to figure out what time it currently is.\nWe failed to acquire random bytes from the system.\nA catch-all error for unlikely errors.\nAuthentication data for (rustls) TLS session\nThis function doesn’t work until the TLS handshake is …\nWe received a TLS handshake message that isn’t valid …\nWe received a TLS message that isn’t valid right now. …\nWe received a certificate which includes invalid data.\nWe received an invalidly encoded certificate from the peer.\nWe received a certificate with invalid signature.\nWe received a certificate with invalid signature type.\nThe presented SCT(s) were invalid.\nAn incoming connection did not support any known …\nThe peer didn’t give us any certificates.\nThe peer doesn’t support a protocol version/feature we …\nThe peer deviated from the standard TLS protocol. The …\nThe peer sent an oversized record/fragment.\nA rustls TLS session\nThe certificate verifier doesn’t support the given type …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe negotiated application protocol, if ALPN is in use\nThe server name specified by the client, if any\nWhich types we expected\nWhich handshake type we expected\nWhat type we received\nWhat handshake type we received\nErrors encountered while decoding <code>TransportParameters</code>\nParameters that are semantically invalid\nCatch-all error for problems while decoding transport …\nTransport parameters used to negotiate connection-level …\nStandard defaults, used if the peer does not supply a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDecode <code>TransportParameters</code> from buffer\nEncode <code>TransportParameters</code> into buffer")