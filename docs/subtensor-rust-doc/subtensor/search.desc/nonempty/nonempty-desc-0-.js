searchState.loadedDescShard("nonempty", 0, "A Non-empty growable vector.\nAppend a <code>Vec</code> to the tail of the <code>NonEmpty</code>.\nBinary searches this sorted non-empty vector for a given …\nBinary searches this sorted non-empty with a comparator …\nBinary searches this sorted non-empty vector with a key …\nGet the capacity of the list.\nCheck whether an element is contained in the list.\nGet the first element. Never fails.\nGet the mutable reference to the first element. Never …\nWhen we have a function that goes from some <code>T</code> to a …\nFlatten nested <code>NonEmpty</code>s into a single one.\nReturns the argument unchanged.\nTurns a pair of an element and a Vec into a NonEmpty.\nOften we have a <code>Vec</code> (or slice <code>&amp;[T]</code>) but want to ensure …\nOften we have a <code>Vec</code> (or slice <code>&amp;[T]</code>) but want to ensure …\nGet an element by index.\nGet an element by index, mutably.\nInserts an element at position index within the vector, …\nCalls <code>U::from(self)</code>.\nAlways returns false.\nGet the last element. Never fails.\nGet the last element mutably.\nGet the length of the list.\nA structure preserving <code>map</code>. This is useful for when we …\nReturns the maximum element in the non-empty vector.\nReturns the element that gives the maximum value with …\nReturns the element that gives the maximum value with …\nReturns the minimum element in the non-empty vector.\nReturns the element that gives the minimum value with …\nReturns the element that gives the minimum value with …\nAlias for <code>NonEmpty::singleton</code>.\nPop an element from the end of the list.\nPush an element to the end of the list.\nCreate a new non-empty list with an initial element.\nDeconstruct a <code>NonEmpty</code> into its first, last, and middle …\nDeconstruct a <code>NonEmpty</code> into its head and tail. This …\nGet the possibly-empty tail of the list.\nTruncate the list to a certain size. Must be greater than <code>0</code>…")