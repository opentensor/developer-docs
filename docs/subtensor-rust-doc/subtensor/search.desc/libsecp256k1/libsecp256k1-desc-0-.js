searchState.loadedDescShard("libsecp256k1", 0, "Pure Rust implementation of the secp256k1 curve and fast …\nCompressed public key, 33 bytes.\nA static ECMult context.\nA static ECMultGen context.\nFull length public key, 65 bytes.\nHashed message input to an ECDSA signature.\nPublic key on a secp256k1 curve.\nFormat for public key parsing.\nRaw public key, 64 bytes.\nTag used for public key recovery from signatures.\nSecret key (256-bit) on a secp256k1 curve.\nShared secret using ECDH.\nAn ECDSA signature.\nCurve related structs.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nNormalizes a signature to a “low S” form. In ECDSA, …\nParse recovery ID starting with 0.\nParse a DER-encoded byte slice to a signature.\nConverts a “lax DER”-encoded byte slice to a …\nParse an possibly overflowing signature.\nParse a possibly overflowing signature slice. See also …\nParse recovery ID as Ethereum RPC format, starting with 27.\nParse a standard SECP256K1 signature. The signature is …\nParse a standard signature slice. See also <code>parse_standard</code>.\nRecover public key from a signed message.\nRecover public key from a signed message, using the given …\nSerialize a signature to a standard byte representation. …\nSerialize a signature to a DER encoding. This is the …\nSign a message using the secret key.\nSign a message using the secret key, with the given …\nUtilities to manipulate the secp256k1 curve parameters.\nCheck signature is a valid message signed by public key.\nCheck signature is a valid message signed by public key, …\nA group element of the secp256k1 curve, in affine …\nAffine coordinate group element compact storage.\nContext for accelerating the computation of a<em>P + b</em>G.\nContext for accelerating the computation of a*G.\nField element for secp256k1.\nCompact field element storage.\nA group element of the secp256k1 curve, in jacobian …\nA 256-bit scalar value.\nSet r equal to the sum of a and b (with b given in affine …\nSet r equal to the sum of a and b (with b given in affine …\nSet r equal to the sum of a and b. If rzr is non-NULL, …\nSet r equal to the sum of a and b (with the inverse of b’…\nConvert a field element to a 32-byte big endian value. …\nConvert a scalar to a byte array.\nAccess bits from a scalar. All requested bits must belong …\nAccess bits from a scalar. Not constant time.\nConditionally add a power of two to a scalar. The result is\nSets a field element equal to zero, initializing all …\nClear a secp256k1_ge to prevent leaking sensitive …\nClear a secp256k1_gej to prevent leaking sensitive …\nClear a scalar to prevent the leak of sensitive data.\nIf flag is true, set *r equal to *a; otherwise leave it. …\nIf flag is true, set *r equal to *a; otherwise leave it. …\nCompare two field elements. Requires both inputs to be …\nConditionally negate a number, in constant time.\nSet r equal to the double of a. If rzr is not-NULL, r-&gt;z = …\nSet r equal to the double of a. If rzr is not-NULL, r-&gt;z = …\nCompare the X coordinate of a group element (jacobian).\nConvert a scalar to a byte array.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a scalar from an unsigned integer.\nCheck whether a group element’s y coordinate is a …\nInspect raw values of <code>ECMultContext</code>.\nInspect <code>ECMultGenContext</code> values.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSets a field element to be the (modular) inverse of …\nPotentially faster version of secp256k1_fe_inv, without …\nCheck whether a scalar is higher than the group order …\nCheck whether a group element is the point at infinity.\nCheck whether a group element is the point at infinity.\nCheck the “oddness” of a field element. Requires the …\nCheck whether a scalar equals one.\nChecks whether a field element is a quadratic residue.\nCheck whether a group element is valid (i.e., on the …\nVerify whether a field element is zero. Requires the input …\nCheck whether a scalar equals zero.\nSets a field element to be the product of two others. …\nMultiplies the passed field element with a small integer …\nCompute the additive inverse of this element. Takes the …\nSet a field element equal to the additive inverse of …\nSet r equal to the inverse of a (i.e., mirrored around the …\nCreate a new affine.\nCreate a new jacobian.\nCreate a new affine storage.\nGenerate a new <code>ECMultContext</code> on the heap. Note that this …\nGenerate a new <code>ECMultGenContext</code> on the heap. Note that …\nCreate a new <code>ECMultContext</code> from raw values.\nCreate a new <code>ECMultGenContext</code> from raw values.\nNormalize a field element.\nNormalize a field element, without constant-time guarantee.\nWeakly normalize a field element: reduce it magnitude to 1,\nVerify whether a field element represents zero i.e. would …\nVerify whether a field element represents zero i.e. would …\nRescale a jacobian point by b which must be non-zero. …\nSet a field element equal to 32-byte big endian value. If …\nSet a scalar from a big endian byte array, return whether …\nSet a group element (jacobian) equal to another which is …\nSet a group element equal to another which is given in …\nSet a group element (jacobian) equal to the point at …\nSet a field element equal to a small integer. Resulting …\nSet a scalar to an unsigned integer.\nSet a group element (affine) equal to the point with the …\nSet a group element (affine) equal to the point with the …\nSet a group element equal to the point with given X and Y …\nShift a scalar right by some amount strictly between 0 and …\nSets a field element to be the square of another. Requires …\nIf a has a square root, it is computed in r and 1 is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.")