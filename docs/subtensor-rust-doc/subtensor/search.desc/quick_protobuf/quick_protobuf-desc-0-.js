searchState.loadedDescShard("quick_protobuf", 0, "A library to read binary protobuf files\nA module to handle all errors\nA module to deserialize a <code>Message</code> as defined in a .proto …\nA module to manage protobuf deserialization\nA module to compute the binary size of data once encoded\nA module to manage protobuf serialization\nDeprecated feature (in protocol buffer specification)\nContains the error value\nAn error enum\nIo error\nUnexpected map tag\nError while parsing protocol buffer message\nContains the success value\nThe supplied output buffer is not large enough to …\nA wrapper for <code>Result&lt;T, Error&gt;</code>\nOut of data when reading from or writing to a byte buffer\nUnknown wire type\nUtf8 Error\nVarint decoding error\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA trait to provide basic information about a given message\nA trait to handle deserialization from protocol buffers.\nA trait to handle deserialization based on parsed <code>Field</code>s\nFull message path, in form of Module.Message\nConstructs an instance of <code>Self</code> by reading from the given …\nComputes necessary binary size of self once serialized in …\nWrites self into a file\nWrites <code>Self</code> into W writer\nA struct to read protocol binary files\nA struct to read protobuf data\nGets the buffer used internally\nDeserialize a <code>MessageRead from a </code>&amp;u8`\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new reader consuming the bytes\nCreates a new reader from chunks of data\nCreates a new <code>Reader</code> out of a file path\nCreates a new <code>Reader</code>\nGets the inner <code>BytesReader</code>\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks if <code>self.len == 0</code>\nGets the remaining length of bytes not read yet\nReads next tag, <code>None</code> if all bytes have been read\nRun a <code>BytesReader</code> dependent function\nReads bool (varint, check if == 0)\nReads bytes (Vec)\nReads double (little endian f64)\nReads enum, encoded as i32\nReads fixed32 (little endian u32)\nReads fixed64 (little endian u64)\nReads float (little endian f32)\nReads int32 (varint)\nReads int64 (varint)\nReads a map item: (key, value)\nReads a nested message\nReads a nested message\nReads packed repeated field (Vec)\nReads packed repeated field where M can directly be …\nReads sfixed32 (little endian i32)\nReads sfixed64 (little endian i64)\nReads sint32 (varint)\nReads sint64 (varint)\nReads string (String)\nAdvance inner cursor to the end\nReads the next byte\nReads uint32 (varint)\nReads uint64 (varint)\nReads unknown data, based on its tag value (which itself …\nReads the next varint encoded u64\nReads the next varint encoded u64\nComputes the binary size of the varint encoded bool …\nComputes the binary size of the varint encoded enum\nComputes the binary size of the varint encoded i32\nComputes the binary size of the varint encoded i64\nComputes the binary size of a variable length chunk of …\nComputes the binary size of the varint encoded sint32\nComputes the binary size of the varint encoded sint64\nComputes the binary size of the varint encoded uint32\nComputes the binary size of the varint encoded uint64\nComputes the binary size of the varint encoded u64\nA writer backend for byte buffers\nA struct to write protobuf messages\nWriter backend abstraction\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new <code>ProtobufWriter</code>\nCreate a new BytesWriter to write into <code>buf</code>\nWrite all bytes in buf\nWrite a f32\nWrite a f64\nWrite a i32\nWrite a i64\nWrite a u32\nWrite a u64\nWrite a u8\nSerialize a <code>MessageWrite</code> into a byte slice\nSerialize a <code>MessageWrite</code> into a <code>Vec</code>\nWrites a <code>bool</code> 1 = true, 0 = false\nWrites <code>bytes</code>: length first then the chunk of data\nWrites a <code>double</code>\nWrites an <code>enum</code> converting it to a <code>i32</code> first\nWrites a <code>fixed32</code> which is little endian coded <code>u32</code>\nWrites a <code>fixed64</code> which is little endian coded <code>u64</code>\nWrites a <code>float</code>\nWrites a <code>int32</code> which is internally coded as a <code>varint</code>\nWrites a <code>int64</code> which is internally coded as a <code>varint</code>\nWrite entire map\nWrites a message which implements <code>MessageWrite</code>\nWrites packed repeated field: length first then the chunk …\nWrites packed repeated field when we know the size of items\nWrites tag then repeated field with fixed length item size\nWrites tag then repeated field\nWrites tag then repeated field\nWrites a <code>sfixed32</code> which is little endian coded <code>i32</code>\nWrites a <code>sfixed64</code> which is little endian coded <code>i64</code>\nWrites a <code>sint32</code> which is internally coded as a <code>varint</code>\nWrites a <code>sint64</code> which is internally coded as a <code>varint</code>\nWrites <code>string</code>: length first then the chunk of data\nWrites a tag, which represents both the field number and …\nWrites a byte which is NOT internally coded as a <code>varint</code>\nWrites a <code>uint32</code> which is internally coded as a <code>varint</code>\nWrites a <code>uint64</code> which is internally coded as a <code>varint</code>\nWrites a <code>varint</code> (compacted <code>u64</code>)\nWrites another item prefixed with tag")