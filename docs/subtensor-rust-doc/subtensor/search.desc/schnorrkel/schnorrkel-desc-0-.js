searchState.loadedDescShard("schnorrkel", 0, "Schnorr signature variants using Ristretto point …\nHalf-aggregated aka prepared batch signature\nReturns buffer size required for serialization\nAdaptor signature-based implicit certificate scheme for …\nSchnorr signature contexts and configuration, adaptable to …\nImplementation of “hierarchical deterministic key …\nErrors which may occur when parsing keys and/or signatures …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSchnorr signatures on the 2-torsion free subgroup of …\nImplementation for Ristretto Schnorr signatures of “…\nCreate a half-aggregated aka prepared batch signature from …\nRistretto point tooling\nReads a <code>PreparedBatch</code> from a correctly sized buffer\nSchnorr signature creation and verification, including …\nVerify a half-aggregated aka prepared batch signature\nVerify a batch of <code>signatures</code> on <code>messages</code> with their …\nVerify a batch of <code>signatures</code> on <code>messages</code> with their …\nVerify a batch of <code>signatures</code> on <code>messages</code> with their …\nImplementation of a Verifiable Random Function (VRF) using …\nSerializes into exactly sized buffer\nAdaptor Implicit Certificate Public Key Reconstruction Data\nAdaptor Implicit Certificate Secret\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSchnorr signing context\nSchnorr signing transcript\nSchnorr signing transcript with the default <code>ThreadRng</code> …\nVery simple transcript construction from a modern hash …\nAttach a <code>CryptoRng</code> to a <code>SigningTranscript</code> to replace the …\nInitialize an owned signing transcript on a message …\nProduce some challenge bytes, shadowed by …\nProduce the public challenge scalar <code>e</code>.\nExtend transcript with some bytes, shadowed by …\nExtend the transcript with a compressed Ristretto point\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInitialize an owned signing transcript on a message …\nInitialize an owned signing transcript on a message …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a <code>XoFTranscript</code> from a conventional hash functions …\nInitialize a signing context from a static byte string that\nExtend transcript with a protocol name\nInitialize a signing context from a static byte string that\nProduce secret witness bytes from the protocol transcript …\nProduce secret witness bytes from the protocol transcript …\nProduce a secret witness scalar <code>k</code>, aka nonce, from the …\nInitialize an owned signing transcript on a message …\nLength in bytes of our chain codes.\nWe cannot assume the original public key is secret and …\nKey types that support “hierarchical deterministic” …\nA convenience wraper that combines derivable key and a …\nWe cannot assume the original public key is secret and …\nDerive key with subkey identified by a byte array …\nDerive key with subkey identified by a byte array …\nDerive key with subkey identified by a byte array and a …\nDerive key with subkey identified by a byte array and a …\nDerive key with subkey identified by a byte array and a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nVaguely BIP32-like “hard” derivation of a <code>MiniSecretKey</code>…\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAppropriate key type\nAn error in the length of bytes handed to a constructor.\nInitial commitment phase of a multi-signature\nActual cosigning phase of a multi-signature\nA signature verification equation failed.\nContains the error value\nThe provided key is not valid.\nThere is no record of the preceding multi-signautre …\nFor this public key, there are either conflicting records …\nThree-round trip multi-signature stage identifies used in …\nSignature not marked as schnorrkel, maybe try ed25519 …\nContains the success value\nInvalid point provided, usually to <code>verify</code> methods.\nReveal phase of a multi-signature\nInvalid scalar provided, usually to <code>Signature::from_bytes</code>.\nErrors which may occur while processing signatures and …\n<code>Result</code> specialized to this crate for convenience.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDescribes the type returning the error\nSet true if the stage was reached correctly once but this …\nLength expected by the constructor in bytes\nIdentifies the multi-signature protocol stage during which …\nIdentifies the multi-signature protocol stage during which …\nIdentifies the type returning the error\nAvoids importing <code>ExpansionMode</code>\nExpand this <code>MiniSecretKey</code> into a <code>SecretKey</code> using …\nMethods for expanding a <code>MiniSecretKey</code> into a <code>SecretKey</code>.\nThe length of an Ristretto Schnorr <code>Keypair</code>, in bytes.\nA Ristretto Schnorr keypair.\nThe length of a Ristretto Schnorr <code>MiniSecretKey</code>, in bytes.\nAn EdDSA-like “secret” key seed.\nThe length of a Ristretto Schnorr <code>PublicKey</code>, in bytes.\nA Ristretto Schnorr public key.\nThe length of a Ristretto Schnorr key, <code>SecretKey</code>, in bytes.\nA secret key for use with Ristretto Schnorr signatures.\nAvoids importing <code>ExpansionMode</code>\nExpand the <code>MiniSecretKey</code> into a uniformly distributed …\nAccept an Adaptor implicit certificate\nView this secret key as a byte array.\nAccess the compressed Ristretto form\nAccess the point form\nDerive a secret key and new chain code from a key pair and …\nProduce DLEQ proof.\nVerify DLEQ proof that <code>p.output = s * p.input</code> where <code>self</code> <code>s</code> …\nDerive the <code>SecretKey</code> corresponding to this <code>MiniSecretKey</code>.\nDerive the <code>Keypair</code> corresponding to this <code>MiniSecretKey</code>.\nDerive the <code>PublicKey</code> corresponding to this <code>MiniSecretKey</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstruct a <code>MiniSecretKey</code> from a slice of bytes.\nConstruct an <code>SecretKey</code> from a slice of bytes.\nConstruct a <code>PublicKey</code> from a slice of bytes.\nDeserialize a <code>Keypair</code> from bytes.\nDecompress into the <code>PublicKey</code> format that also retains the …\nConstruct an <code>SecretKey</code> from a slice of bytes, …\nDeserialize a <code>Keypair</code> from bytes with Ed25519 style …\nCompress into the <code>PublicKey</code> format that also retains the …\nGenerate a <code>MiniSecretKey</code> from rand’s <code>thread_rng</code>.\nGenerate an “unbiased” <code>SecretKey</code> directly, bypassing …\nGenerate a Ristretto Schnorr <code>Keypair</code> directly, from a user …\nGenerate a <code>MiniSecretKey</code> from a <code>csprng</code>.\nGenerate an “unbiased” <code>SecretKey</code> directly from a user …\nGenerate a Ristretto Schnorr <code>Keypair</code> directly, bypassing …\nVaguely BIP32-like “hard” derivation of a <code>MiniSecretKey</code>…\nVaguely BIP32-like “hard” derivation of a <code>MiniSecretKey</code>…\nVaguely BIP32-like “hard” derivation of a <code>MiniSecretKey</code>…\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nExtract the compressed Ristretto form\nExtract the point form\nIssue an Adaptor implicit certificate\nIssue an Adaptor Implicit Certificate for yourself\nInitialize a multi-signature aka cosignature protocol run.\nExtract the certified pulic key from an adaptor certificate\nThe public half of this keypair.\nThe secret half of this keypair.\nSign a transcript with this <code>SecretKey</code>.\nSign a transcript with this keypair’s secret key.\nSign a message with this <code>SecretKey</code>, but doublecheck the …\nSign a message with this <code>SecretKey</code>, but doublecheck the …\nSign a message with this <code>SecretKey</code>.\nSign a message with this keypair’s secret key.\nSign a message with this <code>SecretKey</code>, but doublecheck the …\nSign a message with this <code>SecretKey</code>, but doublecheck the …\nConvert this secret key to a byte array.\nConvert this <code>SecretKey</code> into an array of 64 bytes with.\nConvert this public key to a byte array.\nSerialize <code>Keypair</code> to bytes.\nConvert this <code>SecretKey</code> into an array of 64 bytes, …\nSerialize <code>Keypair</code> to bytes with Ed25519 secret key format.\nDerive the <code>PublicKey</code> corresponding to this <code>SecretKey</code>.\nDerive the <code>PublicKey</code> corresponding to this <code>SecretKey</code>.\nVerify a signature by this public key on a transcript.\nVerify a signature by keypair’s public key on a …\nVerify a signature by this public key on a message.\nVerify a signature by keypair’s public key on a message.\nA temporary verification routine for use in transitioning …\nPair a non-malleable VRF output with the hash of the given …\nEvaluate the VRF-like multiplication on a compressed point,\nEvaluate the VRF-like multiplication on an uncompressed …\nEvaluate the VRF on the given transcript.\nCreate a non-malleable VRF input point by hashing a …\nRun VRF on one single input transcript, producing the …\nRun VRF on one single input transcript, producing the …\nRun VRF on one single input transcript and an extra …\nRun VRF on one single input transcript, producing the …\nVerify VRF proof for one single input transcript and …\nVerify VRF proof for one single input transcript and …\nMerge VRF input and output pairs from the same signer, …\nRun VRF on several input transcripts, producing their …\nRun VRF on several input transcripts and an extra message …\nVerify a common VRF short proof for several input …\nVerify a common VRF short proof for several input …\nAny data structure used for aggregating public keys.\nAggregation helper for public keys kept in slices\nInitial stage for cosignature collectors who do not …\nCommitment stage for cosigner’s <code>R</code> values\nCommitments to <code>R_i</code> values shared between cosigners during …\nFinal cosigning stage collection\nCosignatures shared between cosigners during signing\nSchnorr multi-signature (MuSig) container generic over its …\nRevealed <code>R_i</code> values shared between cosigners during signing\nReveal stage for cosigner’s <code>R</code> values\nInitial cosigning stages during which transcript …\nAdds revealed <code>R</code> and cosignature into a cosignature …\nAdd a new cosigner’s public key and associated <code>R</code> …\nInclude a cosignature from another cosigner\nInclude a revealed <code>R</code> value from a previously committed …\nAdd a new cosigner’s public key and associated <code>R</code> …\nAggregate public keys stored in a mutable slice\nAggregate public keys stored in a mutable slice\nAggregate public keys stored in a sorted slice\nInitialize a collector of cosignatures who does not …\nReveal to cosign phase transition.\nInterate over the cosigners who successfully revaled and …\nAggregate public key expected if all currently committed …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInitialize a multi-signature aka cosignature protocol run.\nOur commitment to our <code>R</code> to send to all other cosigners\nReveals our signature contribution\nReveal our <code>R</code> contribution to send to all other cosigners\nReturns aggregated public key.\nAggregate public key given currently revealed <code>R</code> values\nIterates over public keys.\nCommit to reveal phase transition.\nActually computes the cosignature\nActually computes the collected cosignature.\nWe permit extending the transcript whenever you like, so …\nInterate over the possible cosigners who successfully …\nReturn delinearization weighting for one of many public …\nCompressed Ristretto point length\nA <code>RistrettoBoth</code> contains both an uncompressed …\nAccess the compressed Ristretto form\nAccess the point form\nReturns the argument unchanged.\nConstruct a <code>RistrettoBoth</code> from a slice of bytes.\nVariant of <code>RistrettoBoth::from_bytes</code> that propagates more …\nDecompress into the <code>RistrettoBoth</code> format that also retains …\nCompress into the <code>RistrettoBoth</code> format that also retains …\nCalls <code>U::from(self)</code>.\nExtract the compressed Ristretto form\nExtract the point form\nConvert this public key to a byte array.\nThe length of a curve25519 EdDSA <code>Signature</code>, in bytes.\nA Ristretto Schnorr signature “detached” from the …\nReturns the argument unchanged.\nConstruct a <code>Signature</code> from a slice of bytes.\nDeprecated construction of a <code>Signature</code> from a slice of …\nCalls <code>U::from(self)</code>.\nConvert this <code>Signature</code> to a byte array.\nValue for <code>kusama</code> paramater to <code>*dleq*</code> methods that yields …\nVRF SigningTranscript for malleable VRF outputs.\nReal underlying <code>SigningTranscript</code>\nVRF input and output paired together, possibly unverified.\nVRF pre-output, possibly unverified.\nVRF pre-output, possibly unverified.\nShort proof of correctness for associated VRF output, for …\nLonger proof of correctness for associated VRF output, …\n<code>SigningTranscript</code> helper trait that manages VRF output …\nLength of VRF output.\nLength of the longer VRF proof which supports batch …\nLength of the short VRF proof which lacks support for …\nView this secret key as a byte array.\nVRF output point bytes for serialization.\nPair a non-malleable VRF output with the hash of the given …\nCommit VRF input and output to a transcript.\nBatch verify DLEQ proofs where the public keys were held by\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstruct a <code>VRFPreOut</code> from a slice of bytes.\nConstruct a <code>VRFProof</code> from a slice of bytes.\nConstruct a <code>VRFProofBatchable</code> from a slice of bytes.\nVRF input point\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRaw bytes output from the VRF.\nVRF output converted into Merlin’s Keccek based <code>Rng</code>.\nVRF output converted into any <code>SeedableRng</code>.\nVRF output point\nReturn the shortened <code>VRFProof</code> for retransmitting in not …\nReturn the shortened <code>VRFProof</code> for retransmitting in …\nConvert this VRF output to a byte array.\nConvert this <code>VRFProof</code> to a byte array.\nConvert this <code>VRFProofBatchable</code> to a byte array.\nVRF output point bytes for serialization.\nReturn the underlying <code>SigningTranscript</code> after addressing …\nCreate a malleable VRF input point by hashing a transcript …\nBatch verify VRFs by different signers")