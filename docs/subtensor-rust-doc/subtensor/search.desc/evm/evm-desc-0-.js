searchState.loadedDescShard("evm", 0, "Ethereum Virtual Machine implementation in Rust\n<code>ADD</code>\n<code>ADDMOD</code>\n<code>ADDRESS</code>\n<code>AND</code>\nReading basic account from storage. Fixed size.\nReading address code from storage. Dynamic size.\n<code>BALANCE</code>\n<code>BASEFEE</code>\n<code>BLOCKHASH</code>\n<code>BYTE</code>\n<code>CALL</code>\n<code>CALLCODE</code>\n<code>CALLDATACOPY</code>\n<code>CALLDATALOAD</code>\n<code>CALLDATASIZE</code>\n<code>CALLER</code>\n<code>CALLVALUE</code>\n<code>CHAINID</code>\n<code>CODECOPY</code>\n<code>CODESIZE</code>\n<code>COINBASE</code>\n<code>CREATE</code>\n<code>CREATE2</code>\nCall interrupt resolution.\n<code>CALL</code>\n<code>CALLCODE</code>\nThe environment explicitly set call errors as fatal error.\nFeedback value of <code>CALL</code> interrupt.\nType of <code>CALL</code> interrupt.\nCall scheme.\nCall stack is too deep (runtime).\nCapture represents the result of execution.\nRuntime configuration.\nContext of the runtime.\nCreate interrupt resolution.\nCreate scheme of <code>CREATE2</code>.\nCreate opcode encountered collision (runtime).\nCreate init code exceeds limit (runtime).\nAttempt to create an empty account (runtime, unused).\nFeedback value for <code>CREATE</code> interrupt.\nType of <code>CREATE</code> interrupt.\nCreate scheme.\n<code>DELEGATECALL</code>\n<code>DIFFICULTY</code>\n<code>DIV</code>\n<code>DUPn</code>\n<code>DELEGATECALL</code>\nEncountered the designated invalid opcode.\nSee EIP-3541\n<code>EQ</code>\n<code>EXP</code>\n<code>EXTCODECOPY</code>\n<code>EXTCODEHASH</code>\n<code>EXTCODESIZE</code>\nMachine returns a normal EVM error.\nThe machine has exited. It cannot be executed again.\nExit error reason.\nExit fatal reason.\nExit reason.\nExit revert reason.\nExit succeed reason.\nOperations for recording external costs\nMachine encountered an error that is not supposed to be …\nCreate at a fixed location.\n<code>GAS</code>\n<code>GASLIMIT</code>\n<code>GASPRICE</code>\n<code>GT</code>\nEVM context handler.\n<code>INVALID</code>\n<code>ISZERO</code>\nInvalid opcode during execution or starting byte is 0xef. …\nJump destination is invalid.\nAn opcode accesses memory region, but the region is …\nBasic check for account emptiness. Fixed size.\n<code>JUMP</code>\n<code>JUMPDEST</code>\n<code>JUMPI</code>\n<code>LOGn</code>\n<code>LT</code>\nLegacy create scheme of <code>CREATE</code>.\n<code>MLOAD</code>\n<code>MOD</code>\n<code>MSIZE</code>\n<code>MSTORE</code>\n<code>MSTORE8</code>\n<code>MUL</code>\n<code>MULMOD</code>\nCore execution layer for EVM.\nNonce reached maximum value of 2^64-1 …\nA sequencial memory. It uses Rust’s <code>Vec</code> for internal …\n<code>NOT</code>\n<code>NUMBER</code>\nThe operation is not supported.\n<code>OR</code>\n<code>ORIGIN</code>\nOpcode enum. One-to-one corresponding to an <code>u8</code> value.\nOther normal errors.\nOther fatal errors.\nNot enough fund to start the execution (runtime).\nExecution runs out of gas (runtime).\nAn opcode accesses external information, but the request …\n<code>PC</code>\nPC underflowed (unused).\n<code>POP</code>\n<code>PUSHn</code>\n<code>RETURN</code>\n<code>RETURNDATACOPY</code>\n<code>RETURNDATASIZE</code>\n<code>REVERT</code>\nInterrupt resolution.\nCall interrupt resolution.\nCreate interrupt resolution.\nMachine encountered an explicit return.\nMachine encountered an explicit revert.\nMachine encountered an explicit revert.\nEVM runtime.\n<code>SAR</code>\n<code>SDIV</code>\n<code>SELFBALANCE</code>\n<code>SGT</code>\n<code>SHA3</code>\n<code>SHL</code>\n<code>SHR</code>\n<code>SIGNEXTEND</code>\n<code>SLOAD</code>\n<code>SLT</code>\n<code>SMOD</code>\n<code>SSTORE</code>\n<code>STATICCALL</code>\n<code>STOP</code>\n<code>SUB</code>\n<code>SUICIDE</code>\n<code>SWAPn</code>\nEVM stack.\nTrying to push into a stack over stack limit.\nTrying to pop from an empty stack.\n<code>STATICCALL</code>\nMachine encountered an explicit stop.\nMachine has succeeded.\nMachine encountered an explicit suicide.\n<code>TIMESTAMP</code>\nTransfer from source to target, with given value.\nTrap which indicates that an <code>ExternalOpcode</code> has to be …\nThe machine has trapped. It is waiting for external …\nThe trap (interrupt) is unhandled.\nMapping of valid jump destination from code.\nWriting to storage (Number of bytes written).\n<code>XOR</code>\nExecution address.\nApparent value of the EVM.\nEVM backends\nGet balance of address.\nBerlin hard fork configuration.\nEnvironmental block base fee.\nGet environmental coinbase.\nGet environmental block difficulty.\nGet environmental gas limit.\nGet environmental block hash.\nGet environmental block number.\nGet environmental block randomness.\nGet environmental block timestamp.\nInvoke a call operation.\nFeed in call feedback.\nTake l64 for callcreate after gas.\nCall limit.\nCall stipend.\nCaller of the EVM.\nGet environmental chain ID.\nGet code of address.\nGet code hash of address.\nGet code size of address.\nGet a reference to the execution context.\nCopy <code>data</code> into the memory, of given <code>len</code>.\nInvoke a create operation.\nCreate contract limit.\nFeed in create feedback.\nWhether create transactions and create opcode increases …\nReturn the full memory.\nStack data.\nEIP-3529\nCheck whether an address has already been deleted.\nEIP-3541\nGet the effective length.\nWhether empty account is considered exists.\nWhether to throw out of gas error when …\nWhether the gasometer is running in estimate mode.\nEVM executors\nCheck whether an address exists.\nExplicit exit of the machine. Further step will return …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nFrontier hard fork configuration.\nGas paid per address in transaction access list (see …\nGas paid per storage key in transaction access list (see …\nGas paid for accessing cold account.\nGas paid for BALANCE opcode.\nGas paid for CALL opcode.\nGas paid for EXP opcode for every byte.\nGas paid for extcode.\nGas paid for extcodehash.\nGet the gas left value.\nGet the gas price value.\nGas paid for SLOAD opcode.\nGas paid for cold SLOAD opcode.\nGas paid for sstore reset.\nGas paid for sstore set.\nGas paid for accessing ready storage.\nGas paid for SUICIDE opcode.\nGas paid for SUICIDE opcode when it hits a new account.\nGas paid for a message call transaction.\nGas paid for a contract creation transaction.\nGas paid for non-zero data in a transaction.\nGas paid for zero data in a transaction.\nGet memory region at given offset.\nHas ext block fee. See EIP-3198\nHas bitwise shifting.\nHas chain ID.\nHas create2.\nHas delegate call.\nHas ext code hash.\nHas PUSH0 opcode. See EIP-3855\nHas return data.\nHas revert.\nHas self balance.\nEIP-2929\nInspect the machine’s next opcode and current stack.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks if the address or (address, index) pair has been …\nReturn true if current effective memory range is zero.\nWhether the stack is empty.\nReturns true if the valids list is empty\nWhether the exit is error.\nWhether the exit is fatal.\nWhether the opcode is a push opcode.\nWhether the exit is revert.\nWhether the exit is succeeded.\nReturns <code>true</code> if the position is a valid jump destination. …\nIstanbul hard fork configuration.\nGet the length of the current memory range.\nStack length.\nGet the length of the valid mapping. This is the same as …\nMemory limit.\nStack limit.\nCreate a log owned by address with given topics and data.\nlondon hard fork configuration.\nGet a reference to the machine.\nMark an address to be deleted, with funds transferred to …\nEIP-3860, maximum size limit of init_code.\nEIP-3529\nA module containing the <code>MaybeBorrowed</code> enum. See its …\nReference of machine memory.\nMemory limit.\nMutable reference of machine memory.\nThe Merge (Paris) hard fork configuration.\nCreate a new runtime with given code and data.\nCreate a new machine with given code and data.\nCreate a new memory with the given limit.\nCreate a new stack with given limit.\nCreate a new valid mapping from given code bytes.\nGet execution origin.\nGet original storage value of address at index.\nHandle other unknown external opcodes.\nPeek a value at given index for the stack, where the top of\nPop a value from the stack. If the stack is already empty, …\nReturn a reference of the program counter.\nPre-validation step for the runtime.\nPush a new value into the stack. If it will exceed the …\nRecords some associated <code>ExternalOperation</code>.\nGas paid for sstore refund.\nResize the memory, making it cover to <code>end</code>, with 32 bytes …\nResize the memory, making it cover the memory region of `…\nCopy and get the return value of the machine, if any.\nLoop stepping the runtime until it stops.\nLoop stepping the machine, until it stops.\nSet memory region at given offset. The offset and value is …\nSet a value at given index for the stack, where the top of …\nSet storage value of address at index.\nShanghai hard fork configuration.\nSource address.\nEIP-1283.\nEIP-1706.\nReference of machine stack.\nStack limit.\nMutable reference of machine stack.\nStep the runtime.\nStep the machine, executing one opcode. It then returns.\nGet storage value of address at index.\nTarget address.\nTransfer value.\nEIP-3651\nCaller of the create.\nCaller of the create.\nCode hash.\nSalt.\nApply state operation.\nEVM backend that can apply changes.\nEVM backend.\nBasic account information.\nDelete address.\nAccount information of a memory backend.\nMemory backend, storing all state values in a <code>BTreeMap</code> in …\nVicinity value of a memory backend.\nModify or create at address.\nApply given values and logs at backend.\nAccount balance.\nAccount balance.\nGet basic account information.\nEnvironmental block base fee.\nEnvironmental base fee per gas.\nEnvironmental coinbase.\nEnvironmental coinbase.\nEnvironmental block difficulty.\nEnvironmental block difficulty.\nEnvironmental block gas limit.\nEnvironmental block gas limit.\nEnvironmental block hash.\nEnvironmental block hashes.\nEnvironmental block number.\nEnvironmental block number.\nGet environmental block randomness.\nEnvironmental randomness.\nEnvironmental block timestamp.\nEnvironmental block timestamp.\nEnvironmental chain ID.\nChain ID.\nGet account code.\nAccount code.\nWhether account at address exists.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGas price. Unused for London.\nGas price.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new memory backend.\nAccount nonce.\nAccount nonce.\nOrigin.\nOrigin.\nGet original storage value of address at index, if …\nGet the underlying <code>BTreeMap</code> storing the state.\nGet a mutable reference to the underlying <code>BTreeMap</code> storing …\nGet storage value of address at index.\nFull account storage.\nAddress.\nAddress.\nBasic information of the address.\nCode. <code>None</code> means leaving it unchanged.\nWhether storage should be wiped empty before applying the …\nStorage iterator.\nA stack-based executor with customizable state. A …\nReverts the state changes and consume all the gas.\nMark this failure as fatal, and all EVM execution stacks …\nData returned by a precompile in case of failure.\nPrecompiles function signature. Expected input arguments …\nHandle provided to a precompile to interact with the EVM.\nData returned by a precompile on success.\nA set of precompiles.\nReverts the state changes. Returns the provided error …\nStack-based executor.\nReturns a mutable reference to an account given its address\nPerform subcall in provided context. Precompile specifies …\nRetreive the code address (what is the address of the …\nFetch the code hash of an address. Provide a default …\nFetch the code hash of an address. Provide a default …\nFetch the code size of an address. Provide a default …\nFetch the code size of an address. Provide a default …\nReturn a reference of the Config.\nRetreive the context in which the precompile is executed.\nGet the create address from given scheme.\nDeconstruct the memory stack substate, return state to be …\nCreate a substate executor from the current executor.\nTries to execute a precompile in the precompile set. If …\nExecute the runtime until it returns.\nExit a substate. Panic if it results an empty substate …\nGet fee needed for the current executor, given the price.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet remaining gas.\nRetreive the gas limit of this call.\nRetreive the input data the precompile is called with.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if the given address is a precompile. Should only be …\nIs the precompile call is done statically.\nRecord a log.\nCreate a new stack-based executor with given precompiles.\nGet account nonce.\nReturn a reference to the precompile set.\nRecord cost to the Runtime gasometer.\nRecord Substrate specific cost.\nRefund Substrate specific cost.\nRetreive the remaining gas.\nExecute a <code>CALL</code> transaction with a given caller, address, …\nExecute a <code>CREATE</code> transaction.\nExecute a <code>CREATE2</code> transaction.\nGet used gas for the current executor, given the price.\nSimilar to <code>Cow</code> from the standard library, but without …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.")