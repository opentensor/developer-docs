searchState.loadedDescShard("libp2p_dns", 0, "DNS name resolution\nThe possible errors of a <code>Transport</code> wrapped transport.\nAn error got returned from IO\nAn error with an arbitrary message, referenced as &amp;’…\nAn error with an arbitrary message, stored as String\nDNS resolution was successful, but the underlying …\nDNS resolution was successful, but the underlying …\nNo resolvers available\nNo records were found for a query\nAn error got returned by the trust-dns-proto crate\nThe error type for errors that get returned in the crate\nDNS resolution failed.\nDNS resolution failed.\nThe error kind for errors that get returned in the crate\nConfiguration for the upstream nameservers to use for …\nConfiguration for the Resolver\nA request timed out\nDNS resolution involved too many lookups.\nDNS resolution involved too many lookups.\nA <code>Transport</code> for performing DNS lookups when dialing …\nThe underlying transport encountered an error.\nThe underlying transport encountered an error.\nAdd the configuration for a name server\nAdd a search domain\nNumber of retries after lookup failure before giving up. …\nThis is true by default, disabling this is useful for …\nCache size is in number of records (some records can be …\nValidate the names in the response, not implemented don’…\nCreates a default configuration, using <code>1.1.1.1</code>, <code>1.0.0.1</code> …\nCreates a <code>Transport</code> with a custom resolver configuration …\nCreates a default configuration, using <code>8.8.8.8</code>, <code>8.8.4.4</code> …\nDefault values for the Resolver configuration.\nReturns the local domain\nEnable edns, for larger records\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a ResolverConfig with all parts specified\nA conversion to determine if the response is an error\nCreates a default configuration, using <code>8.8.8.8</code>, <code>8.8.4.4</code> …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe ip_strategy for the Resolver to use when lookup Ipv4 …\nGet the kind of the error\nReturns a reference to the name servers\nSets the number of dots that must appear (unless it’s a …\nOptional maximum TTL for negative (<code>NXDOMAIN</code>) responses.\nOptional minimum TTL for negative (<code>NXDOMAIN</code>) responses.\nCreates a new empty configuration\nNumber of concurrent requests per query\nOptional maximum TTL for positive responses.\nOptional minimum TTL for positive responses.\nPreserve all intermediate records in the lookup response, …\nCreates a configuration, using <code>9.9.9.9</code>, <code>149.112.112.112</code> …\nRequest upstream recursive resolvers to not perform any …\nRotate through the resource records in the response (if …\nReturns the search domains\nThe server ordering strategy that the resolver should use.\nSet the domain of the entity querying results.\nShuffle DNS servers before each query.\nCreates a new <code>Transport</code> from the OS’s DNS configuration …\nSpecify the timeout for a request. Defaults to 5 seconds\nTry queries over TCP if they fail over UDP.\nCheck /ect/hosts file before dns requery (only works for …\nUse DNSSEC to validate the request\nnegative ttl, as determined from DnsResponse::negative_ttl …\nThe query for which no records were found.\nResponseCode, if <code>NXDOMAIN</code>, the domain does not exist (and …\nIf an SOA is present, then this is an authoritative …\nIf we trust <code>NXDOMAIN</code> errors from this server\nA <code>Transport</code> wrapper for performing DNS lookups when …\nCreates a <code>Transport</code> with a custom resolver configuration …\nCreates a new <code>Transport</code> from the OS’s DNS configuration …")