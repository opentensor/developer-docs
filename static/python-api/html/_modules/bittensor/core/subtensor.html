
<!DOCTYPE html>


<html lang="en" data-content_root="../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>bittensor.core.subtensor &#8212; Bittensor SDK Docs  documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/sphinx-book-theme.css?v=a3416100" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=fd3f3429" />
    <link rel="stylesheet" type="text/css" href="../../../_static/bittensor-custom.css?v=c1dfe055" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/bittensor/core/subtensor';</script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../../_static/logo.svg" class="logo__image only-light" alt="Bittensor SDK Docs  documentation - Home"/>
    <script>document.write(`<img src="../../../_static/logo-dark-mode.svg" class="logo__image only-dark" alt="Bittensor SDK Docs  documentation - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Table of Contents</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../autoapi/index.html">API Reference</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../autoapi/bittensor/index.html">bittensor</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../autoapi/bittensor/core/index.html">bittensor.core</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/chain_data/index.html">bittensor.core.chain_data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/extrinsics/index.html">bittensor.core.extrinsics</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/axon/index.html">bittensor.core.axon</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/config/index.html">bittensor.core.config</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/dendrite/index.html">bittensor.core.dendrite</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/errors/index.html">bittensor.core.errors</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/metagraph/index.html">bittensor.core.metagraph</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/settings/index.html">bittensor.core.settings</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/stream/index.html">bittensor.core.stream</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/subtensor/index.html">bittensor.core.subtensor</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/synapse/index.html">bittensor.core.synapse</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/tensor/index.html">bittensor.core.tensor</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/threadpool/index.html">bittensor.core.threadpool</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/types/index.html">bittensor.core.types</a></li>
</ul>
</details></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../autoapi/bittensor/utils/index.html">bittensor.utils</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/btlogging/index.html">bittensor.utils.btlogging</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/mock/index.html">bittensor.utils.mock</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/axon_utils/index.html">bittensor.utils.axon_utils</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/balance/index.html">bittensor.utils.balance</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/deprecated/index.html">bittensor.utils.deprecated</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/formatting/index.html">bittensor.utils.formatting</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/networking/index.html">bittensor.utils.networking</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/register_cuda/index.html">bittensor.utils.register_cuda</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/registration/index.html">bittensor.utils.registration</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/subnets/index.html">bittensor.utils.subnets</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/version/index.html">bittensor.utils.version</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/weight_utils/index.html">bittensor.utils.weight_utils</a></li>
</ul>
</details></li>
<li class="toctree-l3"><a class="reference internal" href="../../../autoapi/bittensor/__main__/index.html">bittensor.__main__</a></li>
</ul>
</details></li>
</ul>
</details></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/opentensor/btcli" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/opentensor/btcli/issues/new?title=Issue%20on%20page%20%2F_modules/bittensor/core/subtensor.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1></h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for bittensor.core.subtensor</h1><div class="highlight"><pre>
<span></span><span class="c1"># The MIT License (MIT)</span>
<span class="c1"># Copyright © 2024 Opentensor Foundation</span>
<span class="c1">#</span>
<span class="c1"># Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated</span>
<span class="c1"># documentation files (the “Software”), to deal in the Software without restriction, including without limitation</span>
<span class="c1"># the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,</span>
<span class="c1"># and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</span>
<span class="c1">#</span>
<span class="c1"># The above copyright notice and this permission notice shall be included in all copies or substantial portions of</span>
<span class="c1"># the Software.</span>
<span class="c1">#</span>
<span class="c1"># THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO</span>
<span class="c1"># THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL</span>
<span class="c1"># THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION</span>
<span class="c1"># OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER</span>
<span class="c1"># DEALINGS IN THE SOFTWARE.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The ``bittensor.core.subtensor`` module in Bittensor serves as a crucial interface for interacting with the Bittensor</span>
<span class="sd">blockchain, facilitating a range of operations essential for the decentralized machine learning network.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">argparse</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">ssl</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">TypedDict</span><span class="p">,</span> <span class="n">Any</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scalecodec</span>
<span class="kn">from</span> <span class="nn">bittensor_wallet</span> <span class="kn">import</span> <span class="n">Wallet</span>
<span class="kn">from</span> <span class="nn">numpy.typing</span> <span class="kn">import</span> <span class="n">NDArray</span>
<span class="kn">from</span> <span class="nn">retry</span> <span class="kn">import</span> <span class="n">retry</span>
<span class="kn">from</span> <span class="nn">scalecodec.base</span> <span class="kn">import</span> <span class="n">RuntimeConfiguration</span>
<span class="kn">from</span> <span class="nn">scalecodec.exceptions</span> <span class="kn">import</span> <span class="n">RemainingScaleBytesNotEmptyException</span>
<span class="kn">from</span> <span class="nn">scalecodec.type_registry</span> <span class="kn">import</span> <span class="n">load_type_registry_preset</span>
<span class="kn">from</span> <span class="nn">scalecodec.types</span> <span class="kn">import</span> <span class="n">ScaleType</span>
<span class="kn">from</span> <span class="nn">substrateinterface.base</span> <span class="kn">import</span> <span class="n">QueryMapResult</span><span class="p">,</span> <span class="n">SubstrateInterface</span>

<span class="kn">from</span> <span class="nn">bittensor.core</span> <span class="kn">import</span> <span class="n">settings</span>
<span class="kn">from</span> <span class="nn">bittensor.core.axon</span> <span class="kn">import</span> <span class="n">Axon</span>
<span class="kn">from</span> <span class="nn">bittensor.core.chain_data</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">custom_rpc_type_registry</span><span class="p">,</span>
    <span class="n">DelegateInfo</span><span class="p">,</span>
    <span class="n">NeuronInfo</span><span class="p">,</span>
    <span class="n">NeuronInfoLite</span><span class="p">,</span>
    <span class="n">PrometheusInfo</span><span class="p">,</span>
    <span class="n">SubnetHyperparameters</span><span class="p">,</span>
    <span class="n">SubnetInfo</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">bittensor.core.config</span> <span class="kn">import</span> <span class="n">Config</span>
<span class="kn">from</span> <span class="nn">bittensor.core.extrinsics.commit_weights</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">commit_weights_extrinsic</span><span class="p">,</span>
    <span class="n">reveal_weights_extrinsic</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">bittensor.core.extrinsics.registration</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">burned_register_extrinsic</span><span class="p">,</span>
    <span class="n">register_extrinsic</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">bittensor.core.extrinsics.root</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">root_register_extrinsic</span><span class="p">,</span>
    <span class="n">set_root_weights_extrinsic</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">bittensor.core.extrinsics.serving</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">do_serve_axon</span><span class="p">,</span>
    <span class="n">serve_axon_extrinsic</span><span class="p">,</span>
    <span class="n">publish_metadata</span><span class="p">,</span>
    <span class="n">get_metadata</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">bittensor.core.extrinsics.set_weights</span> <span class="kn">import</span> <span class="n">set_weights_extrinsic</span>
<span class="kn">from</span> <span class="nn">bittensor.core.extrinsics.transfer</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">transfer_extrinsic</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">bittensor.core.metagraph</span> <span class="kn">import</span> <span class="n">Metagraph</span>
<span class="kn">from</span> <span class="nn">bittensor.utils</span> <span class="kn">import</span> <span class="n">networking</span><span class="p">,</span> <span class="n">torch</span><span class="p">,</span> <span class="n">ss58_to_vec_u8</span><span class="p">,</span> <span class="n">u16_normalized_float</span>
<span class="kn">from</span> <span class="nn">bittensor.utils.balance</span> <span class="kn">import</span> <span class="n">Balance</span>
<span class="kn">from</span> <span class="nn">bittensor.utils.btlogging</span> <span class="kn">import</span> <span class="n">logging</span>
<span class="kn">from</span> <span class="nn">bittensor.utils.registration</span> <span class="kn">import</span> <span class="n">legacy_torch_api_compat</span>
<span class="kn">from</span> <span class="nn">bittensor.utils.weight_utils</span> <span class="kn">import</span> <span class="n">generate_weight_hash</span>

<span class="n">KEY_NONCE</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>


<div class="viewcode-block" id="ParamWithTypes">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.ParamWithTypes">[docs]</a>
<span class="k">class</span> <span class="nc">ParamWithTypes</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>  <span class="c1"># Name of the parameter.</span>
    <span class="nb">type</span><span class="p">:</span> <span class="nb">str</span>  <span class="c1"># ScaleType string of the parameter.</span></div>



<div class="viewcode-block" id="Subtensor">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor">[docs]</a>
<span class="k">class</span> <span class="nc">Subtensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The Subtensor class in Bittensor serves as a crucial interface for interacting with the Bittensor blockchain,</span>
<span class="sd">    facilitating a range of operations essential for the decentralized machine learning network.</span>

<span class="sd">    This class enables neurons (network participants) to engage in activities such as registering on the network,</span>
<span class="sd">    managing staked weights, setting inter-neuronal weights, and participating in consensus mechanisms.</span>

<span class="sd">    The Bittensor network operates on a digital ledger where each neuron holds stakes (S) and learns a set</span>
<span class="sd">    of inter-peer weights (W). These weights, set by the neurons themselves, play a critical role in determining</span>
<span class="sd">    the ranking and incentive mechanisms within the network. Higher-ranked neurons, as determined by their</span>
<span class="sd">    contributions and trust within the network, receive more incentives.</span>

<span class="sd">    The Subtensor class connects to various Bittensor networks like the main ``finney`` network or local test</span>
<span class="sd">    networks, providing a gateway to the blockchain layer of Bittensor. It leverages a staked weighted trust</span>
<span class="sd">    system and consensus to ensure fair and distributed incentive mechanisms, where incentives (I) are</span>
<span class="sd">    primarily allocated to neurons that are trusted by the majority of the network.</span>

<span class="sd">    Additionally, Bittensor introduces a speculation-based reward mechanism in the form of bonds (B), allowing</span>
<span class="sd">    neurons to accumulate bonds in other neurons, speculating on their future value. This mechanism aligns</span>
<span class="sd">    with market-based speculation, incentivizing neurons to make judicious decisions in their inter-neuronal</span>
<span class="sd">    investments.</span>

<span class="sd">    Example Usage::</span>

<span class="sd">        from bittensor.core.subtensor import Subtensor</span>

<span class="sd">        # Connect to the main Bittensor network (Finney).</span>
<span class="sd">        finney_subtensor = Subtensor(network=&#39;finney&#39;)</span>

<span class="sd">        # Close websocket connection with the Bittensor network.</span>
<span class="sd">        finney_subtensor.close()</span>

<span class="sd">        # Register a new neuron on the network.</span>
<span class="sd">        wallet = bittensor_wallet.Wallet(...)  # Assuming a wallet instance is created.</span>
<span class="sd">        netuid = 1</span>
<span class="sd">        success = finney_subtensor.register(wallet=wallet, netuid=netuid)</span>

<span class="sd">        # Set inter-neuronal weights for collaborative learning.</span>
<span class="sd">        success = finney_subtensor.set_weights(wallet=wallet, netuid=netuid, uids=[...], weights=[...])</span>

<span class="sd">        # Get the metagraph for a specific subnet using given subtensor connection</span>
<span class="sd">        metagraph = finney_subtensor.metagraph(netuid=netuid)</span>

<span class="sd">    By facilitating these operations, the Subtensor class is instrumental in maintaining the decentralized</span>
<span class="sd">    intelligence and dynamic learning environment of the Bittensor network, as envisioned in its foundational</span>
<span class="sd">    principles and mechanisms described in the `NeurIPS paper</span>
<span class="sd">    &lt;https://bittensor.com/pdfs/academia/NeurIPS_DAO_Workshop_2022_3_3.pdf&gt;`_. paper.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">network</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">config</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;Config&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">_mock</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">log_verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">connection_timeout</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">600</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes a Subtensor interface for interacting with the Bittensor blockchain.</span>

<span class="sd">        NOTE:</span>
<span class="sd">            Currently subtensor defaults to the ``finney`` network. This will change in a future release.</span>

<span class="sd">        We strongly encourage users to run their own local subtensor node whenever possible. This increases decentralization and resilience of the network. In a future release, local subtensor will become the default and the fallback to ``finney`` removed. Please plan ahead for this change. We will provide detailed instructions on how to run a local subtensor node in the documentation in a subsequent release.</span>

<span class="sd">        Args:</span>
<span class="sd">            network (Optional[str]): The network name to connect to (e.g., ``finney``, ``local``). This can also be the chain endpoint (e.g., ``wss://entrypoint-finney.opentensor.ai:443``) and will be correctly parsed into the network and chain endpoint. If not specified, defaults to the main Bittensor network.</span>
<span class="sd">            config (Optional[bittensor.core.config.Config]): Configuration object for the subtensor. If not provided, a default configuration is used.</span>
<span class="sd">            _mock (bool): If set to ``True``, uses a mocked connection for testing purposes. Default is ``False``.</span>
<span class="sd">            log_verbose (bool): Whether to enable verbose logging. If set to ``True``, detailed log information about the connection and network operations will be provided. Default is ``True``.</span>
<span class="sd">            connection_timeout (int): The maximum time in seconds to keep the connection alive. Default is ``600``.</span>

<span class="sd">        This initialization sets up the connection to the specified Bittensor network, allowing for various blockchain operations such as neuron registration, stake management, and setting weights.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Determine config.subtensor.chain_endpoint and config.subtensor.network config.</span>
        <span class="c1"># If chain_endpoint is set, we override the network flag, otherwise, the chain_endpoint is assigned by the</span>
        <span class="c1"># network.</span>
        <span class="c1"># Argument importance: network &gt; chain_endpoint &gt; config.subtensor.chain_endpoint &gt; config.subtensor.network</span>

        <span class="k">if</span> <span class="n">config</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">config</span> <span class="o">=</span> <span class="n">Subtensor</span><span class="o">.</span><span class="n">config</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_config</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>

        <span class="c1"># Setup config.subtensor.network and config.subtensor.chain_endpoint</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chain_endpoint</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span> <span class="o">=</span> <span class="n">Subtensor</span><span class="o">.</span><span class="n">setup_config</span><span class="p">(</span>
            <span class="n">network</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_config</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">network</span> <span class="o">==</span> <span class="s2">&quot;finney&quot;</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">chain_endpoint</span> <span class="o">==</span> <span class="n">settings</span><span class="o">.</span><span class="n">FINNEY_ENTRYPOINT</span>
        <span class="p">)</span> <span class="ow">and</span> <span class="n">log_verbose</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;You are connecting to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="si">}</span><span class="s2"> network with endpoint </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_endpoint</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;We strongly encourage running a local subtensor node whenever possible. &quot;</span>
                <span class="s2">&quot;This increases decentralization and resilience of the network.&quot;</span>
            <span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;In a future release, local subtensor will become the default endpoint. &quot;</span>
                <span class="s2">&quot;To get ahead of this change, please run a local subtensor node and point to it.&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log_verbose</span> <span class="o">=</span> <span class="n">log_verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_connection_timeout</span> <span class="o">=</span> <span class="n">connection_timeout</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="p">:</span> <span class="s2">&quot;SubstrateInterface&quot;</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_get_substrate</span><span class="p">()</span>

<div class="viewcode-block" id="Subtensor.__str__">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.__str__">[docs]</a>
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">chain_endpoint</span><span class="p">:</span>
            <span class="c1"># Connecting to chain endpoint without network known.</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;subtensor(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_endpoint</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Connecting to network with endpoint known.</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;subtensor(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_endpoint</span><span class="si">}</span><span class="s2">)&quot;</span></div>


<div class="viewcode-block" id="Subtensor.__repr__">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.__repr__">[docs]</a>
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span></div>


<div class="viewcode-block" id="Subtensor.close">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.close">[docs]</a>
    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Cleans up resources for this subtensor instance like active websocket connection and active extensions.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>


<div class="viewcode-block" id="Subtensor._get_substrate">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor._get_substrate">[docs]</a>
    <span class="k">def</span> <span class="nf">_get_substrate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Establishes a connection to the Substrate node using configured parameters.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Set up params.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span> <span class="o">=</span> <span class="n">SubstrateInterface</span><span class="p">(</span>
                <span class="n">ss58_format</span><span class="o">=</span><span class="n">settings</span><span class="o">.</span><span class="n">SS58_FORMAT</span><span class="p">,</span>
                <span class="n">use_remote_preset</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">url</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_endpoint</span><span class="p">,</span>
                <span class="n">type_registry</span><span class="o">=</span><span class="n">settings</span><span class="o">.</span><span class="n">TYPE_REGISTRY</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_verbose</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Connected to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="si">}</span><span class="s2"> network and </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_endpoint</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">websocket</span><span class="o">.</span><span class="n">settimeout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_connection_timeout</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="ne">OSError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error setting timeout: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">except</span> <span class="p">(</span><span class="ne">ConnectionRefusedError</span><span class="p">,</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLError</span><span class="p">)</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Could not connect to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="si">}</span><span class="s2"> network with </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_endpoint</span><span class="si">}</span><span class="s2"> chain endpoint.&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;You can check if you have connectivity by running this command: nc -vz localhost &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_endpoint</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ConnectionRefusedError</span><span class="p">(</span><span class="n">error</span><span class="o">.</span><span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.config">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.config">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">config</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="s2">&quot;Config&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates and returns a Bittensor configuration object.</span>

<span class="sd">        Returns:</span>
<span class="sd">            config (bittensor.core.config.Config): A Bittensor configuration object configured with arguments added by the `subtensor.add_args` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
        <span class="n">Subtensor</span><span class="o">.</span><span class="n">add_args</span><span class="p">(</span><span class="n">parser</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Config</span><span class="p">(</span><span class="n">parser</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">[])</span></div>


<div class="viewcode-block" id="Subtensor.setup_config">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.setup_config">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">setup_config</span><span class="p">(</span><span class="n">network</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">config</span><span class="p">:</span> <span class="s2">&quot;Config&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets up and returns the configuration for the Subtensor network and endpoint.</span>

<span class="sd">        This method determines the appropriate network and chain endpoint based on the provided network string or</span>
<span class="sd">        configuration object. It evaluates the network and endpoint in the following order of precedence:</span>
<span class="sd">        1. Provided network string.</span>
<span class="sd">        2. Configured chain endpoint in the `config` object.</span>
<span class="sd">        3. Configured network in the `config` object.</span>
<span class="sd">        4. Default chain endpoint.</span>
<span class="sd">        5. Default network.</span>

<span class="sd">        Args:</span>
<span class="sd">            network (Optional[str]): The name of the Subtensor network. If None, the network and endpoint will be determined from the `config` object.</span>
<span class="sd">            config (bittensor.core.config.Config): The configuration object containing the network and chain endpoint settings.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple: A tuple containing the formatted WebSocket endpoint URL and the evaluated network name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">network</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="p">(</span>
                <span class="n">evaluated_network</span><span class="p">,</span>
                <span class="n">evaluated_endpoint</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">=</span> <span class="n">Subtensor</span><span class="o">.</span><span class="n">determine_chain_endpoint_and_network</span><span class="p">(</span><span class="n">network</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">is_set</span><span class="p">(</span><span class="s2">&quot;subtensor.chain_endpoint&quot;</span><span class="p">):</span>
                <span class="p">(</span>
                    <span class="n">evaluated_network</span><span class="p">,</span>
                    <span class="n">evaluated_endpoint</span><span class="p">,</span>
                <span class="p">)</span> <span class="o">=</span> <span class="n">Subtensor</span><span class="o">.</span><span class="n">determine_chain_endpoint_and_network</span><span class="p">(</span>
                    <span class="n">config</span><span class="o">.</span><span class="n">subtensor</span><span class="o">.</span><span class="n">chain_endpoint</span>
                <span class="p">)</span>

            <span class="k">elif</span> <span class="n">config</span><span class="o">.</span><span class="n">is_set</span><span class="p">(</span><span class="s2">&quot;subtensor.network&quot;</span><span class="p">):</span>
                <span class="p">(</span>
                    <span class="n">evaluated_network</span><span class="p">,</span>
                    <span class="n">evaluated_endpoint</span><span class="p">,</span>
                <span class="p">)</span> <span class="o">=</span> <span class="n">Subtensor</span><span class="o">.</span><span class="n">determine_chain_endpoint_and_network</span><span class="p">(</span>
                    <span class="n">config</span><span class="o">.</span><span class="n">subtensor</span><span class="o">.</span><span class="n">network</span>
                <span class="p">)</span>

            <span class="k">elif</span> <span class="n">config</span><span class="o">.</span><span class="n">subtensor</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;chain_endpoint&quot;</span><span class="p">):</span>
                <span class="p">(</span>
                    <span class="n">evaluated_network</span><span class="p">,</span>
                    <span class="n">evaluated_endpoint</span><span class="p">,</span>
                <span class="p">)</span> <span class="o">=</span> <span class="n">Subtensor</span><span class="o">.</span><span class="n">determine_chain_endpoint_and_network</span><span class="p">(</span>
                    <span class="n">config</span><span class="o">.</span><span class="n">subtensor</span><span class="o">.</span><span class="n">chain_endpoint</span>
                <span class="p">)</span>

            <span class="k">elif</span> <span class="n">config</span><span class="o">.</span><span class="n">subtensor</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;network&quot;</span><span class="p">):</span>
                <span class="p">(</span>
                    <span class="n">evaluated_network</span><span class="p">,</span>
                    <span class="n">evaluated_endpoint</span><span class="p">,</span>
                <span class="p">)</span> <span class="o">=</span> <span class="n">Subtensor</span><span class="o">.</span><span class="n">determine_chain_endpoint_and_network</span><span class="p">(</span>
                    <span class="n">config</span><span class="o">.</span><span class="n">subtensor</span><span class="o">.</span><span class="n">network</span>
                <span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="p">(</span>
                    <span class="n">evaluated_network</span><span class="p">,</span>
                    <span class="n">evaluated_endpoint</span><span class="p">,</span>
                <span class="p">)</span> <span class="o">=</span> <span class="n">Subtensor</span><span class="o">.</span><span class="n">determine_chain_endpoint_and_network</span><span class="p">(</span>
                    <span class="n">settings</span><span class="o">.</span><span class="n">DEFAULTS</span><span class="o">.</span><span class="n">subtensor</span><span class="o">.</span><span class="n">network</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">networking</span><span class="o">.</span><span class="n">get_formatted_ws_endpoint_url</span><span class="p">(</span><span class="n">evaluated_endpoint</span><span class="p">),</span>
            <span class="n">evaluated_network</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.help">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.help">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">help</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Print help to stdout.&quot;&quot;&quot;</span>
        <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">add_args</span><span class="p">(</span><span class="n">parser</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="fm">__new__</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
        <span class="n">parser</span><span class="o">.</span><span class="n">print_help</span><span class="p">()</span></div>


<div class="viewcode-block" id="Subtensor.add_args">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.add_args">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">add_args</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">parser</span><span class="p">:</span> <span class="s2">&quot;argparse.ArgumentParser&quot;</span><span class="p">,</span> <span class="n">prefix</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds command-line arguments to the provided ArgumentParser for configuring the Subtensor settings.</span>

<span class="sd">        Args:</span>
<span class="sd">            parser (argparse.ArgumentParser): The ArgumentParser object to which the Subtensor arguments will be added.</span>
<span class="sd">            prefix (Optional[str]): An optional prefix for the argument names. If provided, the prefix is prepended to each argument name.</span>

<span class="sd">        Arguments added:</span>
<span class="sd">            --subtensor.network: The Subtensor network flag. Possible values are &#39;finney&#39;, &#39;test&#39;, &#39;archive&#39;, and &#39;local&#39;. Overrides the chain endpoint if set.</span>
<span class="sd">            --subtensor.chain_endpoint: The Subtensor chain endpoint flag. If set, it overrides the network flag.</span>
<span class="sd">            --subtensor._mock: If true, uses a mocked connection to the chain.</span>

<span class="sd">        Example:</span>
<span class="sd">            parser = argparse.ArgumentParser()</span>
<span class="sd">            Subtensor.add_args(parser)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">prefix_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="n">prefix</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">default_network</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">DEFAULT_NETWORK</span>
            <span class="n">default_chain_endpoint</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">FINNEY_ENTRYPOINT</span>

            <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;--</span><span class="si">{</span><span class="n">prefix_str</span><span class="si">}</span><span class="s2">subtensor.network&quot;</span><span class="p">,</span>
                <span class="n">default</span><span class="o">=</span><span class="n">default_network</span><span class="p">,</span>
                <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
                <span class="n">help</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;The subtensor network flag. The likely choices are:</span>
<span class="s2">                                        -- finney (main network)</span>
<span class="s2">                                        -- test (test network)</span>
<span class="s2">                                        -- archive (archive network +300 blocks)</span>
<span class="s2">                                        -- local (local running network)</span>
<span class="s2">                                    If this option is set it overloads subtensor.chain_endpoint with</span>
<span class="s2">                                    an entry point node from that network.</span>
<span class="s2">                                    &quot;&quot;&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;--</span><span class="si">{</span><span class="n">prefix_str</span><span class="si">}</span><span class="s2">subtensor.chain_endpoint&quot;</span><span class="p">,</span>
                <span class="n">default</span><span class="o">=</span><span class="n">default_chain_endpoint</span><span class="p">,</span>
                <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
                <span class="n">help</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;The subtensor endpoint flag. If set, overrides the --network flag.&quot;&quot;&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;--</span><span class="si">{</span><span class="n">prefix_str</span><span class="si">}</span><span class="s2">subtensor._mock&quot;</span><span class="p">,</span>
                <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="nb">type</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span>
                <span class="n">help</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;If true, uses a mocked connection to the chain.&quot;&quot;&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">except</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">:</span>
            <span class="c1"># re-parsing arguments.</span>
            <span class="k">pass</span></div>


    <span class="c1"># Inner private functions</span>
<div class="viewcode-block" id="Subtensor._encode_params">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor._encode_params">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">_encode_params</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">call_definition</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="s2">&quot;ParamWithTypes&quot;</span><span class="p">],</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a hex encoded string of the params using their types.&quot;&quot;&quot;</span>
        <span class="n">param_data</span> <span class="o">=</span> <span class="n">scalecodec</span><span class="o">.</span><span class="n">ScaleBytes</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">call_definition</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">]):</span>  <span class="c1"># type: ignore</span>
            <span class="n">scale_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">create_scale_object</span><span class="p">(</span><span class="n">param</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
                <span class="n">param_data</span> <span class="o">+=</span> <span class="n">scale_obj</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">param</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Missing param </span><span class="si">{</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> in params dict.&quot;</span><span class="p">)</span>

                <span class="n">param_data</span> <span class="o">+=</span> <span class="n">scale_obj</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">param</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]])</span>

        <span class="k">return</span> <span class="n">param_data</span><span class="o">.</span><span class="n">to_hex</span><span class="p">()</span></div>


<div class="viewcode-block" id="Subtensor._get_hyperparameter">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor._get_hyperparameter">[docs]</a>
    <span class="k">def</span> <span class="nf">_get_hyperparameter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">param_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a specified hyperparameter for a specific subnet.</span>

<span class="sd">        Args:</span>
<span class="sd">            param_name (str): The name of the hyperparameter to retrieve.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[Union[int, float]]: The value of the specified hyperparameter if the subnet exists, ``None`` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">subnet_exists</span><span class="p">(</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_subtensor</span><span class="p">(</span><span class="n">param_name</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="p">[</span><span class="n">netuid</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">value</span></div>


    <span class="c1"># Calls methods</span>
<div class="viewcode-block" id="Subtensor.query_subtensor">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.query_subtensor">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">query_subtensor</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ScaleType&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Queries named storage from the Subtensor module on the Bittensor blockchain. This function is used to retrieve specific data or parameters from the blockchain, such as stake, rank, or other neuron-specific attributes.</span>

<span class="sd">        Args:</span>
<span class="sd">            name (str): The name of the storage function to query.</span>
<span class="sd">            block (Optional[int]): The blockchain block number at which to perform the query.</span>
<span class="sd">            params (Optional[list[object]]): A list of parameters to pass to the query function.</span>

<span class="sd">        Returns:</span>
<span class="sd">            query_response (scalecodec.ScaleType): An object containing the requested data.</span>

<span class="sd">        This query function is essential for accessing detailed information about the network and its neurons, providing valuable insights into the state and dynamics of the Bittensor ecosystem.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">logging</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="s2">&quot;ScaleType&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
                <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
                <span class="n">storage_function</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
                <span class="n">block_hash</span><span class="o">=</span><span class="p">(</span>
                    <span class="kc">None</span> <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
                <span class="p">),</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span></div>


<div class="viewcode-block" id="Subtensor.query_map_subtensor">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.query_map_subtensor">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">query_map_subtensor</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;QueryMapResult&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Queries map storage from the Subtensor module on the Bittensor blockchain. This function is designed to retrieve a map-like data structure, which can include various neuron-specific details or network-wide attributes.</span>

<span class="sd">        Args:</span>
<span class="sd">            name (str): The name of the map storage function to query.</span>
<span class="sd">            block (Optional[int]): The blockchain block number at which to perform the query.</span>
<span class="sd">            params (Optional[list[object]]): A list of parameters to pass to the query function.</span>

<span class="sd">        Returns:</span>
<span class="sd">            QueryMapResult (substrateinterface.base.QueryMapResult): An object containing the map-like data structure, or ``None`` if not found.</span>

<span class="sd">        This function is particularly useful for analyzing and understanding complex network structures and relationships within the Bittensor ecosystem, such as inter-neuronal connections and stake distributions.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">logging</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query_map</span><span class="p">(</span>
                <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
                <span class="n">storage_function</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
                <span class="n">block_hash</span><span class="o">=</span><span class="p">(</span>
                    <span class="kc">None</span> <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
                <span class="p">),</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span></div>


<div class="viewcode-block" id="Subtensor.query_runtime_api">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.query_runtime_api">[docs]</a>
    <span class="k">def</span> <span class="nf">query_runtime_api</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">runtime_api</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]],</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Queries the runtime API of the Bittensor blockchain, providing a way to interact with the underlying runtime and retrieve data encoded in Scale Bytes format. This function is essential for advanced users who need to interact with specific runtime methods and decode complex data types.</span>

<span class="sd">        Args:</span>
<span class="sd">            runtime_api (str): The name of the runtime API to query.</span>
<span class="sd">            method (str): The specific method within the runtime API to call.</span>
<span class="sd">            params (Optional[list[ParamWithTypes]]): The parameters to pass to the method call.</span>
<span class="sd">            block (Optional[int]): The blockchain block number at which to perform the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[str]: The Scale Bytes encoded result from the runtime API call, or ``None`` if the call fails.</span>

<span class="sd">        This function enables access to the deeper layers of the Bittensor blockchain, allowing for detailed and specific interactions with the network&#39;s runtime environment.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call_definition</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">TYPE_REGISTRY</span><span class="p">[</span><span class="s2">&quot;runtime_api&quot;</span><span class="p">][</span><span class="n">runtime_api</span><span class="p">][</span><span class="s2">&quot;methods&quot;</span><span class="p">][</span>
            <span class="n">method</span>
        <span class="p">]</span>

        <span class="n">json_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_call</span><span class="p">(</span>
            <span class="n">method</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">runtime_api</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;0x&quot;</span>
                <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encode_params</span><span class="p">(</span><span class="n">call_definition</span><span class="o">=</span><span class="n">call_definition</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
            <span class="p">),</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">json_result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">return_type</span> <span class="o">=</span> <span class="n">call_definition</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span>

        <span class="n">as_scale_bytes</span> <span class="o">=</span> <span class="n">scalecodec</span><span class="o">.</span><span class="n">ScaleBytes</span><span class="p">(</span><span class="n">json_result</span><span class="p">[</span><span class="s2">&quot;result&quot;</span><span class="p">])</span>

        <span class="n">rpc_runtime_config</span> <span class="o">=</span> <span class="n">RuntimeConfiguration</span><span class="p">()</span>
        <span class="n">rpc_runtime_config</span><span class="o">.</span><span class="n">update_type_registry</span><span class="p">(</span><span class="n">load_type_registry_preset</span><span class="p">(</span><span class="s2">&quot;legacy&quot;</span><span class="p">))</span>
        <span class="n">rpc_runtime_config</span><span class="o">.</span><span class="n">update_type_registry</span><span class="p">(</span><span class="n">custom_rpc_type_registry</span><span class="p">)</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="n">rpc_runtime_config</span><span class="o">.</span><span class="n">create_scale_object</span><span class="p">(</span><span class="n">return_type</span><span class="p">,</span> <span class="n">as_scale_bytes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">to_hex</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;0x0400&quot;</span><span class="p">:</span>  <span class="c1"># RPC returned None result</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span></div>


<div class="viewcode-block" id="Subtensor.state_call">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.state_call">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">state_call</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes a state call to the Bittensor blockchain, allowing for direct queries of the blockchain&#39;s state. This function is typically used for advanced queries that require specific method calls and data inputs.</span>

<span class="sd">        Args:</span>
<span class="sd">            method (str): The method name for the state call.</span>
<span class="sd">            data (str): The data to be passed to the method.</span>
<span class="sd">            block (Optional[int]): The blockchain block number at which to perform the state call.</span>

<span class="sd">        Returns:</span>
<span class="sd">            result (dict[Any, Any]): The result of the rpc call.</span>

<span class="sd">        The state call function provides a more direct and flexible way of querying blockchain data, useful for specific use cases where standard queries are insufficient.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">logging</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
            <span class="n">block_hash</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">rpc_request</span><span class="p">(</span>
                <span class="n">method</span><span class="o">=</span><span class="s2">&quot;state_call&quot;</span><span class="p">,</span>
                <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">method</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">block_hash</span><span class="p">]</span> <span class="k">if</span> <span class="n">block_hash</span> <span class="k">else</span> <span class="p">[</span><span class="n">method</span><span class="p">,</span> <span class="n">data</span><span class="p">],</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span></div>


<div class="viewcode-block" id="Subtensor.query_map">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.query_map">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">query_map</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">module</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;QueryMapResult&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Queries map storage from any module on the Bittensor blockchain. This function retrieves data structures that represent key-value mappings, essential for accessing complex and structured data within the blockchain modules.</span>

<span class="sd">        Args:</span>
<span class="sd">            module (str): The name of the module from which to query the map storage.</span>
<span class="sd">            name (str): The specific storage function within the module to query.</span>
<span class="sd">            block (Optional[int]): The blockchain block number at which to perform the query.</span>
<span class="sd">            params (Optional[list[object]]): Parameters to be passed to the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            result (substrateinterface.base.QueryMapResult): A data structure representing the map storage if found, ``None`` otherwise.</span>

<span class="sd">        This function is particularly useful for retrieving detailed and structured data from various blockchain modules, offering insights into the network&#39;s state and the relationships between its different components.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">logging</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="s2">&quot;QueryMapResult&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query_map</span><span class="p">(</span>
                <span class="n">module</span><span class="o">=</span><span class="n">module</span><span class="p">,</span>
                <span class="n">storage_function</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
                <span class="n">block_hash</span><span class="o">=</span><span class="p">(</span>
                    <span class="kc">None</span> <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
                <span class="p">),</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span></div>


<div class="viewcode-block" id="Subtensor.query_constant">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.query_constant">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">query_constant</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">module_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">constant_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;ScaleType&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a constant from the specified module on the Bittensor blockchain. This function is used to access fixed parameters or values defined within the blockchain&#39;s modules, which are essential for understanding the network&#39;s configuration and rules.</span>

<span class="sd">        Args:</span>
<span class="sd">            module_name (str): The name of the module containing the constant.</span>
<span class="sd">            constant_name (str): The name of the constant to retrieve.</span>
<span class="sd">            block (Optional[int]): The blockchain block number at which to query the constant.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[scalecodec.ScaleType]: The value of the constant if found, ``None`` otherwise.</span>

<span class="sd">        Constants queried through this function can include critical network parameters such as inflation rates, consensus rules, or validation thresholds, providing a deeper understanding of the Bittensor network&#39;s operational parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">logging</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_constant</span><span class="p">(</span>
                <span class="n">module_name</span><span class="o">=</span><span class="n">module_name</span><span class="p">,</span>
                <span class="n">constant_name</span><span class="o">=</span><span class="n">constant_name</span><span class="p">,</span>
                <span class="n">block_hash</span><span class="o">=</span><span class="p">(</span>
                    <span class="kc">None</span> <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
                <span class="p">),</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span></div>


<div class="viewcode-block" id="Subtensor.query_module">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.query_module">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">query_module</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">module</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ScaleType&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Queries any module storage on the Bittensor blockchain with the specified parameters and block number. This function is a generic query interface that allows for flexible and diverse data retrieval from various blockchain modules.</span>

<span class="sd">        Args:</span>
<span class="sd">            module (str): The name of the module from which to query data.</span>
<span class="sd">            name (str): The name of the storage function within the module.</span>
<span class="sd">            block (Optional[int]): The blockchain block number at which to perform the query.</span>
<span class="sd">            params (Optional[list[object]]): A list of parameters to pass to the query function.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[scalecodec.ScaleType]: An object containing the requested data if found, ``None`` otherwise.</span>

<span class="sd">        This versatile query function is key to accessing a wide range of data and insights from different parts of the Bittensor blockchain, enhancing the understanding and analysis of the network&#39;s state and dynamics.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">logging</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="s2">&quot;ScaleType&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
                <span class="n">module</span><span class="o">=</span><span class="n">module</span><span class="p">,</span>
                <span class="n">storage_function</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
                <span class="n">block_hash</span><span class="o">=</span><span class="p">(</span>
                    <span class="kc">None</span> <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
                <span class="p">),</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span></div>


    <span class="c1"># Common subtensor methods</span>
<div class="viewcode-block" id="Subtensor.metagraph">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.metagraph">[docs]</a>
    <span class="k">def</span> <span class="nf">metagraph</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">lite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Metagraph&quot;</span><span class="p">:</span>  <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a synced metagraph for a specified subnet within the Bittensor network. The metagraph represents the network&#39;s structure, including neuron connections and interactions.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The network UID of the subnet to query.</span>
<span class="sd">            lite (bool): If true, returns a metagraph using a lightweight sync (no weights, no bonds). Default is ``True``.</span>
<span class="sd">            block (Optional[int]): Block number for synchronization, or ``None`` for the latest block.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bittensor.core.metagraph.Metagraph: The metagraph representing the subnet&#39;s structure and neuron relationships.</span>

<span class="sd">        The metagraph is an essential tool for understanding the topology and dynamics of the Bittensor network&#39;s decentralized architecture, particularly in relation to neuron interconnectivity and consensus processes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">metagraph</span> <span class="o">=</span> <span class="n">Metagraph</span><span class="p">(</span>
            <span class="n">network</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">lite</span><span class="o">=</span><span class="n">lite</span><span class="p">,</span> <span class="n">sync</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>
        <span class="n">metagraph</span><span class="o">.</span><span class="n">sync</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span> <span class="n">lite</span><span class="o">=</span><span class="n">lite</span><span class="p">,</span> <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">metagraph</span></div>


<div class="viewcode-block" id="Subtensor.determine_chain_endpoint_and_network">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.determine_chain_endpoint_and_network">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">determine_chain_endpoint_and_network</span><span class="p">(</span>
        <span class="n">network</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Determines the chain endpoint and network from the passed network or chain_endpoint.</span>

<span class="sd">        Args:</span>
<span class="sd">            network (str): The network flag. The choices are: ``finney`` (main network), ``archive`` (archive network +300 blocks), ``local`` (local running network), ``test`` (test network).</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[Optional[str], Optional[str]]: The network and chain endpoint flag. If passed, overrides the ``network`` argument.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">network</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">network</span> <span class="ow">in</span> <span class="n">settings</span><span class="o">.</span><span class="n">NETWORKS</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">network</span><span class="p">,</span> <span class="n">settings</span><span class="o">.</span><span class="n">NETWORK_MAP</span><span class="p">[</span><span class="n">network</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">network</span> <span class="o">==</span> <span class="n">settings</span><span class="o">.</span><span class="n">FINNEY_ENTRYPOINT</span>
                <span class="ow">or</span> <span class="s2">&quot;entrypoint-finney.opentensor.ai&quot;</span> <span class="ow">in</span> <span class="n">network</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="s2">&quot;finney&quot;</span><span class="p">,</span> <span class="n">settings</span><span class="o">.</span><span class="n">FINNEY_ENTRYPOINT</span>
            <span class="k">elif</span> <span class="p">(</span>
                <span class="n">network</span> <span class="o">==</span> <span class="n">settings</span><span class="o">.</span><span class="n">FINNEY_TEST_ENTRYPOINT</span>
                <span class="ow">or</span> <span class="s2">&quot;test.finney.opentensor.ai&quot;</span> <span class="ow">in</span> <span class="n">network</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="s2">&quot;test&quot;</span><span class="p">,</span> <span class="n">settings</span><span class="o">.</span><span class="n">FINNEY_TEST_ENTRYPOINT</span>
            <span class="k">elif</span> <span class="p">(</span>
                <span class="n">network</span> <span class="o">==</span> <span class="n">settings</span><span class="o">.</span><span class="n">ARCHIVE_ENTRYPOINT</span>
                <span class="ow">or</span> <span class="s2">&quot;archive.chain.opentensor.ai&quot;</span> <span class="ow">in</span> <span class="n">network</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="s2">&quot;archive&quot;</span><span class="p">,</span> <span class="n">settings</span><span class="o">.</span><span class="n">ARCHIVE_ENTRYPOINT</span>
            <span class="k">elif</span> <span class="s2">&quot;127.0.0.1&quot;</span> <span class="ow">in</span> <span class="n">network</span> <span class="ow">or</span> <span class="s2">&quot;localhost&quot;</span> <span class="ow">in</span> <span class="n">network</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;local&quot;</span><span class="p">,</span> <span class="n">network</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;unknown&quot;</span><span class="p">,</span> <span class="n">network</span></div>


<div class="viewcode-block" id="Subtensor.get_netuids_for_hotkey">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.get_netuids_for_hotkey">[docs]</a>
    <span class="k">def</span> <span class="nf">get_netuids_for_hotkey</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a list of subnet UIDs (netuids) for which a given hotkey is a member. This function identifies the specific subnets within the Bittensor network where the neuron associated with the hotkey is active.</span>

<span class="sd">        Args:</span>
<span class="sd">            hotkey_ss58 (str): The ``SS58`` address of the neuron&#39;s hotkey.</span>
<span class="sd">            block (Optional[int]): The blockchain block number at which to perform the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[int]: A list of netuids where the neuron is a member.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_map_subtensor</span><span class="p">(</span><span class="s2">&quot;IsNetworkMember&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="p">[</span><span class="n">hotkey_ss58</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="p">[</span><span class="n">record</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">result</span> <span class="k">if</span> <span class="n">record</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">result</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;records&quot;</span><span class="p">)</span>
            <span class="k">else</span> <span class="p">[]</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_current_block">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.get_current_block">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">get_current_block</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the current block number on the Bittensor blockchain. This function provides the latest block number, indicating the most recent state of the blockchain.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: The current chain block number.</span>

<span class="sd">        Knowing the current block number is essential for querying real-time data and performing time-sensitive operations on the blockchain. It serves as a reference point for network activities and data synchronization.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">logging</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_block_number</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

        <span class="k">return</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span></div>


<div class="viewcode-block" id="Subtensor.is_hotkey_registered_any">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.is_hotkey_registered_any">[docs]</a>
    <span class="k">def</span> <span class="nf">is_hotkey_registered_any</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if a neuron&#39;s hotkey is registered on any subnet within the Bittensor network.</span>

<span class="sd">        Args:</span>
<span class="sd">            hotkey_ss58 (str): The ``SS58`` address of the neuron&#39;s hotkey.</span>
<span class="sd">            block (Optional[int]): The blockchain block number at which to perform the check.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the hotkey is registered on any subnet, False otherwise.</span>

<span class="sd">        This function is essential for determining the network-wide presence and participation of a neuron.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_netuids_for_hotkey</span><span class="p">(</span><span class="n">hotkey_ss58</span><span class="p">,</span> <span class="n">block</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="Subtensor.is_hotkey_registered_on_subnet">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.is_hotkey_registered_on_subnet">[docs]</a>
    <span class="k">def</span> <span class="nf">is_hotkey_registered_on_subnet</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if a neuron&#39;s hotkey is registered on a specific subnet within the Bittensor network.</span>

<span class="sd">        Args:</span>
<span class="sd">            hotkey_ss58 (str): The ``SS58`` address of the neuron&#39;s hotkey.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int]): The blockchain block number at which to perform the check.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the hotkey is registered on the specified subnet, False otherwise.</span>

<span class="sd">        This function helps in assessing the participation of a neuron in a particular subnet, indicating its specific area of operation or influence within the network.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_uid_for_hotkey_on_subnet</span><span class="p">(</span><span class="n">hotkey_ss58</span><span class="p">,</span> <span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Subtensor.is_hotkey_registered">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.is_hotkey_registered">[docs]</a>
    <span class="k">def</span> <span class="nf">is_hotkey_registered</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines whether a given hotkey (public key) is registered in the Bittensor network, either globally across any subnet or specifically on a specified subnet. This function checks the registration status of a neuron identified by its hotkey, which is crucial for validating its participation and activities within the network.</span>

<span class="sd">        Args:</span>
<span class="sd">            hotkey_ss58 (str): The SS58 address of the neuron&#39;s hotkey.</span>
<span class="sd">            netuid (Optional[int]): The unique identifier of the subnet to check the registration. If ``None``, the registration is checked across all subnets.</span>
<span class="sd">            block (Optional[int]): The blockchain block number at which to perform the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the hotkey is registered in the specified context (either any subnet or a specific subnet), ``False`` otherwise.</span>

<span class="sd">        This function is important for verifying the active status of neurons in the Bittensor network. It aids in understanding whether a neuron is eligible to participate in network processes such as consensus, validation, and incentive distribution based on its registration status.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">netuid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_hotkey_registered_any</span><span class="p">(</span><span class="n">hotkey_ss58</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_hotkey_registered_on_subnet</span><span class="p">(</span><span class="n">hotkey_ss58</span><span class="p">,</span> <span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span></div>


    <span class="c1"># Not used in Bittensor, but is actively used by the community in almost all subnets</span>
<div class="viewcode-block" id="Subtensor.set_weights">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.set_weights">[docs]</a>
    <span class="k">def</span> <span class="nf">set_weights</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">uids</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">],</span> <span class="s2">&quot;torch.LongTensor&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">],</span>
        <span class="n">weights</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">],</span> <span class="s2">&quot;torch.FloatTensor&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">],</span>
        <span class="n">version_key</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">version_as_int</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_retries</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the inter-neuronal weights for the specified neuron. This process involves specifying the influence or trust a neuron places on other neurons in the network, which is a fundamental aspect of Bittensor&#39;s decentralized learning architecture.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): The wallet associated with the neuron setting the weights.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            uids (Union[NDArray[np.int64], torch.LongTensor, list]): The list of neuron UIDs that the weights are being set for.</span>
<span class="sd">            weights (Union[NDArray[np.float32], torch.FloatTensor, list]): The corresponding weights to be set for each UID.</span>
<span class="sd">            version_key (int): Version key for compatibility with the network.  Default is ``int representation of Bittensor version.``.</span>
<span class="sd">            wait_for_inclusion (bool): Waits for the transaction to be included in a block. Default is ``False``.</span>
<span class="sd">            wait_for_finalization (bool): Waits for the transaction to be finalized on the blockchain. Default is ``False``.</span>
<span class="sd">            max_retries (int): The number of maximum attempts to set weights. Default is ``5``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[bool, str]: ``True`` if the setting of weights is successful, False otherwise. And `msg`, a string value describing the success or potential error.</span>

<span class="sd">        This function is crucial in shaping the network&#39;s collective intelligence, where each neuron&#39;s learning and contribution are influenced by the weights it sets towards others【81†source】.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">uid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_uid_for_hotkey_on_subnet</span><span class="p">(</span><span class="n">wallet</span><span class="o">.</span><span class="n">hotkey</span><span class="o">.</span><span class="n">ss58_address</span><span class="p">,</span> <span class="n">netuid</span><span class="p">)</span>
        <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;No attempt made. Perhaps it is too soon to set weights!&quot;</span>
        <span class="k">while</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">blocks_since_last_update</span><span class="p">(</span><span class="n">netuid</span><span class="p">,</span> <span class="n">uid</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights_rate_limit</span><span class="p">(</span><span class="n">netuid</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
            <span class="ow">and</span> <span class="n">retries</span> <span class="o">&lt;</span> <span class="n">max_retries</span>
        <span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Setting weights for subnet #</span><span class="si">{</span><span class="n">netuid</span><span class="si">}</span><span class="s2">. Attempt </span><span class="si">{</span><span class="n">retries</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2"> of </span><span class="si">{</span><span class="n">max_retries</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
                <span class="n">success</span><span class="p">,</span> <span class="n">message</span> <span class="o">=</span> <span class="n">set_weights_extrinsic</span><span class="p">(</span>
                    <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
                    <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
                    <span class="n">uids</span><span class="o">=</span><span class="n">uids</span><span class="p">,</span>
                    <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span>
                    <span class="n">version_key</span><span class="o">=</span><span class="n">version_key</span><span class="p">,</span>
                    <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                    <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error setting weights: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="n">retries</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">success</span><span class="p">,</span> <span class="n">message</span></div>


<div class="viewcode-block" id="Subtensor.root_set_weights">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.root_set_weights">[docs]</a>
    <span class="nd">@legacy_torch_api_compat</span>
    <span class="k">def</span> <span class="nf">root_set_weights</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">netuids</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">],</span> <span class="s2">&quot;torch.LongTensor&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">],</span>
        <span class="n">weights</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">],</span> <span class="s2">&quot;torch.FloatTensor&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">],</span>
        <span class="n">version_key</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the weights for neurons on the root network. This action is crucial for defining the influence and interactions of neurons at the root level of the Bittensor network.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): The wallet associated with the neuron setting the weights.</span>
<span class="sd">            netuids (Union[NDArray[np.int64], torch.LongTensor, list]): The list of neuron UIDs for which weights are being set.</span>
<span class="sd">            weights (Union[NDArray[np.float32], torch.FloatTensor, list]): The corresponding weights to be set for each UID.</span>
<span class="sd">            version_key (int, optional): Version key for compatibility with the network. Default is ``0``.</span>
<span class="sd">            wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block. Defaults to ``False``.</span>
<span class="sd">            wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain. Defaults to ``False``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the setting of root-level weights is successful, False otherwise.</span>

<span class="sd">        This function plays a pivotal role in shaping the root network&#39;s collective intelligence and decision-making processes, reflecting the principles of decentralized governance and collaborative learning in Bittensor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">set_root_weights_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">netuids</span><span class="o">=</span><span class="n">netuids</span><span class="p">,</span>
            <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span>
            <span class="n">version_key</span><span class="o">=</span><span class="n">version_key</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.register">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.register">[docs]</a>
    <span class="k">def</span> <span class="nf">register</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">max_allowed_attempts</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
        <span class="n">output_in_place</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">cuda</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">dev_id</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">tpb</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">256</span><span class="p">,</span>
        <span class="n">num_processes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">update_interval</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">log_verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Registers a neuron on the Bittensor network using the provided wallet.</span>

<span class="sd">        Registration is a critical step for a neuron to become an active participant in the network, enabling it to stake, set weights, and receive incentives.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): The wallet associated with the neuron to be registered.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            wait_for_inclusion (bool): Waits for the transaction to be included in a block. Defaults to `False`.</span>
<span class="sd">            wait_for_finalization (bool): Waits for the transaction to be finalized on the blockchain. Defaults to `True`.</span>
<span class="sd">            max_allowed_attempts (int): Maximum number of attempts to register the wallet.</span>
<span class="sd">            output_in_place (bool): If true, prints the progress of the proof of work to the console in-place. Meaning the progress is printed on the same lines. Defaults to `True`.</span>
<span class="sd">            cuda (bool): If ``true``, the wallet should be registered using CUDA device(s). Defaults to `False`.</span>
<span class="sd">            dev_id (Union[List[int], int]): The CUDA device id to use, or a list of device ids. Defaults to `0` (zero).</span>
<span class="sd">            tpb (int): The number of threads per block (CUDA). Default to `256`.</span>
<span class="sd">            num_processes (Optional[int]): The number of processes to use to register. Default to `None`.</span>
<span class="sd">            update_interval (Optional[int]): The number of nonces to solve between updates.  Default to `None`.</span>
<span class="sd">            log_verbose (bool): If ``true``, the registration process will log more information.  Default to `False`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the registration is successful, False otherwise.</span>

<span class="sd">        This function facilitates the entry of new neurons into the network, supporting the decentralized</span>
<span class="sd">        growth and scalability of the Bittensor ecosystem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">register_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">max_allowed_attempts</span><span class="o">=</span><span class="n">max_allowed_attempts</span><span class="p">,</span>
            <span class="n">output_in_place</span><span class="o">=</span><span class="n">output_in_place</span><span class="p">,</span>
            <span class="n">cuda</span><span class="o">=</span><span class="n">cuda</span><span class="p">,</span>
            <span class="n">dev_id</span><span class="o">=</span><span class="n">dev_id</span><span class="p">,</span>
            <span class="n">tpb</span><span class="o">=</span><span class="n">tpb</span><span class="p">,</span>
            <span class="n">num_processes</span><span class="o">=</span><span class="n">num_processes</span><span class="p">,</span>
            <span class="n">update_interval</span><span class="o">=</span><span class="n">update_interval</span><span class="p">,</span>
            <span class="n">log_verbose</span><span class="o">=</span><span class="n">log_verbose</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.root_register">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.root_register">[docs]</a>
    <span class="k">def</span> <span class="nf">root_register</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Registers the neuron associated with the wallet on the root network. This process is integral for participating in the highest layer of decision-making and governance within the Bittensor network.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet associated with the neuron to be registered on the root network.</span>
<span class="sd">            wait_for_inclusion (bool): Waits for the transaction to be included in a block. Defaults to `False`.</span>
<span class="sd">            wait_for_finalization (bool): Waits for the transaction to be finalized on the blockchain. Defaults to `True`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the registration on the root network is successful, False otherwise.</span>

<span class="sd">        This function enables neurons to engage in the most critical and influential aspects of the network&#39;s governance, signifying a high level of commitment and responsibility in the Bittensor ecosystem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">root_register_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.burned_register">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.burned_register">[docs]</a>
    <span class="k">def</span> <span class="nf">burned_register</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Registers a neuron on the Bittensor network by recycling TAO. This method of registration involves recycling TAO tokens, allowing them to be re-mined by performing work on the network.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): The wallet associated with the neuron to be registered.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block. Defaults to `False`.</span>
<span class="sd">            wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain. Defaults to `True`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the registration is successful, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">burned_register_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.serve_axon">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.serve_axon">[docs]</a>
    <span class="k">def</span> <span class="nf">serve_axon</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">axon</span><span class="p">:</span> <span class="s2">&quot;Axon&quot;</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Registers an ``Axon`` serving endpoint on the Bittensor network for a specific neuron. This function is used to set up the Axon, a key component of a neuron that handles incoming queries and data processing tasks.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            axon (bittensor.core.axon.Axon): The Axon instance to be registered for serving.</span>
<span class="sd">            wait_for_inclusion (bool): Waits for the transaction to be included in a block. Default is ``False``.</span>
<span class="sd">            wait_for_finalization (bool): Waits for the transaction to be finalized on the blockchain. Default is ``True``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the Axon serve registration is successful, False otherwise.</span>

<span class="sd">        By registering an Axon, the neuron becomes an active part of the network&#39;s distributed computing infrastructure, contributing to the collective intelligence of Bittensor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">serve_axon_extrinsic</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">,</span> <span class="n">axon</span><span class="p">,</span> <span class="n">wait_for_inclusion</span><span class="p">,</span> <span class="n">wait_for_finalization</span>
        <span class="p">)</span></div>


    <span class="c1"># metagraph</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">block</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns current chain block.</span>

<span class="sd">        Returns:</span>
<span class="sd">            block (int): Current chain block.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_current_block</span><span class="p">()</span>

<div class="viewcode-block" id="Subtensor.blocks_since_last_update">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.blocks_since_last_update">[docs]</a>
    <span class="k">def</span> <span class="nf">blocks_since_last_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">uid</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of blocks since the last update for a specific UID in the subnetwork.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            uid (int): The unique identifier of the neuron.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The number of blocks since the last update, or ``None`` if the subnetwork or UID does not exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hyperparameter</span><span class="p">(</span><span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;LastUpdate&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_current_block</span><span class="p">()</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">[</span><span class="n">uid</span><span class="p">])</span></div>


<div class="viewcode-block" id="Subtensor.get_block_hash">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.get_block_hash">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">get_block_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the hash of a specific block on the Bittensor blockchain. The block hash is a unique identifier representing the cryptographic hash of the block&#39;s content, ensuring its integrity and immutability.</span>

<span class="sd">        Args:</span>
<span class="sd">            block_id (int): The block number for which the hash is to be retrieved.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: The cryptographic hash of the specified block.</span>

<span class="sd">        The block hash is a fundamental aspect of blockchain technology, providing a secure reference to each block&#39;s data. It is crucial for verifying transactions, ensuring data consistency, and maintaining the trustworthiness of the blockchain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_block_hash</span><span class="p">(</span><span class="n">block_id</span><span class="o">=</span><span class="n">block_id</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.weights_rate_limit">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.weights_rate_limit">[docs]</a>
    <span class="k">def</span> <span class="nf">weights_rate_limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns network WeightsSetRateLimit hyperparameter.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The value of the WeightsSetRateLimit hyperparameter, or ``None`` if the subnetwork does not exist or the parameter is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hyperparameter</span><span class="p">(</span><span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;WeightsSetRateLimit&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">)</span></div>


    <span class="c1"># Keep backwards compatibility for community usage.</span>
    <span class="c1"># Make some commitment on-chain about arbitrary data.</span>
<div class="viewcode-block" id="Subtensor.commit">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.commit">[docs]</a>
    <span class="k">def</span> <span class="nf">commit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wallet</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Commits arbitrary data to the Bittensor network by publishing metadata.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): The wallet associated with the neuron committing the data.</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            data (str): The data to be committed to the network.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">publish_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wallet</span><span class="p">,</span> <span class="n">netuid</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Raw</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span></div>


    <span class="c1"># Keep backwards compatibility for community usage.</span>
<div class="viewcode-block" id="Subtensor.subnetwork_n">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.subnetwork_n">[docs]</a>
    <span class="k">def</span> <span class="nf">subnetwork_n</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns network SubnetworkN hyperparameter.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            block (Optional[int]): The block number to retrieve the parameter from. If ``None``, the latest block is used. Default is ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The value of the SubnetworkN hyperparameter, or ``None`` if the subnetwork does not exist or the parameter is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hyperparameter</span><span class="p">(</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;SubnetworkN&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">)</span></div>


    <span class="c1"># Community uses this method</span>
<div class="viewcode-block" id="Subtensor.transfer">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.transfer">[docs]</a>
    <span class="k">def</span> <span class="nf">transfer</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">dest</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">amount</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;Balance&quot;</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Executes a transfer of funds from the provided wallet to the specified destination address. This function is used to move TAO tokens within the Bittensor network, facilitating transactions between neurons.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): The wallet from which funds are being transferred.</span>
<span class="sd">            dest (str): The destination public key address.</span>
<span class="sd">            amount (Union[bittensor.utils.balance.Balance, float]): The amount of TAO to be transferred.</span>
<span class="sd">            wait_for_inclusion (bool): Waits for the transaction to be included in a block.  Default is ``True``.</span>
<span class="sd">            wait_for_finalization (bool): Waits for the transaction to be finalized on the blockchain.  Default is ``False``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            transfer_extrinsic (bool): ``True`` if the transfer is successful, False otherwise.</span>

<span class="sd">        This function is essential for the fluid movement of tokens in the network, supporting various economic activities such as staking, delegation, and reward distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">transfer_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">dest</span><span class="o">=</span><span class="n">dest</span><span class="p">,</span>
            <span class="n">amount</span><span class="o">=</span><span class="n">amount</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="c1"># Community uses this method via `bittensor.api.extrinsics.prometheus.prometheus_extrinsic`</span>
<div class="viewcode-block" id="Subtensor.get_neuron_for_pubkey_and_subnet">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.get_neuron_for_pubkey_and_subnet">[docs]</a>
    <span class="k">def</span> <span class="nf">get_neuron_for_pubkey_and_subnet</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;NeuronInfo&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves information about a neuron based on its public key (hotkey SS58 address) and the specific subnet UID (netuid). This function provides detailed neuron information for a particular subnet within the Bittensor network.</span>

<span class="sd">        Args:</span>
<span class="sd">            hotkey_ss58 (str): The ``SS58`` address of the neuron&#39;s hotkey.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int]): The blockchain block number at which to perform the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[bittensor.core.chain_data.neuron_info.NeuronInfo]: Detailed information about the neuron if found, ``None`` otherwise.</span>

<span class="sd">        This function is crucial for accessing specific neuron data and understanding its status, stake, and other attributes within a particular subnet of the Bittensor ecosystem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron_for_uid</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_uid_for_hotkey_on_subnet</span><span class="p">(</span><span class="n">hotkey_ss58</span><span class="p">,</span> <span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">),</span>
            <span class="n">netuid</span><span class="p">,</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.neuron_for_uid">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.neuron_for_uid">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">neuron_for_uid</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">uid</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;NeuronInfo&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves detailed information about a specific neuron identified by its unique identifier (UID) within a specified subnet (netuid) of the Bittensor network. This function provides a comprehensive view of a neuron&#39;s attributes, including its stake, rank, and operational status.</span>

<span class="sd">        Args:</span>
<span class="sd">            uid (Optional[int]): The unique identifier of the neuron.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bittensor.core.chain_data.neuron_info.NeuronInfo: Detailed information about the neuron if found, ``None`` otherwise.</span>

<span class="sd">        This function is crucial for analyzing individual neurons&#39; contributions and status within a specific subnet, offering insights into their roles in the network&#39;s consensus and validation mechanisms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">uid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">NeuronInfo</span><span class="o">.</span><span class="n">get_null_neuron</span><span class="p">()</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">logging</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">():</span>
            <span class="n">block_hash</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
            <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">netuid</span><span class="p">,</span> <span class="n">uid</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">block_hash</span><span class="p">:</span>
                <span class="n">params</span> <span class="o">=</span> <span class="n">params</span> <span class="o">+</span> <span class="p">[</span><span class="n">block_hash</span><span class="p">]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">rpc_request</span><span class="p">(</span>
                <span class="n">method</span><span class="o">=</span><span class="s2">&quot;neuronInfo_getNeuron&quot;</span><span class="p">,</span>
                <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>  <span class="c1"># custom rpc method</span>
            <span class="p">)</span>

        <span class="n">json_body</span> <span class="o">=</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">result</span> <span class="o">:=</span> <span class="n">json_body</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;result&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">NeuronInfo</span><span class="o">.</span><span class="n">get_null_neuron</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">NeuronInfo</span><span class="o">.</span><span class="n">from_vec_u8</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>


    <span class="c1"># Community uses this method</span>
<div class="viewcode-block" id="Subtensor.get_subnet_hyperparameters">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.get_subnet_hyperparameters">[docs]</a>
    <span class="k">def</span> <span class="nf">get_subnet_hyperparameters</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="s2">&quot;SubnetHyperparameters&quot;</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the hyperparameters for a specific subnet within the Bittensor network. These hyperparameters define the operational settings and rules governing the subnet&#39;s behavior.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The network UID of the subnet to query.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[bittensor.core.chain_data.subnet_hyperparameters.SubnetHyperparameters]: The subnet&#39;s hyperparameters, or ``None`` if not available.</span>

<span class="sd">        Understanding the hyperparameters is crucial for comprehending how subnets are configured and managed, and how they interact with the network&#39;s consensus and incentive mechanisms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hex_bytes_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_runtime_api</span><span class="p">(</span>
            <span class="n">runtime_api</span><span class="o">=</span><span class="s2">&quot;SubnetInfoRuntimeApi&quot;</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;get_subnet_hyperparams&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">],</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">hex_bytes_result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">hex_bytes_result</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;0x&quot;</span><span class="p">):</span>
            <span class="n">bytes_result</span> <span class="o">=</span> <span class="nb">bytes</span><span class="o">.</span><span class="n">fromhex</span><span class="p">(</span><span class="n">hex_bytes_result</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bytes_result</span> <span class="o">=</span> <span class="nb">bytes</span><span class="o">.</span><span class="n">fromhex</span><span class="p">(</span><span class="n">hex_bytes_result</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">SubnetHyperparameters</span><span class="o">.</span><span class="n">from_vec_u8</span><span class="p">(</span><span class="n">bytes_result</span><span class="p">)</span>  <span class="c1"># type: ignore</span></div>


    <span class="c1"># Community uses this method</span>
    <span class="c1"># Returns network ImmunityPeriod hyper parameter.</span>
<div class="viewcode-block" id="Subtensor.immunity_period">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.immunity_period">[docs]</a>
    <span class="k">def</span> <span class="nf">immunity_period</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the &#39;ImmunityPeriod&#39; hyperparameter for a specific subnet. This parameter defines the duration during which new neurons are protected from certain network penalties or restrictions.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The value of the &#39;ImmunityPeriod&#39; hyperparameter if the subnet exists, ``None`` otherwise.</span>

<span class="sd">        The &#39;ImmunityPeriod&#39; is a critical aspect of the network&#39;s governance system, ensuring that new participants have a grace period to establish themselves and contribute to the network without facing immediate punitive actions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hyperparameter</span><span class="p">(</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;ImmunityPeriod&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">)</span></div>


    <span class="c1"># Community uses this method</span>
<div class="viewcode-block" id="Subtensor.get_uid_for_hotkey_on_subnet">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.get_uid_for_hotkey_on_subnet">[docs]</a>
    <span class="k">def</span> <span class="nf">get_uid_for_hotkey_on_subnet</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the unique identifier (UID) for a neuron&#39;s hotkey on a specific subnet.</span>

<span class="sd">        Args:</span>
<span class="sd">            hotkey_ss58 (str): The ``SS58`` address of the neuron&#39;s hotkey.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The UID of the neuron if it is registered on the subnet, ``None`` otherwise.</span>

<span class="sd">        The UID is a critical identifier within the network, linking the neuron&#39;s hotkey to its operational and governance activities on a particular subnet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_subtensor</span><span class="p">(</span><span class="s2">&quot;Uids&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="p">[</span><span class="n">netuid</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">_result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>


    <span class="c1"># Community uses this method</span>
<div class="viewcode-block" id="Subtensor.tempo">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.tempo">[docs]</a>
    <span class="k">def</span> <span class="nf">tempo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns network Tempo hyperparameter.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            block (Optional[int]): The block number to retrieve the parameter from. If ``None``, the latest block is used. Default is ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The value of the Tempo hyperparameter, or ``None`` if the subnetwork does not exist or the parameter is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hyperparameter</span><span class="p">(</span><span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;Tempo&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">)</span></div>


    <span class="c1"># Community uses this method</span>
<div class="viewcode-block" id="Subtensor.get_commitment">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.get_commitment">[docs]</a>
    <span class="k">def</span> <span class="nf">get_commitment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">uid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the on-chain commitment for a specific neuron in the Bittensor network.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            uid (int): The unique identifier of the neuron.</span>
<span class="sd">            block (Optional[int]): The block number to retrieve the commitment from. If None, the latest block is used. Default is ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: The commitment data as a string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">metagraph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metagraph</span><span class="p">(</span><span class="n">netuid</span><span class="p">)</span>
        <span class="n">hotkey</span> <span class="o">=</span> <span class="n">metagraph</span><span class="o">.</span><span class="n">hotkeys</span><span class="p">[</span><span class="n">uid</span><span class="p">]</span>  <span class="c1"># type: ignore</span>

        <span class="n">metadata</span> <span class="o">=</span> <span class="n">get_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">,</span> <span class="n">hotkey</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>
        <span class="n">commitment</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;info&quot;</span><span class="p">][</span><span class="s2">&quot;fields&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># type: ignore</span>
        <span class="n">hex_data</span> <span class="o">=</span> <span class="n">commitment</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">commitment</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">2</span><span class="p">:]</span>  <span class="c1"># type: ignore</span>

        <span class="k">return</span> <span class="nb">bytes</span><span class="o">.</span><span class="n">fromhex</span><span class="p">(</span><span class="n">hex_data</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span></div>


    <span class="c1"># Community uses this via `bittensor.utils.weight_utils.process_weights_for_netuid` function.</span>
<div class="viewcode-block" id="Subtensor.min_allowed_weights">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.min_allowed_weights">[docs]</a>
    <span class="k">def</span> <span class="nf">min_allowed_weights</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns network MinAllowedWeights hyperparameter.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            block (Optional[int]): The block number to retrieve the parameter from. If ``None``, the latest block is used. Default is ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The value of the MinAllowedWeights hyperparameter, or ``None`` if the subnetwork does not exist or the parameter is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hyperparameter</span><span class="p">(</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;MinAllowedWeights&quot;</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">)</span></div>


    <span class="c1"># Community uses this via `bittensor.utils.weight_utils.process_weights_for_netuid` function.</span>
<div class="viewcode-block" id="Subtensor.max_weight_limit">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.max_weight_limit">[docs]</a>
    <span class="k">def</span> <span class="nf">max_weight_limit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns network MaxWeightsLimit hyperparameter.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            block (Optional[int]): The block number to retrieve the parameter from. If ``None``, the latest block is used. Default is ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[float]: The value of the MaxWeightsLimit hyperparameter, or ``None`` if the subnetwork does not exist or the parameter is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hyperparameter</span><span class="p">(</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;MaxWeightsLimit&quot;</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">u16_normalized_float</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">))</span></div>


    <span class="c1"># # Community uses this method. It is used in subtensor in neuron_info, and serving.</span>
<div class="viewcode-block" id="Subtensor.get_prometheus_info">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.get_prometheus_info">[docs]</a>
    <span class="k">def</span> <span class="nf">get_prometheus_info</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;PrometheusInfo&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the prometheus information for this hotkey account.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            hotkey_ss58 (str): The SS58 address of the hotkey.</span>
<span class="sd">            block (Optional[int]): The block number to retrieve the prometheus information from. If ``None``, the latest block is used. Default is ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[bittensor.core.chain_data.prometheus_info.PrometheusInfo]: A PrometheusInfo object containing the prometheus information, or ``None`` if the prometheus information is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_subtensor</span><span class="p">(</span><span class="s2">&quot;Prometheus&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="p">[</span><span class="n">netuid</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">PrometheusInfo</span><span class="p">(</span>
                <span class="n">ip</span><span class="o">=</span><span class="n">networking</span><span class="o">.</span><span class="n">int_to_ip</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="s2">&quot;ip&quot;</span><span class="p">]),</span>
                <span class="n">ip_type</span><span class="o">=</span><span class="n">result</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="s2">&quot;ip_type&quot;</span><span class="p">],</span>
                <span class="n">port</span><span class="o">=</span><span class="n">result</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="s2">&quot;port&quot;</span><span class="p">],</span>
                <span class="n">version</span><span class="o">=</span><span class="n">result</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="s2">&quot;version&quot;</span><span class="p">],</span>
                <span class="n">block</span><span class="o">=</span><span class="n">result</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="s2">&quot;block&quot;</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span></div>


    <span class="c1"># Community uses this method</span>
<div class="viewcode-block" id="Subtensor.subnet_exists">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.subnet_exists">[docs]</a>
    <span class="k">def</span> <span class="nf">subnet_exists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if a subnet with the specified unique identifier (netuid) exists within the Bittensor network.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int]): The blockchain block number at which to check the subnet&#39;s existence.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the subnet exists, False otherwise.</span>

<span class="sd">        This function is critical for verifying the presence of specific subnets in the network, enabling a deeper understanding of the network&#39;s structure and composition.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_subtensor</span><span class="p">(</span><span class="s2">&quot;NetworksAdded&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="p">[</span><span class="n">netuid</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">_result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_all_subnets_info">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.get_all_subnets_info">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">get_all_subnets_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">SubnetInfo</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves detailed information about all subnets within the Bittensor network. This function provides comprehensive data on each subnet, including its characteristics and operational parameters.</span>

<span class="sd">        Args:</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[SubnetInfo]: A list of SubnetInfo objects, each containing detailed information about a subnet.</span>

<span class="sd">        Gaining insights into the subnets&#39; details assists in understanding the network&#39;s composition, the roles of different subnets, and their unique features.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">():</span>
            <span class="n">block_hash</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">rpc_request</span><span class="p">(</span>
                <span class="n">method</span><span class="o">=</span><span class="s2">&quot;subnetInfo_getSubnetsInfo&quot;</span><span class="p">,</span>  <span class="c1"># custom rpc method</span>
                <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">block_hash</span><span class="p">]</span> <span class="k">if</span> <span class="n">block_hash</span> <span class="k">else</span> <span class="p">[],</span>
            <span class="p">)</span>

        <span class="n">json_body</span> <span class="o">=</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">result</span> <span class="o">:=</span> <span class="n">json_body</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;result&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)):</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="n">SubnetInfo</span><span class="o">.</span><span class="n">list_from_vec_u8</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>


    <span class="c1"># Metagraph uses this method</span>
<div class="viewcode-block" id="Subtensor.bonds">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.bonds">[docs]</a>
    <span class="k">def</span> <span class="nf">bonds</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the bond distribution set by neurons within a specific subnet of the Bittensor network. Bonds represent the investments or commitments made by neurons in one another, indicating a level of trust and perceived value. This bonding mechanism is integral to the network&#39;s market-based approach to measuring and rewarding machine intelligence.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The network UID of the subnet to query.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[tuple[int, list[tuple[int, int]]]]: A list of tuples mapping each neuron&#39;s UID to its bonds with other neurons.</span>

<span class="sd">        Understanding bond distributions is crucial for analyzing the trust dynamics and market behavior within the subnet. It reflects how neurons recognize and invest in each other&#39;s intelligence and contributions, supporting diverse and niche systems within the Bittensor ecosystem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">b_map</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">b_map_encoded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_map_subtensor</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Bonds&quot;</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">b_map_encoded</span><span class="o">.</span><span class="n">records</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">uid</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">b_map_encoded</span><span class="p">:</span>
                <span class="n">b_map</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">uid</span><span class="o">.</span><span class="n">serialize</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">serialize</span><span class="p">()))</span>

        <span class="k">return</span> <span class="n">b_map</span></div>


<div class="viewcode-block" id="Subtensor.get_subnet_burn_cost">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.get_subnet_burn_cost">[docs]</a>
    <span class="k">def</span> <span class="nf">get_subnet_burn_cost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the burn cost for registering a new subnet within the Bittensor network. This cost represents the amount of Tao that needs to be locked or burned to establish a new subnet.</span>

<span class="sd">        Args:</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: The burn cost for subnet registration.</span>

<span class="sd">        The subnet burn cost is an important economic parameter, reflecting the network&#39;s mechanisms for controlling the proliferation of subnets and ensuring their commitment to the network&#39;s long-term viability.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lock_cost</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_runtime_api</span><span class="p">(</span>
            <span class="n">runtime_api</span><span class="o">=</span><span class="s2">&quot;SubnetRegistrationRuntimeApi&quot;</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;get_network_registration_cost&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[],</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">lock_cost</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">lock_cost</span></div>


    <span class="c1"># Metagraph uses this method</span>
<div class="viewcode-block" id="Subtensor.neurons">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.neurons">[docs]</a>
    <span class="k">def</span> <span class="nf">neurons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="s2">&quot;NeuronInfo&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a list of all neurons within a specified subnet of the Bittensor network. This function provides a snapshot of the subnet&#39;s neuron population, including each neuron&#39;s attributes and network interactions.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[bittensor.core.chain_data.neuron_info.NeuronInfo]: A list of NeuronInfo objects detailing each neuron&#39;s characteristics in the subnet.</span>

<span class="sd">        Understanding the distribution and status of neurons within a subnet is key to comprehending the network&#39;s decentralized structure and the dynamics of its consensus and governance processes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">neurons_lite</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neurons_lite</span><span class="p">(</span><span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">)</span>
        <span class="n">bonds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">)</span>

        <span class="n">weights_as_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">uid</span><span class="p">:</span> <span class="n">w</span> <span class="k">for</span> <span class="n">uid</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">weights</span><span class="p">}</span>
        <span class="n">bonds_as_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">uid</span><span class="p">:</span> <span class="n">b</span> <span class="k">for</span> <span class="n">uid</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bonds</span><span class="p">}</span>

        <span class="n">neurons</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">NeuronInfo</span><span class="o">.</span><span class="n">from_weights_bonds_and_neuron_lite</span><span class="p">(</span>
                <span class="n">neuron_lite</span><span class="p">,</span> <span class="n">weights_as_dict</span><span class="p">,</span> <span class="n">bonds_as_dict</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">neuron_lite</span> <span class="ow">in</span> <span class="n">neurons_lite</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="n">neurons</span></div>


    <span class="c1"># Metagraph uses this method</span>
<div class="viewcode-block" id="Subtensor.get_total_subnets">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.get_total_subnets">[docs]</a>
    <span class="k">def</span> <span class="nf">get_total_subnets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the total number of subnets within the Bittensor network as of a specific blockchain block.</span>

<span class="sd">        Args:</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The total number of subnets in the network.</span>

<span class="sd">        Understanding the total number of subnets is essential for assessing the network&#39;s growth and the extent of its decentralized infrastructure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_subtensor</span><span class="p">(</span><span class="s2">&quot;TotalNetworks&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">_result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>


    <span class="c1"># Metagraph uses this method</span>
<div class="viewcode-block" id="Subtensor.get_subnets">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.get_subnets">[docs]</a>
    <span class="k">def</span> <span class="nf">get_subnets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a list of all subnets currently active within the Bittensor network. This function provides an overview of the various subnets and their identifiers.</span>

<span class="sd">        Args:</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[int]: A list of network UIDs representing each active subnet.</span>

<span class="sd">        This function is valuable for understanding the network&#39;s structure and the diversity of subnets available for neuron participation and collaboration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_map_subtensor</span><span class="p">(</span><span class="s2">&quot;NetworksAdded&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="p">[</span><span class="n">network</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">network</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">records</span> <span class="k">if</span> <span class="n">network</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">result</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;records&quot;</span><span class="p">)</span>
            <span class="k">else</span> <span class="p">[]</span>
        <span class="p">)</span></div>


    <span class="c1"># Metagraph uses this method</span>
<div class="viewcode-block" id="Subtensor.neurons_lite">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.neurons_lite">[docs]</a>
    <span class="k">def</span> <span class="nf">neurons_lite</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="s2">&quot;NeuronInfoLite&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a list of neurons in a &#39;lite&#39; format from a specific subnet of the Bittensor network. This function provides a streamlined view of the neurons, focusing on key attributes such as stake and network participation.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[bittensor.core.chain_data.neuron_info_lite.NeuronInfoLite]: A list of simplified neuron information for the subnet.</span>

<span class="sd">        This function offers a quick overview of the neuron population within a subnet, facilitating efficient analysis of the network&#39;s decentralized structure and neuron dynamics.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hex_bytes_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_runtime_api</span><span class="p">(</span>
            <span class="n">runtime_api</span><span class="o">=</span><span class="s2">&quot;NeuronInfoRuntimeApi&quot;</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;get_neurons_lite&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">],</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">hex_bytes_result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">hex_bytes_result</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;0x&quot;</span><span class="p">):</span>
            <span class="n">bytes_result</span> <span class="o">=</span> <span class="nb">bytes</span><span class="o">.</span><span class="n">fromhex</span><span class="p">(</span><span class="n">hex_bytes_result</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bytes_result</span> <span class="o">=</span> <span class="nb">bytes</span><span class="o">.</span><span class="n">fromhex</span><span class="p">(</span><span class="n">hex_bytes_result</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">NeuronInfoLite</span><span class="o">.</span><span class="n">list_from_vec_u8</span><span class="p">(</span><span class="n">bytes_result</span><span class="p">)</span>  <span class="c1"># type: ignore</span></div>


    <span class="c1"># Used in the `neurons` method which is used in metagraph.py</span>
<div class="viewcode-block" id="Subtensor.weights">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.weights">[docs]</a>
    <span class="k">def</span> <span class="nf">weights</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the weight distribution set by neurons within a specific subnet of the Bittensor network. This function maps each neuron&#39;s UID to the weights it assigns to other neurons, reflecting the network&#39;s trust and value assignment mechanisms.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The network UID of the subnet to query.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[tuple[int, list[tuple[int, int]]]]: A list of tuples mapping each neuron&#39;s UID to its assigned weights.</span>

<span class="sd">        The weight distribution is a key factor in the network&#39;s consensus algorithm and the ranking of neurons, influencing their influence and reward allocation within the subnet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">w_map</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">w_map_encoded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_map_subtensor</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Weights&quot;</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">w_map_encoded</span><span class="o">.</span><span class="n">records</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">uid</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">w_map_encoded</span><span class="p">:</span>
                <span class="n">w_map</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">uid</span><span class="o">.</span><span class="n">serialize</span><span class="p">(),</span> <span class="n">w</span><span class="o">.</span><span class="n">serialize</span><span class="p">()))</span>

        <span class="k">return</span> <span class="n">w_map</span></div>


    <span class="c1"># Used by community via `transfer_extrinsic`</span>
<div class="viewcode-block" id="Subtensor.get_balance">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.get_balance">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">get_balance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Balance&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the token balance of a specific address within the Bittensor network. This function queries the blockchain to determine the amount of Tao held by a given account.</span>

<span class="sd">        Args:</span>
<span class="sd">            address (str): The Substrate address in ``ss58`` format.</span>
<span class="sd">            block (Optional[int]): The blockchain block number at which to perform the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bittensor.utils.balance.Balance: The account balance at the specified block, represented as a Balance object.</span>

<span class="sd">        This function is important for monitoring account holdings and managing financial transactions within the Bittensor ecosystem. It helps in assessing the economic status and capacity of network participants.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>

            <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">logging</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">():</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
                    <span class="n">module</span><span class="o">=</span><span class="s2">&quot;System&quot;</span><span class="p">,</span>
                    <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;Account&quot;</span><span class="p">,</span>
                    <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">address</span><span class="p">],</span>
                    <span class="n">block_hash</span><span class="o">=</span><span class="p">(</span>
                        <span class="kc">None</span> <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
                    <span class="p">),</span>
                <span class="p">)</span>

            <span class="n">result</span> <span class="o">=</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span>

        <span class="k">except</span> <span class="n">RemainingScaleBytesNotEmptyException</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;Received a corrupted message. This likely points to an error with the network or subnet.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">Balance</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Balance</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">][</span><span class="s2">&quot;free&quot;</span><span class="p">])</span></div>


    <span class="c1"># Used in community via `bittensor.core.subtensor.Subtensor.transfer`</span>
<div class="viewcode-block" id="Subtensor.get_transfer_fee">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.get_transfer_fee">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">get_transfer_fee</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;Balance&quot;</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Balance&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the transaction fee for transferring tokens from a wallet to a specified destination address. This function simulates the transfer to estimate the associated cost, taking into account the current network conditions and transaction complexity.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): The wallet from which the transfer is initiated.</span>
<span class="sd">            dest (str): The ``SS58`` address of the destination account.</span>
<span class="sd">            value (Union[bittensor.utils.balance.Balance, float, int]): The amount of tokens to be transferred, specified as a Balance object, or in Tao (float) or Rao (int) units.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bittensor.utils.balance.Balance: The estimated transaction fee for the transfer, represented as a Balance object.</span>

<span class="sd">        Estimating the transfer fee is essential for planning and executing token transactions, ensuring that the wallet has sufficient funds to cover both the transfer amount and the associated costs. This function provides a crucial tool for managing financial operations within the Bittensor network.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_tao</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Balance</span><span class="p">):</span>
            <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">compose_call</span><span class="p">(</span>
                <span class="n">call_module</span><span class="o">=</span><span class="s2">&quot;Balances&quot;</span><span class="p">,</span>
                <span class="n">call_function</span><span class="o">=</span><span class="s2">&quot;transfer_allow_death&quot;</span><span class="p">,</span>
                <span class="n">call_params</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;dest&quot;</span><span class="p">:</span> <span class="n">dest</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">value</span><span class="o">.</span><span class="n">rao</span><span class="p">},</span>
            <span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">payment_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_payment_info</span><span class="p">(</span>
                    <span class="n">call</span><span class="o">=</span><span class="n">call</span><span class="p">,</span> <span class="n">keypair</span><span class="o">=</span><span class="n">wallet</span><span class="o">.</span><span class="n">coldkeypub</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&lt;red&gt;Failed to get payment info.&lt;/red&gt; </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">payment_info</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;partialFee&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="mf">2e7</span><span class="p">)}</span>  <span class="c1"># assume  0.02 Tao</span>

            <span class="n">fee</span> <span class="o">=</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="n">payment_info</span><span class="p">[</span><span class="s2">&quot;partialFee&quot;</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">fee</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fee</span> <span class="o">=</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="mf">2e7</span><span class="p">))</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;To calculate the transaction fee, the value must be Balance, float, or int. Received type: </span><span class="si">%s</span><span class="s2">. Fee &quot;</span>
                <span class="s2">&quot;is </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">),</span>
                <span class="mf">2e7</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">fee</span></div>


    <span class="c1"># Used in community via `bittensor.core.subtensor.Subtensor.transfer`</span>
<div class="viewcode-block" id="Subtensor.get_existential_deposit">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.get_existential_deposit">[docs]</a>
    <span class="k">def</span> <span class="nf">get_existential_deposit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;Balance&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the existential deposit amount for the Bittensor blockchain. The existential deposit is the minimum amount of TAO required for an account to exist on the blockchain. Accounts with balances below this threshold can be reaped to conserve network resources.</span>

<span class="sd">        Args:</span>
<span class="sd">            block (Optional[int]): Block number at which to query the deposit amount. If ``None``, the current block is used.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[bittensor.utils.balance.Balance]: The existential deposit amount, or ``None`` if the query fails.</span>

<span class="sd">        The existential deposit is a fundamental economic parameter in the Bittensor network, ensuring efficient use of storage and preventing the proliferation of dust accounts.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_constant</span><span class="p">(</span>
            <span class="n">module_name</span><span class="o">=</span><span class="s2">&quot;Balances&quot;</span><span class="p">,</span> <span class="n">constant_name</span><span class="o">=</span><span class="s2">&quot;ExistentialDeposit&quot;</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">value</span><span class="p">)</span></div>


    <span class="c1"># Community uses this method</span>
<div class="viewcode-block" id="Subtensor.commit_weights">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.commit_weights">[docs]</a>
    <span class="k">def</span> <span class="nf">commit_weights</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">salt</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">uids</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">],</span> <span class="nb">list</span><span class="p">],</span>
        <span class="n">weights</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">],</span> <span class="nb">list</span><span class="p">],</span>
        <span class="n">version_key</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">version_as_int</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_retries</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Commits a hash of the neuron&#39;s weights to the Bittensor blockchain using the provided wallet.</span>
<span class="sd">        This action serves as a commitment or snapshot of the neuron&#39;s current weight distribution.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): The wallet associated with the neuron committing the weights.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            salt (list[int]): list of randomly generated integers as salt to generated weighted hash.</span>
<span class="sd">            uids (np.ndarray): NumPy array of neuron UIDs for which weights are being committed.</span>
<span class="sd">            weights (np.ndarray): NumPy array of weight values corresponding to each UID.</span>
<span class="sd">            version_key (int): Version key for compatibility with the network. Default is ``int representation of Bittensor version.``.</span>
<span class="sd">            wait_for_inclusion (bool): Waits for the transaction to be included in a block. Default is ``False``.</span>
<span class="sd">            wait_for_finalization (bool): Waits for the transaction to be finalized on the blockchain. Default is ``False``.</span>
<span class="sd">            max_retries (int): The number of maximum attempts to commit weights. Default is ``5``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[bool, str]: ``True`` if the weight commitment is successful, False otherwise. And `msg`, a string</span>
<span class="sd">            value describing the success or potential error.</span>

<span class="sd">        This function allows neurons to create a tamper-proof record of their weight distribution at a specific point in time,</span>
<span class="sd">        enhancing transparency and accountability within the Bittensor network.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;No attempt made. Perhaps it is too soon to commit weights!&quot;</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Committing weights with params: netuid=</span><span class="si">{</span><span class="n">netuid</span><span class="si">}</span><span class="s2">, uids=</span><span class="si">{</span><span class="n">uids</span><span class="si">}</span><span class="s2">, weights=</span><span class="si">{</span><span class="n">weights</span><span class="si">}</span><span class="s2">, version_key=</span><span class="si">{</span><span class="n">version_key</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Generate the hash of the weights</span>
        <span class="n">commit_hash</span> <span class="o">=</span> <span class="n">generate_weight_hash</span><span class="p">(</span>
            <span class="n">address</span><span class="o">=</span><span class="n">wallet</span><span class="o">.</span><span class="n">hotkey</span><span class="o">.</span><span class="n">ss58_address</span><span class="p">,</span>
            <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
            <span class="n">uids</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">uids</span><span class="p">),</span>
            <span class="n">values</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">weights</span><span class="p">),</span>
            <span class="n">salt</span><span class="o">=</span><span class="n">salt</span><span class="p">,</span>
            <span class="n">version_key</span><span class="o">=</span><span class="n">version_key</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Commit Hash: </span><span class="si">{</span><span class="n">commit_hash</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">while</span> <span class="n">retries</span> <span class="o">&lt;</span> <span class="n">max_retries</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">success</span><span class="p">,</span> <span class="n">message</span> <span class="o">=</span> <span class="n">commit_weights_extrinsic</span><span class="p">(</span>
                    <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
                    <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
                    <span class="n">commit_hash</span><span class="o">=</span><span class="n">commit_hash</span><span class="p">,</span>
                    <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                    <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">success</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error committing weights: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="n">retries</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">success</span><span class="p">,</span> <span class="n">message</span></div>


    <span class="c1"># Community uses this method</span>
<div class="viewcode-block" id="Subtensor.reveal_weights">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.reveal_weights">[docs]</a>
    <span class="k">def</span> <span class="nf">reveal_weights</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">uids</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">],</span> <span class="nb">list</span><span class="p">],</span>
        <span class="n">weights</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">],</span> <span class="nb">list</span><span class="p">],</span>
        <span class="n">salt</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">],</span> <span class="nb">list</span><span class="p">],</span>
        <span class="n">version_key</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">version_as_int</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_retries</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reveals the weights for a specific subnet on the Bittensor blockchain using the provided wallet.</span>
<span class="sd">        This action serves as a revelation of the neuron&#39;s previously committed weight distribution.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): The wallet associated with the neuron revealing the weights.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            uids (np.ndarray): NumPy array of neuron UIDs for which weights are being revealed.</span>
<span class="sd">            weights (np.ndarray): NumPy array of weight values corresponding to each UID.</span>
<span class="sd">            salt (np.ndarray): NumPy array of salt values corresponding to the hash function.</span>
<span class="sd">            version_key (int): Version key for compatibility with the network. Default is ``int representation of Bittensor version``.</span>
<span class="sd">            wait_for_inclusion (bool): Waits for the transaction to be included in a block. Default is ``False``.</span>
<span class="sd">            wait_for_finalization (bool): Waits for the transaction to be finalized on the blockchain. Default is ``False``.</span>
<span class="sd">            max_retries (int): The number of maximum attempts to reveal weights. Default is ``5``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[bool, str]: ``True`` if the weight revelation is successful, False otherwise. And `msg`, a string</span>
<span class="sd">            value describing the success or potential error.</span>

<span class="sd">        This function allows neurons to reveal their previously committed weight distribution, ensuring transparency</span>
<span class="sd">        and accountability within the Bittensor network.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;No attempt made. Perhaps it is too soon to reveal weights!&quot;</span>

        <span class="k">while</span> <span class="n">retries</span> <span class="o">&lt;</span> <span class="n">max_retries</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">success</span><span class="p">,</span> <span class="n">message</span> <span class="o">=</span> <span class="n">reveal_weights_extrinsic</span><span class="p">(</span>
                    <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
                    <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
                    <span class="n">uids</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">uids</span><span class="p">),</span>
                    <span class="n">weights</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">weights</span><span class="p">),</span>
                    <span class="n">salt</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">salt</span><span class="p">),</span>
                    <span class="n">version_key</span><span class="o">=</span><span class="n">version_key</span><span class="p">,</span>
                    <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                    <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">success</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error revealing weights: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="n">retries</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">success</span><span class="p">,</span> <span class="n">message</span></div>


<div class="viewcode-block" id="Subtensor.difficulty">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.difficulty">[docs]</a>
    <span class="k">def</span> <span class="nf">difficulty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the &#39;Difficulty&#39; hyperparameter for a specified subnet in the Bittensor network.</span>

<span class="sd">        This parameter is instrumental in determining the computational challenge required for neurons to participate in consensus and validation processes.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The value of the &#39;Difficulty&#39; hyperparameter if the subnet exists, ``None`` otherwise.</span>

<span class="sd">        The &#39;Difficulty&#39; parameter directly impacts the network&#39;s security and integrity by setting the computational effort required for validating transactions and participating in the network&#39;s consensus mechanism.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hyperparameter</span><span class="p">(</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;Difficulty&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.recycle">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.recycle">[docs]</a>
    <span class="k">def</span> <span class="nf">recycle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;Balance&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the &#39;Burn&#39; hyperparameter for a specified subnet. The &#39;Burn&#39; parameter represents the amount of Tao that is effectively recycled within the Bittensor network.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[Balance]: The value of the &#39;Burn&#39; hyperparameter if the subnet exists, None otherwise.</span>

<span class="sd">        Understanding the &#39;Burn&#39; rate is essential for analyzing the network registration usage, particularly how it is correlated with user activity and the overall cost of participation in a given subnet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hyperparameter</span><span class="p">(</span><span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;Burn&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">))</span></div>


<div class="viewcode-block" id="Subtensor.get_delegate_take">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.get_delegate_take">[docs]</a>
    <span class="k">def</span> <span class="nf">get_delegate_take</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the delegate &#39;take&#39; percentage for a neuron identified by its hotkey. The &#39;take&#39; represents the percentage of rewards that the delegate claims from its nominators&#39; stakes.</span>

<span class="sd">        Args:</span>
<span class="sd">            hotkey_ss58 (str): The ``SS58`` address of the neuron&#39;s hotkey.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[float]: The delegate take percentage, None if not available.</span>

<span class="sd">        The delegate take is a critical parameter in the network&#39;s incentive structure, influencing the distribution of rewards among neurons and their nominators.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_subtensor</span><span class="p">(</span><span class="s2">&quot;Delegates&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="p">[</span><span class="n">hotkey_ss58</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="kc">None</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">_result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="n">u16_normalized_float</span><span class="p">(</span><span class="n">_result</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_delegate_by_hotkey">
<a class="viewcode-back" href="../../../autoapi/bittensor/index.html#bittensor.core.subtensor.Subtensor.get_delegate_by_hotkey">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">get_delegate_by_hotkey</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DelegateInfo</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves detailed information about a delegate neuron based on its hotkey. This function provides a comprehensive view of the delegate&#39;s status, including its stakes, nominators, and reward distribution.</span>

<span class="sd">        Args:</span>
<span class="sd">            hotkey_ss58 (str): The ``SS58`` address of the delegate&#39;s hotkey.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query. Default is ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[DelegateInfo]: Detailed information about the delegate neuron, ``None`` if not found.</span>

<span class="sd">        This function is essential for understanding the roles and influence of delegate neurons within the Bittensor network&#39;s consensus and governance structures.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">(</span><span class="n">encoded_hotkey_</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
            <span class="n">block_hash</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">rpc_request</span><span class="p">(</span>
                <span class="n">method</span><span class="o">=</span><span class="s2">&quot;delegateInfo_getDelegate&quot;</span><span class="p">,</span>  <span class="c1"># custom rpc method</span>
                <span class="n">params</span><span class="o">=</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">encoded_hotkey_</span><span class="p">,</span> <span class="n">block_hash</span><span class="p">]</span> <span class="k">if</span> <span class="n">block_hash</span> <span class="k">else</span> <span class="p">[</span><span class="n">encoded_hotkey_</span><span class="p">]</span>
                <span class="p">),</span>
            <span class="p">)</span>

        <span class="n">encoded_hotkey</span> <span class="o">=</span> <span class="n">ss58_to_vec_u8</span><span class="p">(</span><span class="n">hotkey_ss58</span><span class="p">)</span>
        <span class="n">json_body</span> <span class="o">=</span> <span class="n">make_substrate_call_with_retry</span><span class="p">(</span><span class="n">encoded_hotkey</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">result</span> <span class="o">:=</span> <span class="n">json_body</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;result&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">DelegateInfo</span><span class="o">.</span><span class="n">from_vec_u8</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>


    <span class="c1"># Subnet 27 uses this method name</span>
    <span class="n">_do_serve_axon</span> <span class="o">=</span> <span class="n">do_serve_axon</span></div>

</pre></div>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Opentensor Foundation
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2024, Opentensor Foundation.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>