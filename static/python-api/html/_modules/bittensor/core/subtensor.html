
<!DOCTYPE html>


<html lang="en" data-content_root="../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>bittensor.core.subtensor &#8212; Bittensor SDK Docs  documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/sphinx-book-theme.css?v=a3416100" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=fd3f3429" />
    <link rel="stylesheet" type="text/css" href="../../../_static/bittensor-custom.css?v=c1dfe055" />
  
  <!-- So that users can add custom icons -->
  <script src="../../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/bittensor/core/subtensor';</script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../../_static/logo.svg" class="logo__image only-light" alt="Bittensor SDK Docs  documentation - Home"/>
    <img src="../../../_static/logo-dark-mode.svg" class="logo__image only-dark pst-js-only" alt="Bittensor SDK Docs  documentation - Home"/>
  
  
</a></div>
        <div class="sidebar-primary-item">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Table of Contents</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../autoapi/index.html">API Reference</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../autoapi/bittensor/index.html">bittensor</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../autoapi/bittensor/core/index.html">bittensor.core</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/async_subtensor/index.html">bittensor.core.async_subtensor</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/axon/index.html">bittensor.core.axon</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/chain_data/index.html">bittensor.core.chain_data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/config/index.html">bittensor.core.config</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/dendrite/index.html">bittensor.core.dendrite</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/errors/index.html">bittensor.core.errors</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/extrinsics/index.html">bittensor.core.extrinsics</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/metagraph/index.html">bittensor.core.metagraph</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/settings/index.html">bittensor.core.settings</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/stream/index.html">bittensor.core.stream</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/subtensor/index.html">bittensor.core.subtensor</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/subtensor_api/index.html">bittensor.core.subtensor_api</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/synapse/index.html">bittensor.core.synapse</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/tensor/index.html">bittensor.core.tensor</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/threadpool/index.html">bittensor.core.threadpool</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/timelock/index.html">bittensor.core.timelock</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/types/index.html">bittensor.core.types</a></li>
</ul>
</details></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../autoapi/bittensor/utils/index.html">bittensor.utils</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/axon_utils/index.html">bittensor.utils.axon_utils</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/balance/index.html">bittensor.utils.balance</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/btlogging/index.html">bittensor.utils.btlogging</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/easy_imports/index.html">bittensor.utils.easy_imports</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/formatting/index.html">bittensor.utils.formatting</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/mock/index.html">bittensor.utils.mock</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/networking/index.html">bittensor.utils.networking</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/registration/index.html">bittensor.utils.registration</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/subnets/index.html">bittensor.utils.subnets</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/substrate_utils/index.html">bittensor.utils.substrate_utils</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/version/index.html">bittensor.utils.version</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/weight_utils/index.html">bittensor.utils.weight_utils</a></li>
</ul>
</details></li>
</ul>
</details></li>
</ul>
</details></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/opentensor/btcli" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/opentensor/btcli/issues/new?title=Issue%20on%20page%20%2F_modules/bittensor/core/subtensor.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button>


<button class="btn btn-sm pst-navbar-icon search-button search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
</button>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1></h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for bittensor.core.subtensor</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">lru_cache</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">cast</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">import</span> <span class="nn">scalecodec</span>
<span class="kn">from</span> <span class="nn">async_substrate_interface.errors</span> <span class="kn">import</span> <span class="n">SubstrateRequestException</span>
<span class="kn">from</span> <span class="nn">async_substrate_interface.types</span> <span class="kn">import</span> <span class="n">ScaleObj</span>
<span class="kn">from</span> <span class="nn">async_substrate_interface.sync_substrate</span> <span class="kn">import</span> <span class="n">SubstrateInterface</span>
<span class="kn">from</span> <span class="nn">async_substrate_interface.utils</span> <span class="kn">import</span> <span class="n">json</span>
<span class="kn">from</span> <span class="nn">numpy.typing</span> <span class="kn">import</span> <span class="n">NDArray</span>

<span class="kn">from</span> <span class="nn">bittensor.core.async_subtensor</span> <span class="kn">import</span> <span class="n">ProposalVoteData</span>
<span class="kn">from</span> <span class="nn">bittensor.core.axon</span> <span class="kn">import</span> <span class="n">Axon</span>
<span class="kn">from</span> <span class="nn">bittensor.core.chain_data</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">DelegateInfo</span><span class="p">,</span>
    <span class="n">DynamicInfo</span><span class="p">,</span>
    <span class="n">MetagraphInfo</span><span class="p">,</span>
    <span class="n">NeuronInfo</span><span class="p">,</span>
    <span class="n">NeuronInfoLite</span><span class="p">,</span>
    <span class="n">StakeInfo</span><span class="p">,</span>
    <span class="n">SubnetHyperparameters</span><span class="p">,</span>
    <span class="n">WeightCommitInfo</span><span class="p">,</span>
    <span class="n">SubnetIdentity</span><span class="p">,</span>
    <span class="n">SubnetInfo</span><span class="p">,</span>
    <span class="n">decode_account_id</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">bittensor.core.chain_data.utils</span> <span class="kn">import</span> <span class="n">decode_metadata</span>
<span class="kn">from</span> <span class="nn">bittensor.core.config</span> <span class="kn">import</span> <span class="n">Config</span>
<span class="kn">from</span> <span class="nn">bittensor.core.extrinsics.commit_reveal</span> <span class="kn">import</span> <span class="n">commit_reveal_v3_extrinsic</span>
<span class="kn">from</span> <span class="nn">bittensor.core.extrinsics.commit_weights</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">commit_weights_extrinsic</span><span class="p">,</span>
    <span class="n">reveal_weights_extrinsic</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">bittensor.core.extrinsics.move_stake</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">transfer_stake_extrinsic</span><span class="p">,</span>
    <span class="n">swap_stake_extrinsic</span><span class="p">,</span>
    <span class="n">move_stake_extrinsic</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">bittensor.core.extrinsics.registration</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">burned_register_extrinsic</span><span class="p">,</span>
    <span class="n">register_extrinsic</span><span class="p">,</span>
    <span class="n">register_subnet_extrinsic</span><span class="p">,</span>
    <span class="n">set_subnet_identity_extrinsic</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">bittensor.core.extrinsics.root</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">root_register_extrinsic</span><span class="p">,</span>
    <span class="n">set_root_weights_extrinsic</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">bittensor.core.extrinsics.serving</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">publish_metadata</span><span class="p">,</span>
    <span class="n">get_metadata</span><span class="p">,</span>
    <span class="n">serve_axon_extrinsic</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">bittensor.core.extrinsics.set_weights</span> <span class="kn">import</span> <span class="n">set_weights_extrinsic</span>
<span class="kn">from</span> <span class="nn">bittensor.core.extrinsics.staking</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">add_stake_extrinsic</span><span class="p">,</span>
    <span class="n">add_stake_multiple_extrinsic</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">bittensor.core.extrinsics.transfer</span> <span class="kn">import</span> <span class="n">transfer_extrinsic</span>
<span class="kn">from</span> <span class="nn">bittensor.core.extrinsics.unstaking</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">unstake_extrinsic</span><span class="p">,</span>
    <span class="n">unstake_multiple_extrinsic</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">bittensor.core.metagraph</span> <span class="kn">import</span> <span class="n">Metagraph</span>
<span class="kn">from</span> <span class="nn">bittensor.core.settings</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">version_as_int</span><span class="p">,</span>
    <span class="n">SS58_FORMAT</span><span class="p">,</span>
    <span class="n">TYPE_REGISTRY</span><span class="p">,</span>
    <span class="n">DELEGATES_DETAILS_URL</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">bittensor.core.types</span> <span class="kn">import</span> <span class="n">ParamWithTypes</span><span class="p">,</span> <span class="n">SubtensorMixin</span>
<span class="kn">from</span> <span class="nn">bittensor.utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">torch</span><span class="p">,</span>
    <span class="n">format_error_message</span><span class="p">,</span>
    <span class="n">decode_hex_identity_dict</span><span class="p">,</span>
    <span class="n">u16_normalized_float</span><span class="p">,</span>
    <span class="n">_decode_hex_identity_dict</span><span class="p">,</span>
    <span class="n">Certificate</span><span class="p">,</span>
    <span class="n">u64_normalized_float</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">bittensor.utils.balance</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Balance</span><span class="p">,</span>
    <span class="n">fixed_to_float</span><span class="p">,</span>
    <span class="n">FixedPoint</span><span class="p">,</span>
    <span class="n">check_and_convert_to_balance</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">bittensor.utils.btlogging</span> <span class="kn">import</span> <span class="n">logging</span>
<span class="kn">from</span> <span class="nn">bittensor.utils.delegates_details</span> <span class="kn">import</span> <span class="n">DelegatesDetails</span>
<span class="kn">from</span> <span class="nn">bittensor.utils.weight_utils</span> <span class="kn">import</span> <span class="n">generate_weight_hash</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">bittensor_wallet</span> <span class="kn">import</span> <span class="n">Wallet</span>
    <span class="kn">from</span> <span class="nn">async_substrate_interface.sync_substrate</span> <span class="kn">import</span> <span class="n">QueryMapResult</span>
    <span class="kn">from</span> <span class="nn">scalecodec.types</span> <span class="kn">import</span> <span class="n">GenericCall</span>


<div class="viewcode-block" id="Subtensor">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor">[docs]</a>
<span class="k">class</span> <span class="nc">Subtensor</span><span class="p">(</span><span class="n">SubtensorMixin</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Thin layer for interacting with Substrate Interface. Mostly a collection of frequently-used calls.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">network</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">config</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;Config&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">_mock</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">log_verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes an instance of the Subtensor class.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            network (str): The network name or type to connect to.</span>
<span class="sd">            config (Optional[Config]): Configuration object for the AsyncSubtensor instance.</span>
<span class="sd">            _mock: Whether this is a mock instance. Mainly just for use in testing.</span>
<span class="sd">            log_verbose (bool): Enables or disables verbose logging.</span>

<span class="sd">        Raises:</span>
<span class="sd">            Any exceptions raised during the setup, configuration, or connection process.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">config</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">config</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_config</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chain_endpoint</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setup_config</span><span class="p">(</span><span class="n">network</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mock</span> <span class="o">=</span> <span class="n">_mock</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log_verbose</span> <span class="o">=</span> <span class="n">log_verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_and_log_network_settings</span><span class="p">()</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Connecting to network: [blue]</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="si">}</span><span class="s2">[/blue], &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;chain_endpoint: [blue]</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_endpoint</span><span class="si">}</span><span class="s2">[/blue]&gt; ...&quot;</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span> <span class="o">=</span> <span class="n">SubstrateInterface</span><span class="p">(</span>
            <span class="n">url</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_endpoint</span><span class="p">,</span>
            <span class="n">ss58_format</span><span class="o">=</span><span class="n">SS58_FORMAT</span><span class="p">,</span>
            <span class="n">type_registry</span><span class="o">=</span><span class="n">TYPE_REGISTRY</span><span class="p">,</span>
            <span class="n">use_remote_preset</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">chain_name</span><span class="o">=</span><span class="s2">&quot;Bittensor&quot;</span><span class="p">,</span>
            <span class="n">_mock</span><span class="o">=</span><span class="n">_mock</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_verbose</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Connected to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="si">}</span><span class="s2"> network and </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_endpoint</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_val</span><span class="p">,</span> <span class="n">exc_tb</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<div class="viewcode-block" id="Subtensor.close">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.close">[docs]</a>
    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Closes the websocket connection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>


    <span class="c1"># Subtensor queries ===========================================================================================</span>

<div class="viewcode-block" id="Subtensor.query_constant">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.query_constant">[docs]</a>
    <span class="k">def</span> <span class="nf">query_constant</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">module_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">constant_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;ScaleObj&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a constant from the specified module on the Bittensor blockchain. This function is used to access</span>
<span class="sd">            fixed parameters or values defined within the blockchain&#39;s modules, which are essential for understanding</span>
<span class="sd">            the network&#39;s configuration and rules.</span>

<span class="sd">        Args:</span>
<span class="sd">            module_name: The name of the module containing the constant.</span>
<span class="sd">            constant_name: The name of the constant to retrieve.</span>
<span class="sd">            block: The blockchain block number at which to query the constant.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[async_substrate_interface.types.ScaleObj]: The value of the constant if found, `None` otherwise.</span>

<span class="sd">        Constants queried through this function can include critical network parameters such as inflation rates,</span>
<span class="sd">            consensus rules, or validation thresholds, providing a deeper understanding of the Bittensor network&#39;s</span>
<span class="sd">            operational parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_constant</span><span class="p">(</span>
            <span class="n">module_name</span><span class="o">=</span><span class="n">module_name</span><span class="p">,</span>
            <span class="n">constant_name</span><span class="o">=</span><span class="n">constant_name</span><span class="p">,</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">),</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.query_map">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.query_map">[docs]</a>
    <span class="k">def</span> <span class="nf">query_map</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">module</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;QueryMapResult&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Queries map storage from any module on the Bittensor blockchain. This function retrieves data structures that</span>
<span class="sd">            represent key-value mappings, essential for accessing complex and structured data within the blockchain</span>
<span class="sd">            modules.</span>

<span class="sd">        Args:</span>
<span class="sd">            module: The name of the module from which to query the map storage.</span>
<span class="sd">            name: The specific storage function within the module to query.</span>
<span class="sd">            block: The blockchain block number at which to perform the query.</span>
<span class="sd">            params: Parameters to be passed to the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            result: A data structure representing the map storage if found, `None` otherwise.</span>

<span class="sd">        This function is particularly useful for retrieving detailed and structured data from various blockchain</span>
<span class="sd">            modules, offering insights into the network&#39;s state and the relationships between its different components.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query_map</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="n">module</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="Subtensor.query_map_subtensor">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.query_map_subtensor">[docs]</a>
    <span class="k">def</span> <span class="nf">query_map_subtensor</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;QueryMapResult&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Queries map storage from the Subtensor module on the Bittensor blockchain. This function is designed to retrieve</span>
<span class="sd">            a map-like data structure, which can include various neuron-specific details or network-wide attributes.</span>

<span class="sd">        Args:</span>
<span class="sd">            name: The name of the map storage function to query.</span>
<span class="sd">            block: The blockchain block number at which to perform the query.</span>
<span class="sd">            params: A list of parameters to pass to the query function.</span>

<span class="sd">        Returns:</span>
<span class="sd">            An object containing the map-like data structure, or `None` if not found.</span>

<span class="sd">        This function is particularly useful for analyzing and understanding complex network structures and</span>
<span class="sd">            relationships within the Bittensor ecosystem, such as interneuronal connections and stake distributions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query_map</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">),</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.query_module">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.query_module">[docs]</a>
    <span class="k">def</span> <span class="nf">query_module</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">module</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="s2">&quot;ScaleObj&quot;</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">FixedPoint</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Queries any module storage on the Bittensor blockchain with the specified parameters and block number. This</span>
<span class="sd">            function is a generic query interface that allows for flexible and diverse data retrieval from various</span>
<span class="sd">            blockchain modules.</span>

<span class="sd">        Args:</span>
<span class="sd">            module (str): The name of the module from which to query data.</span>
<span class="sd">            name (str): The name of the storage function within the module.</span>
<span class="sd">            block (Optional[int]): The blockchain block number at which to perform the query.</span>
<span class="sd">            params (Optional[list[object]]): A list of parameters to pass to the query function.</span>

<span class="sd">        Returns:</span>
<span class="sd">            An object containing the requested data if found, `None` otherwise.</span>

<span class="sd">        This versatile query function is key to accessing a wide range of data and insights from different parts of the</span>
<span class="sd">            Bittensor blockchain, enhancing the understanding and analysis of the network&#39;s state and dynamics.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="n">module</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">),</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.query_runtime_api">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.query_runtime_api">[docs]</a>
    <span class="k">def</span> <span class="nf">query_runtime_api</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">runtime_api</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Queries the runtime API of the Bittensor blockchain, providing a way to interact with the underlying runtime and</span>
<span class="sd">            retrieve data encoded in Scale Bytes format. This function is essential for advanced users who need to</span>
<span class="sd">            interact with specific runtime methods and decode complex data types.</span>

<span class="sd">        Args:</span>
<span class="sd">            runtime_api: The name of the runtime API to query.</span>
<span class="sd">            method: The specific method within the runtime API to call.</span>
<span class="sd">            params: The parameters to pass to the method call.</span>
<span class="sd">            block: the block number for this query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The Scale Bytes encoded result from the runtime API call, or `None` if the call fails.</span>

<span class="sd">        This function enables access to the deeper layers of the Bittensor blockchain, allowing for detailed and</span>
<span class="sd">            specific interactions with the network&#39;s runtime environment.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">block_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">runtime_call</span><span class="p">(</span><span class="n">runtime_api</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">block_hash</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">value</span></div>


<div class="viewcode-block" id="Subtensor.query_subtensor">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.query_subtensor">[docs]</a>
    <span class="k">def</span> <span class="nf">query_subtensor</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="s2">&quot;ScaleObj&quot;</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Queries named storage from the Subtensor module on the Bittensor blockchain. This function is used to retrieve</span>
<span class="sd">            specific data or parameters from the blockchain, such as stake, rank, or other neuron-specific attributes.</span>

<span class="sd">        Args:</span>
<span class="sd">            name: The name of the storage function to query.</span>
<span class="sd">            block: The blockchain block number at which to perform the query.</span>
<span class="sd">            params: A list of parameters to pass to the query function.</span>

<span class="sd">        Returns:</span>
<span class="sd">            query_response: An object containing the requested data.</span>

<span class="sd">        This query function is essential for accessing detailed information about the network and its neurons, providing</span>
<span class="sd">            valuable insights into the state and dynamics of the Bittensor ecosystem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">),</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.state_call">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.state_call">[docs]</a>
    <span class="k">def</span> <span class="nf">state_call</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes a state call to the Bittensor blockchain, allowing for direct queries of the blockchain&#39;s state. This</span>
<span class="sd">            function is typically used for advanced queries that require specific method calls and data inputs.</span>

<span class="sd">        Args:</span>
<span class="sd">            method: The method name for the state call.</span>
<span class="sd">            data: The data to be passed to the method.</span>
<span class="sd">            block: The blockchain block number at which to perform the state call.</span>

<span class="sd">        Returns:</span>
<span class="sd">            result (dict[Any, Any]): The result of the rpc call.</span>

<span class="sd">        The state call function provides a more direct and flexible way of querying blockchain data, useful for specific</span>
<span class="sd">            use cases where standard queries are insufficient.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">block_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">rpc_request</span><span class="p">(</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;state_call&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">method</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">block_hash</span><span class="p">]</span> <span class="k">if</span> <span class="n">block_hash</span> <span class="k">else</span> <span class="p">[</span><span class="n">method</span><span class="p">,</span> <span class="n">data</span><span class="p">],</span>
        <span class="p">)</span></div>


    <span class="c1"># Common subtensor calls ===========================================================================================</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">block</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_current_block</span><span class="p">()</span>

<div class="viewcode-block" id="Subtensor.all_subnets">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.all_subnets">[docs]</a>
    <span class="k">def</span> <span class="nf">all_subnets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="s2">&quot;DynamicInfo&quot;</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the subnet information for all subnets in the network.</span>

<span class="sd">        Args:</span>
<span class="sd">            block (Optional[int]): The block number to query the subnet information from.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[DynamicInfo]: A list of DynamicInfo objects, each containing detailed information about a subnet.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">block_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
        <span class="n">query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">runtime_call</span><span class="p">(</span>
            <span class="s2">&quot;SubnetInfoRuntimeApi&quot;</span><span class="p">,</span>
            <span class="s2">&quot;get_all_dynamic_info&quot;</span><span class="p">,</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">DynamicInfo</span><span class="o">.</span><span class="n">list_from_dicts</span><span class="p">(</span><span class="n">query</span><span class="o">.</span><span class="n">decode</span><span class="p">())</span></div>


<div class="viewcode-block" id="Subtensor.blocks_since_last_update">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.blocks_since_last_update">[docs]</a>
    <span class="k">def</span> <span class="nf">blocks_since_last_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">uid</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of blocks since the last update for a specific UID in the subnetwork.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            uid (int): The unique identifier of the neuron.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The number of blocks since the last update, or ``None`` if the subnetwork or UID does not</span>
<span class="sd">                exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hyperparameter</span><span class="p">(</span><span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;LastUpdate&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_current_block</span><span class="p">()</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">[</span><span class="n">uid</span><span class="p">]))</span></div>


<div class="viewcode-block" id="Subtensor.bonds">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.bonds">[docs]</a>
    <span class="k">def</span> <span class="nf">bonds</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the bond distribution set by neurons within a specific subnet of the Bittensor network.</span>
<span class="sd">            Bonds represent the investments or commitments made by neurons in one another, indicating a level of trust</span>
<span class="sd">            and perceived value. This bonding mechanism is integral to the network&#39;s market-based approach to</span>
<span class="sd">            measuring and rewarding machine intelligence.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid: The network UID of the subnet to query.</span>
<span class="sd">            block: the block number for this query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of tuples mapping each neuron&#39;s UID to its bonds with other neurons.</span>

<span class="sd">        Understanding bond distributions is crucial for analyzing the trust dynamics and market behavior within the</span>
<span class="sd">            subnet. It reflects how neurons recognize and invest in each other&#39;s intelligence and contributions,</span>
<span class="sd">            supporting diverse and niche systems within the Bittensor ecosystem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">b_map_encoded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query_map</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;Bonds&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">b_map</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">uid</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">b_map_encoded</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">b_map</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">uid</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">b_map</span></div>


<div class="viewcode-block" id="Subtensor.commit">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.commit">[docs]</a>
    <span class="k">def</span> <span class="nf">commit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wallet</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Commits arbitrary data to the Bittensor network by publishing metadata.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): The wallet associated with the neuron committing the data.</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            data (str): The data to be committed to the network.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">publish_metadata</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
            <span class="n">data_type</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Raw</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">encode</span><span class="p">(),</span>
        <span class="p">)</span></div>


    <span class="c1"># add explicit alias</span>
    <span class="n">set_commitment</span> <span class="o">=</span> <span class="n">commit</span>

<div class="viewcode-block" id="Subtensor.commit_reveal_enabled">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.commit_reveal_enabled">[docs]</a>
    <span class="k">def</span> <span class="nf">commit_reveal_enabled</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if commit-reveal mechanism is enabled for a given network at a specific block.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            netuid: The network identifier for which to check the commit-reveal mechanism.</span>
<span class="sd">            block: The block number to query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Returns the integer value of the hyperparameter if available; otherwise, returns None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hyperparameter</span><span class="p">(</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;CommitRevealWeightsEnabled&quot;</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">True</span> <span class="k">else</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="Subtensor.difficulty">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.difficulty">[docs]</a>
    <span class="k">def</span> <span class="nf">difficulty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the &#39;Difficulty&#39; hyperparameter for a specified subnet in the Bittensor network.</span>

<span class="sd">        This parameter is instrumental in determining the computational challenge required for neurons to participate in</span>
<span class="sd">            consensus and validation processes.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            netuid: The unique identifier of the subnet.</span>
<span class="sd">            block: The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The value of the &#39;Difficulty&#39; hyperparameter if the subnet exists, ``None`` otherwise.</span>

<span class="sd">        The &#39;Difficulty&#39; parameter directly impacts the network&#39;s security and integrity by setting the computational</span>
<span class="sd">            effort required for validating transactions and participating in the network&#39;s consensus mechanism.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hyperparameter</span><span class="p">(</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;Difficulty&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.does_hotkey_exist">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.does_hotkey_exist">[docs]</a>
    <span class="k">def</span> <span class="nf">does_hotkey_exist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns true if the hotkey is known by the chain and there are accounts.</span>

<span class="sd">        Args:</span>
<span class="sd">            hotkey_ss58: The SS58 address of the hotkey.</span>
<span class="sd">            block: the block number for this query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            `True` if the hotkey is known by the chain and there are accounts, `False` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;Owner&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">hotkey_ss58</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">return_val</span> <span class="o">=</span> <span class="p">(</span>
            <span class="kc">False</span>
            <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="n">result</span> <span class="o">!=</span> <span class="s2">&quot;5C4hrfjw9DjXZTzV3MwzrrAr9P1MJhSrvWGWqi1eSuyUpnhM&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">return_val</span></div>


<div class="viewcode-block" id="Subtensor.get_all_subnets_info">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_all_subnets_info">[docs]</a>
    <span class="k">def</span> <span class="nf">get_all_subnets_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="s2">&quot;SubnetInfo&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves detailed information about all subnets within the Bittensor network. This function provides</span>
<span class="sd">            comprehensive data on each subnet, including its characteristics and operational parameters.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            block: The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[SubnetInfo]: A list of SubnetInfo objects, each containing detailed information about a subnet.</span>

<span class="sd">        Gaining insights into the subnets&#39; details assists in understanding the network&#39;s composition, the roles of</span>
<span class="sd">            different subnets, and their unique features.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_runtime_api</span><span class="p">(</span>
            <span class="n">runtime_api</span><span class="o">=</span><span class="s2">&quot;SubnetInfoRuntimeApi&quot;</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;get_subnets_info_v2&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[],</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SubnetInfo</span><span class="o">.</span><span class="n">list_from_dicts</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_balance">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_balance">[docs]</a>
    <span class="k">def</span> <span class="nf">get_balance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Balance</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the balance for given coldkey.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            address (str): coldkey address.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Balance object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">balance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;System&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;Account&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">address</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">Balance</span><span class="p">(</span><span class="n">balance</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">][</span><span class="s2">&quot;free&quot;</span><span class="p">])</span></div>


<div class="viewcode-block" id="Subtensor.get_balances">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_balances">[docs]</a>
    <span class="k">def</span> <span class="nf">get_balances</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">addresses</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Balance</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the balance for given coldkey(s)</span>

<span class="sd">        Arguments:</span>
<span class="sd">            addresses (str): coldkey addresses(s).</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dict of {address: Balance objects}.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">block_hash</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)):</span>
            <span class="n">block_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_chain_head</span><span class="p">()</span>
        <span class="n">calls</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">create_storage_key</span><span class="p">(</span>
                    <span class="s2">&quot;System&quot;</span><span class="p">,</span> <span class="s2">&quot;Account&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">address</span><span class="p">],</span> <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">address</span> <span class="ow">in</span> <span class="n">addresses</span>
        <span class="p">]</span>
        <span class="n">batch_call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query_multi</span><span class="p">(</span><span class="n">calls</span><span class="p">,</span> <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">batch_call</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="p">{</span><span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;free&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}}</span>
            <span class="n">results</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">Balance</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">][</span><span class="s2">&quot;free&quot;</span><span class="p">])})</span>
        <span class="k">return</span> <span class="n">results</span></div>


<div class="viewcode-block" id="Subtensor.get_current_block">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_current_block">[docs]</a>
    <span class="k">def</span> <span class="nf">get_current_block</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the current block number on the Bittensor blockchain. This function provides the latest block number,</span>
<span class="sd">            indicating the most recent state of the blockchain.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: The current chain block number.</span>

<span class="sd">        Knowing the current block number is essential for querying real-time data and performing time-sensitive</span>
<span class="sd">            operations on the blockchain. It serves as a reference point for network activities and data</span>
<span class="sd">            synchronization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_block_number</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span></div>


    <span class="nd">@lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">128</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_get_block_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_block_hash</span><span class="p">(</span><span class="n">block_id</span><span class="p">)</span>

<div class="viewcode-block" id="Subtensor.get_block_hash">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_block_hash">[docs]</a>
    <span class="k">def</span> <span class="nf">get_block_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the hash of a specific block on the Bittensor blockchain. The block hash is a unique identifier</span>
<span class="sd">            representing the cryptographic hash of the block&#39;s content, ensuring its integrity and immutability.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            block (int): The block number for which the hash is to be retrieved.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: The cryptographic hash of the specified block.</span>

<span class="sd">        The block hash is a fundamental aspect of blockchain technology, providing a secure reference to each block&#39;s</span>
<span class="sd">            data. It is crucial for verifying transactions, ensuring data consistency, and maintaining the</span>
<span class="sd">            trustworthiness of the blockchain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">block</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_chain_head</span><span class="p">()</span></div>


<div class="viewcode-block" id="Subtensor.determine_block_hash">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.determine_block_hash">[docs]</a>
    <span class="k">def</span> <span class="nf">determine_block_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_block_hash</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.encode_params">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.encode_params">[docs]</a>
    <span class="k">def</span> <span class="nf">encode_params</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">call_definition</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="s2">&quot;ParamWithTypes&quot;</span><span class="p">]],</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a hex encoded string of the params using their types.&quot;&quot;&quot;</span>
        <span class="n">param_data</span> <span class="o">=</span> <span class="n">scalecodec</span><span class="o">.</span><span class="n">ScaleBytes</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">call_definition</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">]):</span>
            <span class="n">scale_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">create_scale_object</span><span class="p">(</span><span class="n">param</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">param_data</span> <span class="o">+=</span> <span class="n">scale_obj</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">param</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Missing param </span><span class="si">{</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> in params dict.&quot;</span><span class="p">)</span>

                <span class="n">param_data</span> <span class="o">+=</span> <span class="n">scale_obj</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">param</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]])</span>

        <span class="k">return</span> <span class="n">param_data</span><span class="o">.</span><span class="n">to_hex</span><span class="p">()</span></div>


<div class="viewcode-block" id="Subtensor.get_hyperparameter">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_hyperparameter">[docs]</a>
    <span class="k">def</span> <span class="nf">get_hyperparameter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">param_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a specified hyperparameter for a specific subnet.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            param_name (str): The name of the hyperparameter to retrieve.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block: the block number at which to retrieve the hyperparameter.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The value of the specified hyperparameter if the subnet exists, or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">block_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">subnet_exists</span><span class="p">(</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">):</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;subnet </span><span class="si">{</span><span class="n">netuid</span><span class="si">}</span><span class="s2"> does not exist&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="n">param_name</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_children">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_children">[docs]</a>
    <span class="k">def</span> <span class="nf">get_children</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hotkey</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method retrieves the children of a given hotkey and netuid. It queries the SubtensorModule&#39;s ChildKeys</span>
<span class="sd">            storage function to get the children and formats them before returning as a tuple.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            hotkey (str): The hotkey value.</span>
<span class="sd">            netuid (int): The netuid value.</span>
<span class="sd">            block (Optional[int]): The block number for which the children are to be retrieved.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A tuple containing a boolean indicating success or failure, a list of formatted children, and an error</span>
<span class="sd">                message (if applicable)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">children</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
                <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
                <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;ChildKeys&quot;</span><span class="p">,</span>
                <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">hotkey</span><span class="p">,</span> <span class="n">netuid</span><span class="p">],</span>
                <span class="n">block_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">children</span><span class="p">:</span>
                <span class="n">formatted_children</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">proportion</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                    <span class="c1"># Convert U64 to int</span>
                    <span class="n">formatted_child</span> <span class="o">=</span> <span class="n">decode_account_id</span><span class="p">(</span><span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">normalized_proportion</span> <span class="o">=</span> <span class="n">u64_normalized_float</span><span class="p">(</span><span class="n">proportion</span><span class="p">)</span>
                    <span class="n">formatted_children</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">normalized_proportion</span><span class="p">,</span> <span class="n">formatted_child</span><span class="p">))</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">formatted_children</span><span class="p">,</span> <span class="s2">&quot;&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="p">[],</span> <span class="s2">&quot;&quot;</span>
        <span class="k">except</span> <span class="n">SubstrateRequestException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="p">[],</span> <span class="n">format_error_message</span><span class="p">(</span><span class="n">e</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_commitment">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_commitment">[docs]</a>
    <span class="k">def</span> <span class="nf">get_commitment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">uid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the on-chain commitment for a specific neuron in the Bittensor network.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            uid (int): The unique identifier of the neuron.</span>
<span class="sd">            block (Optional[int]): The block number to retrieve the commitment from. If None, the latest block is used.</span>
<span class="sd">                Default is ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: The commitment data as a string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">metagraph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metagraph</span><span class="p">(</span><span class="n">netuid</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">hotkey</span> <span class="o">=</span> <span class="n">metagraph</span><span class="o">.</span><span class="n">hotkeys</span><span class="p">[</span><span class="n">uid</span><span class="p">]</span>  <span class="c1"># type: ignore</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;Your uid is not in the hotkeys. Please double-check your UID.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span>

        <span class="n">metadata</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">get_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">,</span> <span class="n">hotkey</span><span class="p">,</span> <span class="n">block</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">decode_metadata</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>

        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>


<div class="viewcode-block" id="Subtensor.get_all_commitments">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_all_commitments">[docs]</a>
    <span class="k">def</span> <span class="nf">get_all_commitments</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
        <span class="n">query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_map</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;Commitments&quot;</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;CommitmentOf&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">],</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">id_</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">query</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="n">decode_account_id</span><span class="p">(</span><span class="n">id_</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="n">decode_account_id</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="Subtensor.get_current_weight_commit_info">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_current_weight_commit_info">[docs]</a>
    <span class="k">def</span> <span class="nf">get_current_weight_commit_info</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves CRV3 weight commit information for a specific subnet.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query. Default is ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: A list of commit details, where each entry is a dictionary with keys &#39;who&#39;, &#39;serialized_commit&#39;, and</span>
<span class="sd">            &#39;reveal_round&#39;, or an empty list if no data is found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query_map</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;CRV3WeightCommits&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="n">commits</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">records</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">records</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">WeightCommitInfo</span><span class="o">.</span><span class="n">from_vec_u8</span><span class="p">(</span><span class="n">commit</span><span class="p">)</span> <span class="k">for</span> <span class="n">commit</span> <span class="ow">in</span> <span class="n">commits</span><span class="p">]</span></div>


<div class="viewcode-block" id="Subtensor.get_delegate_by_hotkey">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_delegate_by_hotkey">[docs]</a>
    <span class="k">def</span> <span class="nf">get_delegate_by_hotkey</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;DelegateInfo&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves detailed information about a delegate neuron based on its hotkey. This function provides a</span>
<span class="sd">            comprehensive view of the delegate&#39;s status, including its stakes, nominators, and reward distribution.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            hotkey_ss58 (str): The ``SS58`` address of the delegate&#39;s hotkey.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[DelegateInfo]: Detailed information about the delegate neuron, ``None`` if not found.</span>

<span class="sd">        This function is essential for understanding the roles and influence of delegate neurons within the Bittensor</span>
<span class="sd">            network&#39;s consensus and governance structures.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_runtime_api</span><span class="p">(</span>
            <span class="n">runtime_api</span><span class="o">=</span><span class="s2">&quot;DelegateInfoRuntimeApi&quot;</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;get_delegate&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">hotkey_ss58</span><span class="p">],</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">DelegateInfo</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_delegate_identities">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_delegate_identities">[docs]</a>
    <span class="k">def</span> <span class="nf">get_delegate_identities</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s2">&quot;DelegatesDetails&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fetches delegates identities from the chain and GitHub. Preference is given to chain data, and missing info is</span>
<span class="sd">            filled-in by the info from GitHub. At some point, we want to totally move away from fetching this info from</span>
<span class="sd">            GitHub, but chain data is still limited in that regard.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dict {ss58: DelegatesDetails, ...}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">block_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">DELEGATES_DETAILS_URL</span><span class="p">)</span>
        <span class="n">identities_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query_map</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;Registry&quot;</span><span class="p">,</span> <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;IdentityOf&quot;</span><span class="p">,</span> <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span>
        <span class="p">)</span>

        <span class="n">all_delegates_details</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">ss58_address</span><span class="p">,</span> <span class="n">identity</span> <span class="ow">in</span> <span class="n">identities_info</span><span class="p">:</span>
            <span class="n">all_delegates_details</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="n">decode_account_id</span><span class="p">(</span>
                        <span class="n">ss58_address</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="p">):</span> <span class="n">DelegatesDetails</span><span class="o">.</span><span class="n">from_chain_data</span><span class="p">(</span>
                        <span class="n">decode_hex_identity_dict</span><span class="p">(</span><span class="n">identity</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="s2">&quot;info&quot;</span><span class="p">])</span>
                    <span class="p">)</span>
                <span class="p">}</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">response</span><span class="o">.</span><span class="n">ok</span><span class="p">:</span>
            <span class="n">all_delegates</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">content</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">delegate_hotkey</span><span class="p">,</span> <span class="n">delegate_details</span> <span class="ow">in</span> <span class="n">all_delegates</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">delegate_info</span> <span class="o">=</span> <span class="n">all_delegates_details</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span>
                    <span class="n">delegate_hotkey</span><span class="p">,</span>
                    <span class="n">DelegatesDetails</span><span class="p">(</span>
                        <span class="n">display</span><span class="o">=</span><span class="n">delegate_details</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">),</span>
                        <span class="n">web</span><span class="o">=</span><span class="n">delegate_details</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;url&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">),</span>
                        <span class="n">additional</span><span class="o">=</span><span class="n">delegate_details</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;description&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">),</span>
                        <span class="n">pgp_fingerprint</span><span class="o">=</span><span class="n">delegate_details</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;fingerprint&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">),</span>
                    <span class="p">),</span>
                <span class="p">)</span>
                <span class="n">delegate_info</span><span class="o">.</span><span class="n">display</span> <span class="o">=</span> <span class="n">delegate_info</span><span class="o">.</span><span class="n">display</span> <span class="ow">or</span> <span class="n">delegate_details</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span>
                <span class="p">)</span>
                <span class="n">delegate_info</span><span class="o">.</span><span class="n">web</span> <span class="o">=</span> <span class="n">delegate_info</span><span class="o">.</span><span class="n">web</span> <span class="ow">or</span> <span class="n">delegate_details</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;url&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="n">delegate_info</span><span class="o">.</span><span class="n">additional</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">delegate_info</span><span class="o">.</span><span class="n">additional</span> <span class="ow">or</span> <span class="n">delegate_details</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;description&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">delegate_info</span><span class="o">.</span><span class="n">pgp_fingerprint</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">delegate_info</span><span class="o">.</span><span class="n">pgp_fingerprint</span>
                    <span class="ow">or</span> <span class="n">delegate_details</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;fingerprint&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">all_delegates_details</span></div>


<div class="viewcode-block" id="Subtensor.get_delegate_take">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_delegate_take">[docs]</a>
    <span class="k">def</span> <span class="nf">get_delegate_take</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the delegate &#39;take&#39; percentage for a neuron identified by its hotkey. The &#39;take&#39; represents the</span>
<span class="sd">            percentage of rewards that the delegate claims from its nominators&#39; stakes.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            hotkey_ss58 (str): The ``SS58`` address of the neuron&#39;s hotkey.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[float]: The delegate take percentage, None if not available.</span>

<span class="sd">        The delegate take is a critical parameter in the network&#39;s incentive structure, influencing the distribution of</span>
<span class="sd">            rewards among neurons and their nominators.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_subtensor</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Delegates&quot;</span><span class="p">,</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">hotkey_ss58</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="kc">None</span>
            <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="n">u16_normalized_float</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_delegated">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_delegated">[docs]</a>
    <span class="k">def</span> <span class="nf">get_delegated</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">coldkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="s2">&quot;DelegateInfo&quot;</span><span class="p">,</span> <span class="n">Balance</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a list of delegates and their associated stakes for a given coldkey. This function identifies the</span>
<span class="sd">        delegates that a specific account has staked tokens on.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            coldkey_ss58 (str): The `SS58` address of the account&#39;s coldkey.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of tuples, each containing a delegate&#39;s information and staked amount.</span>

<span class="sd">        This function is important for account holders to understand their stake allocations and their involvement in</span>
<span class="sd">            the network&#39;s delegation and consensus mechanisms.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_runtime_api</span><span class="p">(</span>
            <span class="n">runtime_api</span><span class="o">=</span><span class="s2">&quot;DelegateInfoRuntimeApi&quot;</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;get_delegated&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">coldkey_ss58</span><span class="p">],</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="n">DelegateInfo</span><span class="o">.</span><span class="n">delegated_list_from_dicts</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_delegates">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_delegates">[docs]</a>
    <span class="k">def</span> <span class="nf">get_delegates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="s2">&quot;DelegateInfo&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fetches all delegates on the chain</span>

<span class="sd">        Arguments:</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of DelegateInfo objects, or an empty list if there are no delegates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_runtime_api</span><span class="p">(</span>
            <span class="n">runtime_api</span><span class="o">=</span><span class="s2">&quot;DelegateInfoRuntimeApi&quot;</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;get_delegates&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[],</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">DelegateInfo</span><span class="o">.</span><span class="n">list_from_dicts</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span></div>


<div class="viewcode-block" id="Subtensor.get_existential_deposit">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_existential_deposit">[docs]</a>
    <span class="k">def</span> <span class="nf">get_existential_deposit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Balance</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the existential deposit amount for the Bittensor blockchain.</span>
<span class="sd">        The existential deposit is the minimum amount of TAO required for an account to exist on the blockchain.</span>
<span class="sd">        Accounts with balances below this threshold can be reaped to conserve network resources.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The existential deposit amount.</span>

<span class="sd">        The existential deposit is a fundamental economic parameter in the Bittensor network, ensuring efficient use of</span>
<span class="sd">            storage and preventing the proliferation of dust accounts.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_constant</span><span class="p">(</span>
            <span class="n">module_name</span><span class="o">=</span><span class="s2">&quot;Balances&quot;</span><span class="p">,</span>
            <span class="n">constant_name</span><span class="o">=</span><span class="s2">&quot;ExistentialDeposit&quot;</span><span class="p">,</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unable to retrieve existential deposit amount.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span></div>


<div class="viewcode-block" id="Subtensor.get_hotkey_owner">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_hotkey_owner">[docs]</a>
    <span class="k">def</span> <span class="nf">get_hotkey_owner</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the owner of the given hotkey at a specific block hash.</span>
<span class="sd">        This function queries the blockchain for the owner of the provided hotkey. If the hotkey does not exist at the</span>
<span class="sd">            specified block hash, it returns None.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            hotkey_ss58 (str): The SS58 address of the hotkey.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[str]: The SS58 address of the owner if the hotkey exists, or None if it doesn&#39;t.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hk_owner_query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;Owner&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">hotkey_ss58</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">exists</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">hk_owner_query</span><span class="p">:</span>
            <span class="n">exists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">does_hotkey_exist</span><span class="p">(</span><span class="n">hotkey_ss58</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span>
        <span class="n">hotkey_owner</span> <span class="o">=</span> <span class="n">hk_owner_query</span> <span class="k">if</span> <span class="n">exists</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">hotkey_owner</span></div>


<div class="viewcode-block" id="Subtensor.get_minimum_required_stake">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_minimum_required_stake">[docs]</a>
    <span class="k">def</span> <span class="nf">get_minimum_required_stake</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Balance</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the minimum required stake for nominators in the Subtensor network.</span>
<span class="sd">        This method retries the substrate call up to three times with exponential backoff in case of failures.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Balance: The minimum required stake as a Balance object.</span>

<span class="sd">        Raises:</span>
<span class="sd">            Exception: If the substrate call fails after the maximum number of retries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span> <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;NominatorMinRequiredStake&quot;</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span></div>


<div class="viewcode-block" id="Subtensor.get_metagraph_info">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_metagraph_info">[docs]</a>
    <span class="k">def</span> <span class="nf">get_metagraph_info</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">MetagraphInfo</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the MetagraphInfo dataclass from the node for a single subnet (netuid)</span>

<span class="sd">        Arguments:</span>
<span class="sd">            netuid: The NetUID of the subnet.</span>
<span class="sd">            block: the block number at which to retrieve the hyperparameter. Do not specify if using block_hash or</span>
<span class="sd">                reuse_block</span>

<span class="sd">        Returns:</span>
<span class="sd">            MetagraphInfo dataclass</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">block_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
        <span class="n">query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">runtime_call</span><span class="p">(</span>
            <span class="s2">&quot;SubnetInfoRuntimeApi&quot;</span><span class="p">,</span>
            <span class="s2">&quot;get_metagraph&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">query</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Subnet </span><span class="si">{</span><span class="n">netuid</span><span class="si">}</span><span class="s2"> does not exist.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">MetagraphInfo</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">query</span><span class="o">.</span><span class="n">value</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_all_metagraphs_info">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_all_metagraphs_info">[docs]</a>
    <span class="k">def</span> <span class="nf">get_all_metagraphs_info</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">MetagraphInfo</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a list of MetagraphInfo objects for all subnets</span>

<span class="sd">        Arguments:</span>
<span class="sd">            block: the block number at which to retrieve the hyperparameter. Do not specify if using block_hash or</span>
<span class="sd">                reuse_block</span>

<span class="sd">        Returns:</span>
<span class="sd">            MetagraphInfo dataclass</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">block_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
        <span class="n">query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">runtime_call</span><span class="p">(</span>
            <span class="s2">&quot;SubnetInfoRuntimeApi&quot;</span><span class="p">,</span>
            <span class="s2">&quot;get_all_metagraphs&quot;</span><span class="p">,</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">MetagraphInfo</span><span class="o">.</span><span class="n">list_from_dicts</span><span class="p">(</span><span class="n">query</span><span class="o">.</span><span class="n">value</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_netuids_for_hotkey">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_netuids_for_hotkey">[docs]</a>
    <span class="k">def</span> <span class="nf">get_netuids_for_hotkey</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a list of subnet UIDs (netuids) for which a given hotkey is a member. This function identifies the</span>
<span class="sd">            specific subnets within the Bittensor network where the neuron associated with the hotkey is active.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            hotkey_ss58 (str): The ``SS58`` address of the neuron&#39;s hotkey.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of netuids where the neuron is a member.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query_map</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;IsNetworkMember&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">hotkey_ss58</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">netuids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">records</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">record</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                    <span class="n">netuids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">record</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">netuids</span></div>


<div class="viewcode-block" id="Subtensor.get_neuron_certificate">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_neuron_certificate">[docs]</a>
    <span class="k">def</span> <span class="nf">get_neuron_certificate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hotkey</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Certificate</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the TLS certificate for a specific neuron identified by its unique identifier (UID) within a</span>
<span class="sd">            specified subnet (netuid) of the Bittensor network.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            hotkey: The hotkey to query.</span>
<span class="sd">            netuid: The unique identifier of the subnet.</span>
<span class="sd">            block: The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the certificate of the neuron if found, `None` otherwise.</span>

<span class="sd">        This function is used for certificate discovery for setting up mutual tls communication between neurons.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">certificate_query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_module</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;NeuronCertificates&quot;</span><span class="p">,</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">,</span> <span class="n">hotkey</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">certificate_query</span><span class="p">:</span>
                <span class="n">certificate</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">certificate_query</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">Certificate</span><span class="p">(</span><span class="n">certificate</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Subtensor.get_neuron_for_pubkey_and_subnet">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_neuron_for_pubkey_and_subnet">[docs]</a>
    <span class="k">def</span> <span class="nf">get_neuron_for_pubkey_and_subnet</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;NeuronInfo&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves information about a neuron based on its public key (hotkey SS58 address) and the specific subnet UID</span>
<span class="sd">            (netuid). This function provides detailed neuron information for a particular subnet within the Bittensor</span>
<span class="sd">            network.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            hotkey_ss58 (str): The ``SS58`` address of the neuron&#39;s hotkey.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[bittensor.core.chain_data.neuron_info.NeuronInfo]: Detailed information about the neuron if found,</span>
<span class="sd">                ``None`` otherwise.</span>

<span class="sd">        This function is crucial for accessing specific neuron data and understanding its status, stake, and other</span>
<span class="sd">            attributes within a particular subnet of the Bittensor ecosystem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">block_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
        <span class="n">uid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;Uids&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">uid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">NeuronInfo</span><span class="o">.</span><span class="n">get_null_neuron</span><span class="p">()</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_runtime_api</span><span class="p">(</span>
            <span class="n">runtime_api</span><span class="o">=</span><span class="s2">&quot;NeuronInfoRuntimeApi&quot;</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;get_neuron&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">,</span> <span class="n">uid</span><span class="o">.</span><span class="n">value</span><span class="p">],</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">NeuronInfo</span><span class="o">.</span><span class="n">get_null_neuron</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">NeuronInfo</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_stake">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_stake">[docs]</a>
    <span class="k">def</span> <span class="nf">get_stake</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">coldkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Balance</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the stake under a coldkey - hotkey pairing.</span>

<span class="sd">        Args:</span>
<span class="sd">            hotkey_ss58 (str): The SS58 address of the hotkey.</span>
<span class="sd">            coldkey_ss58 (str): The SS58 address of the coldkey.</span>
<span class="sd">            netuid (int): The subnet ID</span>
<span class="sd">            block (Optional[int]): The block number at which to query the stake information.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Balance: The stake under the coldkey - hotkey pairing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alpha_shares_query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_module</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Alpha&quot;</span><span class="p">,</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">hotkey_ss58</span><span class="p">,</span> <span class="n">coldkey_ss58</span><span class="p">,</span> <span class="n">netuid</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">alpha_shares</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">FixedPoint</span><span class="p">,</span> <span class="n">alpha_shares_query</span><span class="p">)</span>

        <span class="n">hotkey_alpha_obj</span><span class="p">:</span> <span class="n">ScaleObj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_module</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;TotalHotkeyAlpha&quot;</span><span class="p">,</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">hotkey_ss58</span><span class="p">,</span> <span class="n">netuid</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">hotkey_alpha</span> <span class="o">=</span> <span class="n">hotkey_alpha_obj</span><span class="o">.</span><span class="n">value</span>

        <span class="n">hotkey_shares_query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_module</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;TotalHotkeyShares&quot;</span><span class="p">,</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">hotkey_ss58</span><span class="p">,</span> <span class="n">netuid</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">hotkey_shares</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">FixedPoint</span><span class="p">,</span> <span class="n">hotkey_shares_query</span><span class="p">)</span>

        <span class="n">alpha_shares_as_float</span> <span class="o">=</span> <span class="n">fixed_to_float</span><span class="p">(</span><span class="n">alpha_shares</span><span class="p">)</span>
        <span class="n">hotkey_shares_as_float</span> <span class="o">=</span> <span class="n">fixed_to_float</span><span class="p">(</span><span class="n">hotkey_shares</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">hotkey_shares_as_float</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">set_unit</span><span class="p">(</span><span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">)</span>

        <span class="n">stake</span> <span class="o">=</span> <span class="n">alpha_shares_as_float</span> <span class="o">/</span> <span class="n">hotkey_shares_as_float</span> <span class="o">*</span> <span class="n">hotkey_alpha</span>

        <span class="k">return</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">stake</span><span class="p">))</span><span class="o">.</span><span class="n">set_unit</span><span class="p">(</span><span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_stake_for_coldkey_and_hotkey">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_stake_for_coldkey_and_hotkey">[docs]</a>
    <span class="k">def</span> <span class="nf">get_stake_for_coldkey_and_hotkey</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">coldkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">netuids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">StakeInfo</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves all coldkey-hotkey pairing stake across specified (or all) subnets</span>

<span class="sd">        Arguments:</span>
<span class="sd">            coldkey_ss58 (str): The SS58 address of the coldkey.</span>
<span class="sd">            hotkey_ss58 (str): The SS58 address of the hotkey.</span>
<span class="sd">            netuids (Optional[list[int]]): The subnet IDs to query for. Set to `None` for all subnets.</span>
<span class="sd">            block (Optional[int]): The block number at which to query the stake information.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A {netuid: StakeInfo} pairing of all stakes across all subnets.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">netuids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">all_netuids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_subnets</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">all_netuids</span> <span class="o">=</span> <span class="n">netuids</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">query_runtime_api</span><span class="p">(</span>
                <span class="s2">&quot;StakeInfoRuntimeApi&quot;</span><span class="p">,</span>
                <span class="s2">&quot;get_stake_info_for_hotkey_coldkey_netuid&quot;</span><span class="p">,</span>
                <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">hotkey_ss58</span><span class="p">,</span> <span class="n">coldkey_ss58</span><span class="p">,</span> <span class="n">netuid</span><span class="p">],</span>
                <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">netuid</span> <span class="ow">in</span> <span class="n">all_netuids</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="n">netuid</span><span class="p">:</span> <span class="n">StakeInfo</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">netuid</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">all_netuids</span><span class="p">,</span> <span class="n">results</span><span class="p">)</span>
        <span class="p">}</span></div>


<div class="viewcode-block" id="Subtensor.get_stake_for_coldkey">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_stake_for_coldkey">[docs]</a>
    <span class="k">def</span> <span class="nf">get_stake_for_coldkey</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">coldkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="s2">&quot;StakeInfo&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the stake information for a given coldkey.</span>

<span class="sd">        Args:</span>
<span class="sd">            coldkey_ss58 (str): The SS58 address of the coldkey.</span>
<span class="sd">            block (Optional[int]): The block number at which to query the stake information.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[list[StakeInfo]]: A list of StakeInfo objects, or ``None`` if no stake information is found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_runtime_api</span><span class="p">(</span>
            <span class="n">runtime_api</span><span class="o">=</span><span class="s2">&quot;StakeInfoRuntimeApi&quot;</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;get_stake_info_for_coldkey&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">coldkey_ss58</span><span class="p">],</span>  <span class="c1"># type: ignore</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">stakes</span> <span class="o">=</span> <span class="n">StakeInfo</span><span class="o">.</span><span class="n">list_from_dicts</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">stake</span> <span class="k">for</span> <span class="n">stake</span> <span class="ow">in</span> <span class="n">stakes</span> <span class="k">if</span> <span class="n">stake</span><span class="o">.</span><span class="n">stake</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span></div>


    <span class="n">get_stake_info_for_coldkey</span> <span class="o">=</span> <span class="n">get_stake_for_coldkey</span>

<div class="viewcode-block" id="Subtensor.get_stake_for_hotkey">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_stake_for_hotkey">[docs]</a>
    <span class="k">def</span> <span class="nf">get_stake_for_hotkey</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Balance</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the stake information for a given hotkey.</span>

<span class="sd">        Args:</span>
<span class="sd">            hotkey_ss58: The SS58 address of the hotkey.</span>
<span class="sd">            netuid: The subnet ID to query for.</span>
<span class="sd">            block: The block number at which to query the stake information. Do not specify if also specifying</span>
<span class="sd">                block_hash or reuse_block</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hotkey_alpha_query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_subtensor</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;TotalHotkeyAlpha&quot;</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">hotkey_ss58</span><span class="p">,</span> <span class="n">netuid</span><span class="p">],</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span>
        <span class="p">)</span>
        <span class="n">hotkey_alpha</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">ScaleObj</span><span class="p">,</span> <span class="n">hotkey_alpha_query</span><span class="p">)</span>
        <span class="n">balance</span> <span class="o">=</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="n">hotkey_alpha</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="n">balance</span><span class="o">.</span><span class="n">set_unit</span><span class="p">(</span><span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">balance</span></div>


    <span class="n">get_hotkey_stake</span> <span class="o">=</span> <span class="n">get_stake_for_hotkey</span>

<div class="viewcode-block" id="Subtensor.get_subnet_burn_cost">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_subnet_burn_cost">[docs]</a>
    <span class="k">def</span> <span class="nf">get_subnet_burn_cost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Balance</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the burn cost for registering a new subnet within the Bittensor network. This cost represents the</span>
<span class="sd">            amount of Tao that needs to be locked or burned to establish a new subnet.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: The burn cost for subnet registration.</span>

<span class="sd">        The subnet burn cost is an important economic parameter, reflecting the network&#39;s mechanisms for controlling</span>
<span class="sd">            the proliferation of subnets and ensuring their commitment to the network&#39;s long-term viability.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lock_cost</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_runtime_api</span><span class="p">(</span>
            <span class="n">runtime_api</span><span class="o">=</span><span class="s2">&quot;SubnetRegistrationRuntimeApi&quot;</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;get_network_registration_cost&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[],</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">lock_cost</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="n">lock_cost</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">lock_cost</span></div>


<div class="viewcode-block" id="Subtensor.get_subnet_hyperparameters">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_subnet_hyperparameters">[docs]</a>
    <span class="k">def</span> <span class="nf">get_subnet_hyperparameters</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="s2">&quot;SubnetHyperparameters&quot;</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the hyperparameters for a specific subnet within the Bittensor network. These hyperparameters define</span>
<span class="sd">            the operational settings and rules governing the subnet&#39;s behavior.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            netuid (int): The network UID of the subnet to query.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The subnet&#39;s hyperparameters, or `None` if not available.</span>

<span class="sd">        Understanding the hyperparameters is crucial for comprehending how subnets are configured and managed, and how</span>
<span class="sd">            they interact with the network&#39;s consensus and incentive mechanisms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_runtime_api</span><span class="p">(</span>
            <span class="n">runtime_api</span><span class="o">=</span><span class="s2">&quot;SubnetInfoRuntimeApi&quot;</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;get_subnet_hyperparams&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">],</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">SubnetHyperparameters</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_subnet_reveal_period_epochs">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_subnet_reveal_period_epochs">[docs]</a>
    <span class="k">def</span> <span class="nf">get_subnet_reveal_period_epochs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve the SubnetRevealPeriodEpochs hyperparameter.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cast</span><span class="p">(</span>
            <span class="nb">int</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_hyperparameter</span><span class="p">(</span>
                <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;RevealPeriodEpochs&quot;</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span>
            <span class="p">),</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_subnets">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_subnets">[docs]</a>
    <span class="k">def</span> <span class="nf">get_subnets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the list of all subnet unique identifiers (netuids) currently present in the Bittensor network.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of subnet netuids.</span>

<span class="sd">        This function provides a comprehensive view of the subnets within the Bittensor network,</span>
<span class="sd">        offering insights into its diversity and scale.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query_map</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;NetworksAdded&quot;</span><span class="p">,</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">subnets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">records</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">netuid</span><span class="p">,</span> <span class="n">exists</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">exists</span><span class="p">:</span>
                    <span class="n">subnets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">netuid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">subnets</span></div>


<div class="viewcode-block" id="Subtensor.get_total_subnets">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_total_subnets">[docs]</a>
    <span class="k">def</span> <span class="nf">get_total_subnets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the total number of subnets within the Bittensor network as of a specific blockchain block.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[str]: The total number of subnets in the network.</span>

<span class="sd">        Understanding the total number of subnets is essential for assessing the network&#39;s growth and the extent of its</span>
<span class="sd">            decentralized infrastructure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;TotalNetworks&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_transfer_fee">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_transfer_fee">[docs]</a>
    <span class="k">def</span> <span class="nf">get_transfer_fee</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Balance</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Balance</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the transaction fee for transferring tokens from a wallet to a specified destination address. This</span>
<span class="sd">            function simulates the transfer to estimate the associated cost, taking into account the current network</span>
<span class="sd">            conditions and transaction complexity.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): The wallet from which the transfer is initiated.</span>
<span class="sd">            dest (str): The ``SS58`` address of the destination account.</span>
<span class="sd">            value (Union[bittensor.utils.balance.Balance, float, int]): The amount of tokens to be transferred,</span>
<span class="sd">                specified as a Balance object, or in Tao (float) or Rao (int) units.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bittensor.utils.balance.Balance: The estimated transaction fee for the transfer, represented as a Balance</span>
<span class="sd">                object.</span>

<span class="sd">        Estimating the transfer fee is essential for planning and executing token transactions, ensuring that the wallet</span>
<span class="sd">            has sufficient funds to cover both the transfer amount and the associated costs. This function provides a</span>
<span class="sd">            crucial tool for managing financial operations within the Bittensor network.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">check_and_convert_to_balance</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">compose_call</span><span class="p">(</span>
            <span class="n">call_module</span><span class="o">=</span><span class="s2">&quot;Balances&quot;</span><span class="p">,</span>
            <span class="n">call_function</span><span class="o">=</span><span class="s2">&quot;transfer_allow_death&quot;</span><span class="p">,</span>
            <span class="n">call_params</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;dest&quot;</span><span class="p">:</span> <span class="n">dest</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">value</span><span class="o">.</span><span class="n">rao</span><span class="p">},</span>
        <span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">payment_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_payment_info</span><span class="p">(</span>
                <span class="n">call</span><span class="o">=</span><span class="n">call</span><span class="p">,</span> <span class="n">keypair</span><span class="o">=</span><span class="n">wallet</span><span class="o">.</span><span class="n">coldkeypub</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;:cross_mark: [red]Failed to get payment info: [/red]</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">payment_info</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;partial_fee&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="mf">2e7</span><span class="p">)}</span>  <span class="c1"># assume  0.02 Tao</span>

        <span class="k">return</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="n">payment_info</span><span class="p">[</span><span class="s2">&quot;partial_fee&quot;</span><span class="p">])</span></div>


<div class="viewcode-block" id="Subtensor.get_vote_data">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_vote_data">[docs]</a>
    <span class="k">def</span> <span class="nf">get_vote_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">proposal_hash</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;ProposalVoteData&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the voting data for a specific proposal on the Bittensor blockchain. This data includes information</span>
<span class="sd">            about how senate members have voted on the proposal.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            proposal_hash (str): The hash of the proposal for which voting data is requested.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            An object containing the proposal&#39;s voting data, or `None` if not found.</span>

<span class="sd">        This function is important for tracking and understanding the decision-making processes within the Bittensor</span>
<span class="sd">            network, particularly how proposals are received and acted upon by the governing body.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vote_data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;Triumvirate&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;Voting&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">proposal_hash</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">vote_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ProposalVoteData</span><span class="p">(</span><span class="n">vote_data</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_uid_for_hotkey_on_subnet">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_uid_for_hotkey_on_subnet">[docs]</a>
    <span class="k">def</span> <span class="nf">get_uid_for_hotkey_on_subnet</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the unique identifier (UID) for a neuron&#39;s hotkey on a specific subnet.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            hotkey_ss58 (str): The ``SS58`` address of the neuron&#39;s hotkey.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The UID of the neuron if it is registered on the subnet, ``None`` otherwise.</span>

<span class="sd">        The UID is a critical identifier within the network, linking the neuron&#39;s hotkey to its operational and</span>
<span class="sd">            governance activities on a particular subnet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;Uids&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.filter_netuids_by_registered_hotkeys">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.filter_netuids_by_registered_hotkeys">[docs]</a>
    <span class="k">def</span> <span class="nf">filter_netuids_by_registered_hotkeys</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">all_netuids</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">filter_for_netuids</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">all_hotkeys</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="s2">&quot;Wallet&quot;</span><span class="p">],</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filters a given list of all netuids for certain specified netuids and hotkeys</span>

<span class="sd">        Arguments:</span>
<span class="sd">            all_netuids (Iterable[int]): A list of netuids to filter.</span>
<span class="sd">            filter_for_netuids (Iterable[int]): A subset of all_netuids to filter from the main list.</span>
<span class="sd">            all_hotkeys (Iterable[Wallet]): Hotkeys to filter from the main list.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The filtered list of netuids.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_get_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>  <span class="c1"># just used to cache the block hash</span>
        <span class="n">netuids_with_registered_hotkeys</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">item</span>
            <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_netuids_for_hotkey</span><span class="p">(</span>
                    <span class="n">wallet</span><span class="o">.</span><span class="n">hotkey</span><span class="o">.</span><span class="n">ss58_address</span><span class="p">,</span>
                    <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">wallet</span> <span class="ow">in</span> <span class="n">all_hotkeys</span>
            <span class="p">]</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sublist</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">filter_for_netuids</span><span class="p">:</span>
            <span class="n">all_netuids</span> <span class="o">=</span> <span class="n">netuids_with_registered_hotkeys</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">filtered_netuids</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">netuid</span> <span class="k">for</span> <span class="n">netuid</span> <span class="ow">in</span> <span class="n">all_netuids</span> <span class="k">if</span> <span class="n">netuid</span> <span class="ow">in</span> <span class="n">filter_for_netuids</span>
            <span class="p">]</span>

            <span class="n">registered_hotkeys_filtered</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">netuid</span>
                <span class="k">for</span> <span class="n">netuid</span> <span class="ow">in</span> <span class="n">netuids_with_registered_hotkeys</span>
                <span class="k">if</span> <span class="n">netuid</span> <span class="ow">in</span> <span class="n">filter_for_netuids</span>
            <span class="p">]</span>

            <span class="c1"># Combine both filtered lists</span>
            <span class="n">all_netuids</span> <span class="o">=</span> <span class="n">filtered_netuids</span> <span class="o">+</span> <span class="n">registered_hotkeys_filtered</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">all_netuids</span><span class="p">))</span></div>


<div class="viewcode-block" id="Subtensor.immunity_period">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.immunity_period">[docs]</a>
    <span class="k">def</span> <span class="nf">immunity_period</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the &#39;ImmunityPeriod&#39; hyperparameter for a specific subnet. This parameter defines the duration during</span>
<span class="sd">            which new neurons are protected from certain network penalties or restrictions.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The value of the &#39;ImmunityPeriod&#39; hyperparameter if the subnet exists, ``None`` otherwise.</span>

<span class="sd">        The &#39;ImmunityPeriod&#39; is a critical aspect of the network&#39;s governance system, ensuring that new participants</span>
<span class="sd">            have a grace period to establish themselves and contribute to the network without facing immediate</span>
<span class="sd">            punitive actions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hyperparameter</span><span class="p">(</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;ImmunityPeriod&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.is_hotkey_delegate">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.is_hotkey_delegate">[docs]</a>
    <span class="k">def</span> <span class="nf">is_hotkey_delegate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines whether a given hotkey (public key) is a delegate on the Bittensor network. This function checks if</span>
<span class="sd">            the neuron associated with the hotkey is part of the network&#39;s delegation system.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            hotkey_ss58 (str): The SS58 address of the neuron&#39;s hotkey.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            `True` if the hotkey is a delegate, `False` otherwise.</span>

<span class="sd">        Being a delegate is a significant status within the Bittensor network, indicating a neuron&#39;s involvement in</span>
<span class="sd">            consensus and governance processes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">delegates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_delegates</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hotkey_ss58</span> <span class="ow">in</span> <span class="p">[</span><span class="n">info</span><span class="o">.</span><span class="n">hotkey_ss58</span> <span class="k">for</span> <span class="n">info</span> <span class="ow">in</span> <span class="n">delegates</span><span class="p">]</span></div>


<div class="viewcode-block" id="Subtensor.is_hotkey_registered">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.is_hotkey_registered">[docs]</a>
    <span class="k">def</span> <span class="nf">is_hotkey_registered</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines whether a given hotkey (public key) is registered in the Bittensor network, either globally across</span>
<span class="sd">            any subnet or specifically on a specified subnet. This function checks the registration status of a neuron</span>
<span class="sd">            identified by its hotkey, which is crucial for validating its participation and activities within the</span>
<span class="sd">            network.</span>

<span class="sd">        Args:</span>
<span class="sd">            hotkey_ss58: The SS58 address of the neuron&#39;s hotkey.</span>
<span class="sd">            netuid: The unique identifier of the subnet to check the registration. If `None`, the</span>
<span class="sd">                registration is checked across all subnets.</span>
<span class="sd">            block: The blockchain block number at which to perform the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: `True` if the hotkey is registered in the specified context (either any subnet or a specific subnet),</span>
<span class="sd">                `False` otherwise.</span>

<span class="sd">        This function is important for verifying the active status of neurons in the Bittensor network. It aids in</span>
<span class="sd">            understanding whether a neuron is eligible to participate in network processes such as consensus,</span>
<span class="sd">            validation, and incentive distribution based on its registration status.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">netuid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_hotkey_registered_any</span><span class="p">(</span><span class="n">hotkey_ss58</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_hotkey_registered_on_subnet</span><span class="p">(</span><span class="n">hotkey_ss58</span><span class="p">,</span> <span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.is_hotkey_registered_any">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.is_hotkey_registered_any">[docs]</a>
    <span class="k">def</span> <span class="nf">is_hotkey_registered_any</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if a neuron&#39;s hotkey is registered on any subnet within the Bittensor network.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            hotkey_ss58 (str): The ``SS58`` address of the neuron&#39;s hotkey.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the hotkey is registered on any subnet, False otherwise.</span>

<span class="sd">        This function is essential for determining the network-wide presence and participation of a neuron.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hotkeys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_netuids_for_hotkey</span><span class="p">(</span><span class="n">hotkey_ss58</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">hotkeys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="Subtensor.is_hotkey_registered_on_subnet">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.is_hotkey_registered_on_subnet">[docs]</a>
    <span class="k">def</span> <span class="nf">is_hotkey_registered_on_subnet</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Checks if the hotkey is registered on a given netuid.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_uid_for_hotkey_on_subnet</span><span class="p">(</span><span class="n">hotkey_ss58</span><span class="p">,</span> <span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span>
            <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.last_drand_round">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.last_drand_round">[docs]</a>
    <span class="k">def</span> <span class="nf">last_drand_round</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the last drand round emitted in bittensor. This corresponds when committed weights will be revealed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: The latest Drand round emitted in bittensor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;Drand&quot;</span><span class="p">,</span> <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;LastStoredRound&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.max_weight_limit">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.max_weight_limit">[docs]</a>
    <span class="k">def</span> <span class="nf">max_weight_limit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns network MaxWeightsLimit hyperparameter.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[float]: The value of the MaxWeightsLimit hyperparameter, or ``None`` if the subnetwork does not</span>
<span class="sd">                exist or the parameter is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hyperparameter</span><span class="p">(</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;MaxWeightsLimit&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">u16_normalized_float</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">))</span></div>


<div class="viewcode-block" id="Subtensor.metagraph">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.metagraph">[docs]</a>
    <span class="k">def</span> <span class="nf">metagraph</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">lite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Metagraph&quot;</span><span class="p">:</span>
        <span class="n">metagraph</span> <span class="o">=</span> <span class="n">Metagraph</span><span class="p">(</span>
            <span class="n">network</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_endpoint</span><span class="p">,</span>
            <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
            <span class="n">lite</span><span class="o">=</span><span class="n">lite</span><span class="p">,</span>
            <span class="n">sync</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">metagraph</span><span class="o">.</span><span class="n">sync</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span> <span class="n">lite</span><span class="o">=</span><span class="n">lite</span><span class="p">,</span> <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">metagraph</span></div>


<div class="viewcode-block" id="Subtensor.min_allowed_weights">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.min_allowed_weights">[docs]</a>
    <span class="k">def</span> <span class="nf">min_allowed_weights</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns network MinAllowedWeights hyperparameter.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The value of the MinAllowedWeights hyperparameter, or ``None`` if the subnetwork does not</span>
<span class="sd">                exist or the parameter is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hyperparameter</span><span class="p">(</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;MinAllowedWeights&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.neuron_for_uid">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.neuron_for_uid">[docs]</a>
    <span class="k">def</span> <span class="nf">neuron_for_uid</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">uid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;NeuronInfo&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves detailed information about a specific neuron identified by its unique identifier (UID) within a</span>
<span class="sd">            specified subnet (netuid) of the Bittensor network. This function provides a comprehensive view of a</span>
<span class="sd">            neuron&#39;s attributes, including its stake, rank, and operational status.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            uid (int): The unique identifier of the neuron.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Detailed information about the neuron if found, a null neuron otherwise</span>

<span class="sd">        This function is crucial for analyzing individual neurons&#39; contributions and status within a specific subnet,</span>
<span class="sd">            offering insights into their roles in the network&#39;s consensus and validation mechanisms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">uid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">NeuronInfo</span><span class="o">.</span><span class="n">get_null_neuron</span><span class="p">()</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_runtime_api</span><span class="p">(</span>
            <span class="n">runtime_api</span><span class="o">=</span><span class="s2">&quot;NeuronInfoRuntimeApi&quot;</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;get_neuron&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">,</span> <span class="n">uid</span><span class="p">],</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">NeuronInfo</span><span class="o">.</span><span class="n">get_null_neuron</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">NeuronInfo</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.neurons">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.neurons">[docs]</a>
    <span class="k">def</span> <span class="nf">neurons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="s2">&quot;NeuronInfo&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a list of all neurons within a specified subnet of the Bittensor network.</span>
<span class="sd">        This function provides a snapshot of the subnet&#39;s neuron population, including each neuron&#39;s attributes and</span>
<span class="sd">            network interactions.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of NeuronInfo objects detailing each neuron&#39;s characteristics in the subnet.</span>

<span class="sd">        Understanding the distribution and status of neurons within a subnet is key to comprehending the network&#39;s</span>
<span class="sd">            decentralized structure and the dynamics of its consensus and governance processes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_runtime_api</span><span class="p">(</span>
            <span class="n">runtime_api</span><span class="o">=</span><span class="s2">&quot;NeuronInfoRuntimeApi&quot;</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;get_neurons&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">],</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="n">NeuronInfo</span><span class="o">.</span><span class="n">list_from_dicts</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.neurons_lite">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.neurons_lite">[docs]</a>
    <span class="k">def</span> <span class="nf">neurons_lite</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="s2">&quot;NeuronInfoLite&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a list of neurons in a &#39;lite&#39; format from a specific subnet of the Bittensor network.</span>
<span class="sd">        This function provides a streamlined view of the neurons, focusing on key attributes such as stake and network</span>
<span class="sd">            participation.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of simplified neuron information for the subnet.</span>

<span class="sd">        This function offers a quick overview of the neuron population within a subnet, facilitating efficient analysis</span>
<span class="sd">            of the network&#39;s decentralized structure and neuron dynamics.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_runtime_api</span><span class="p">(</span>
            <span class="n">runtime_api</span><span class="o">=</span><span class="s2">&quot;NeuronInfoRuntimeApi&quot;</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;get_neurons_lite&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">],</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="n">NeuronInfoLite</span><span class="o">.</span><span class="n">list_from_dicts</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.query_identity">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.query_identity">[docs]</a>
    <span class="k">def</span> <span class="nf">query_identity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coldkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Queries the identity of a neuron on the Bittensor blockchain using the given key. This function retrieves</span>
<span class="sd">            detailed identity information about a specific neuron, which is a crucial aspect of the network&#39;s</span>
<span class="sd">            decentralized identity and governance system.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            coldkey_ss58 (str): The coldkey used to query the neuron&#39;s identity (technically the neuron&#39;s coldkey SS58</span>
<span class="sd">                address).</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            An object containing the identity information of the neuron if found, ``None`` otherwise.</span>

<span class="sd">        The identity information can include various attributes such as the neuron&#39;s stake, rank, and other</span>
<span class="sd">            network-specific details, providing insights into the neuron&#39;s role and status within the Bittensor network.</span>

<span class="sd">        Note:</span>
<span class="sd">            See the `Bittensor CLI documentation &lt;https://docs.bittensor.com/reference/btcli&gt;`_ for supported identity</span>
<span class="sd">                parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">identity_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;IdentitiesV2&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">coldkey_ss58</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">identity_info</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{}</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_decode_hex_identity_dict</span><span class="p">(</span><span class="n">identity_info</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{}</span></div>


<div class="viewcode-block" id="Subtensor.recycle">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.recycle">[docs]</a>
    <span class="k">def</span> <span class="nf">recycle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Balance</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the &#39;Burn&#39; hyperparameter for a specified subnet. The &#39;Burn&#39; parameter represents the amount of Tao</span>
<span class="sd">            that is effectively recycled within the Bittensor network.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[Balance]: The value of the &#39;Burn&#39; hyperparameter if the subnet exists, None otherwise.</span>

<span class="sd">        Understanding the &#39;Burn&#39; rate is essential for analyzing the network registration usage, particularly how it is</span>
<span class="sd">            correlated with user activity and the overall cost of participation in a given subnet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hyperparameter</span><span class="p">(</span><span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;Burn&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">))</span></div>


<div class="viewcode-block" id="Subtensor.subnet">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.subnet">[docs]</a>
    <span class="k">def</span> <span class="nf">subnet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DynamicInfo</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the subnet information for a single subnet in the network.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int]): The block number to query the subnet information from.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[DynamicInfo]: A DynamicInfo object, containing detailed information about a subnet.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">block_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>

        <span class="n">query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">runtime_call</span><span class="p">(</span>
            <span class="s2">&quot;SubnetInfoRuntimeApi&quot;</span><span class="p">,</span>
            <span class="s2">&quot;get_dynamic_info&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">subnet</span> <span class="o">=</span> <span class="n">DynamicInfo</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">query</span><span class="o">.</span><span class="n">decode</span><span class="p">())</span>  <span class="c1"># type: ignore</span>
        <span class="k">return</span> <span class="n">subnet</span></div>


<div class="viewcode-block" id="Subtensor.subnet_exists">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.subnet_exists">[docs]</a>
    <span class="k">def</span> <span class="nf">subnet_exists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if a subnet with the specified unique identifier (netuid) exists within the Bittensor network.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            `True` if the subnet exists, `False` otherwise.</span>

<span class="sd">        This function is critical for verifying the presence of specific subnets in the network,</span>
<span class="sd">        enabling a deeper understanding of the network&#39;s structure and composition.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;NetworksAdded&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.subnetwork_n">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.subnetwork_n">[docs]</a>
    <span class="k">def</span> <span class="nf">subnetwork_n</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns network SubnetworkN hyperparameter.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The value of the SubnetworkN hyperparameter, or ``None`` if the subnetwork does not exist or</span>
<span class="sd">                the parameter is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hyperparameter</span><span class="p">(</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;SubnetworkN&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.tempo">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.tempo">[docs]</a>
    <span class="k">def</span> <span class="nf">tempo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns network Tempo hyperparameter.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The value of the Tempo hyperparameter, or ``None`` if the subnetwork does not exist or the</span>
<span class="sd">                parameter is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hyperparameter</span><span class="p">(</span><span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;Tempo&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.tx_rate_limit">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.tx_rate_limit">[docs]</a>
    <span class="k">def</span> <span class="nf">tx_rate_limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the transaction rate limit for the Bittensor network as of a specific blockchain block.</span>
<span class="sd">        This rate limit sets the maximum number of transactions that can be processed within a given time frame.</span>

<span class="sd">        Args:</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The transaction rate limit of the network, None if not available.</span>

<span class="sd">        The transaction rate limit is an essential parameter for ensuring the stability and scalability of the Bittensor</span>
<span class="sd">            network. It helps in managing network load and preventing congestion, thereby maintaining efficient and</span>
<span class="sd">            timely transaction processing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_subtensor</span><span class="p">(</span><span class="s2">&quot;TxRateLimit&quot;</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.wait_for_block">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.wait_for_block">[docs]</a>
    <span class="k">def</span> <span class="nf">wait_for_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Waits until a specific block is reached on the chain. If no block is specified,</span>
<span class="sd">        waits for the next block.</span>

<span class="sd">        Args:</span>
<span class="sd">            block (Optional[int]): The block number to wait for. If None, waits for next block.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if the target block was reached, False if timeout occurred.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; subtensor.wait_for_block() # Waits for next block</span>
<span class="sd">            &gt;&gt;&gt; subtensor.wait_for_block(block=1234) # Waits for specific block</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">handler</span><span class="p">(</span><span class="n">block_data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;reached block </span><span class="si">{</span><span class="n">block_data</span><span class="p">[</span><span class="s2">&quot;header&quot;</span><span class="p">][</span><span class="s2">&quot;number&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">. Waiting for block </span><span class="si">{</span><span class="n">target_block</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">block_data</span><span class="p">[</span><span class="s2">&quot;header&quot;</span><span class="p">][</span><span class="s2">&quot;number&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">target_block</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>

        <span class="n">current_block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_block</span><span class="p">()</span>
        <span class="n">current_block_hash</span> <span class="o">=</span> <span class="n">current_block</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;header&quot;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;hash&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">target_block</span> <span class="o">=</span> <span class="n">block</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">target_block</span> <span class="o">=</span> <span class="n">current_block</span><span class="p">[</span><span class="s2">&quot;header&quot;</span><span class="p">][</span><span class="s2">&quot;number&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">_get_block_handler</span><span class="p">(</span>
            <span class="n">current_block_hash</span><span class="p">,</span> <span class="n">header_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">subscription_handler</span><span class="o">=</span><span class="n">handler</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="Subtensor.weights">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.weights">[docs]</a>
    <span class="k">def</span> <span class="nf">weights</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the weight distribution set by neurons within a specific subnet of the Bittensor network.</span>
<span class="sd">        This function maps each neuron&#39;s UID to the weights it assigns to other neurons, reflecting the network&#39;s trust</span>
<span class="sd">            and value assignment mechanisms.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            netuid (int): The network UID of the subnet to query.</span>
<span class="sd">            block (Optional[int]): Block number for synchronization, or ``None`` for the latest block.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of tuples mapping each neuron&#39;s UID to its assigned weights.</span>

<span class="sd">        The weight distribution is a key factor in the network&#39;s consensus algorithm and the ranking of neurons,</span>
<span class="sd">            influencing their influence and reward allocation within the subnet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">w_map_encoded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query_map</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;Weights&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">w_map</span> <span class="o">=</span> <span class="p">[(</span><span class="n">uid</span><span class="p">,</span> <span class="n">w</span><span class="o">.</span><span class="n">value</span> <span class="ow">or</span> <span class="p">[])</span> <span class="k">for</span> <span class="n">uid</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">w_map_encoded</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">w_map</span></div>


<div class="viewcode-block" id="Subtensor.weights_rate_limit">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.weights_rate_limit">[docs]</a>
    <span class="k">def</span> <span class="nf">weights_rate_limit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns network WeightsSetRateLimit hyperparameter.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The value of the WeightsSetRateLimit hyperparameter, or ``None`` if the subnetwork does not</span>
<span class="sd">                exist or the parameter is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hyperparameter</span><span class="p">(</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;WeightsSetRateLimit&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">)</span></div>


    <span class="c1"># Extrinsics helper ================================================================================================</span>

<div class="viewcode-block" id="Subtensor.sign_and_send_extrinsic">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.sign_and_send_extrinsic">[docs]</a>
    <span class="k">def</span> <span class="nf">sign_and_send_extrinsic</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">call</span><span class="p">:</span> <span class="s2">&quot;GenericCall&quot;</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">sign_with</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;coldkey&quot;</span><span class="p">,</span>
        <span class="n">use_nonce</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">period</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">nonce_key</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;hotkey&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper method to sign and submit an extrinsic call to chain.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            call (scalecodec.types.GenericCall): a prepared Call object</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): the wallet whose coldkey will be used to sign the extrinsic</span>
<span class="sd">            wait_for_inclusion (bool): whether to wait until the extrinsic call is included on the chain</span>
<span class="sd">            wait_for_finalization (bool): whether to wait until the extrinsic call is finalized on the chain</span>
<span class="sd">            sign_with: the wallet&#39;s keypair to use for the signing. Options are &quot;coldkey&quot;, &quot;hotkey&quot;, &quot;coldkeypub&quot;</span>

<span class="sd">        Returns:</span>
<span class="sd">            (success, error message)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">possible_keys</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;coldkey&quot;</span><span class="p">,</span> <span class="s2">&quot;hotkey&quot;</span><span class="p">,</span> <span class="s2">&quot;coldkeypub&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sign_with</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">possible_keys</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;sign_with&#39; must be either &#39;coldkey&#39;, &#39;hotkey&#39; or &#39;coldkeypub&#39;, not &#39;</span><span class="si">{</span><span class="n">sign_with</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
            <span class="p">)</span>

        <span class="n">signing_keypair</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">wallet</span><span class="p">,</span> <span class="n">sign_with</span><span class="p">)</span>
        <span class="n">extrinsic_data</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;call&quot;</span><span class="p">:</span> <span class="n">call</span><span class="p">,</span> <span class="s2">&quot;keypair&quot;</span><span class="p">:</span> <span class="n">signing_keypair</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">use_nonce</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nonce_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">possible_keys</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;&#39;nonce_key&#39; must be either &#39;coldkey&#39;, &#39;hotkey&#39; or &#39;coldkeypub&#39;, not &#39;</span><span class="si">{</span><span class="n">nonce_key</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
                <span class="p">)</span>
            <span class="n">next_nonce</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_account_next_index</span><span class="p">(</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">wallet</span><span class="p">,</span> <span class="n">nonce_key</span><span class="p">)</span><span class="o">.</span><span class="n">ss58_address</span>
            <span class="p">)</span>
            <span class="n">extrinsic_data</span><span class="p">[</span><span class="s2">&quot;nonce&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">next_nonce</span>
        <span class="k">if</span> <span class="n">period</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extrinsic_data</span><span class="p">[</span><span class="s2">&quot;era&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;period&quot;</span><span class="p">:</span> <span class="n">period</span><span class="p">}</span>

        <span class="n">extrinsic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">create_signed_extrinsic</span><span class="p">(</span><span class="o">**</span><span class="n">extrinsic_data</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">submit_extrinsic</span><span class="p">(</span>
                <span class="n">extrinsic</span><span class="p">,</span>
                <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># We only wait here if we expect finalization.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">wait_for_finalization</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">wait_for_inclusion</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;&quot;</span>

            <span class="k">if</span> <span class="n">response</span><span class="o">.</span><span class="n">is_success</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;&quot;</span>

            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">format_error_message</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">error_message</span><span class="p">)</span>

        <span class="k">except</span> <span class="n">SubstrateRequestException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">format_error_message</span><span class="p">(</span><span class="n">e</span><span class="p">)</span></div>


    <span class="c1"># Extrinsics =======================================================================================================</span>

<div class="viewcode-block" id="Subtensor.add_stake">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.add_stake">[docs]</a>
    <span class="k">def</span> <span class="nf">add_stake</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">amount</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Balance</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds the specified amount of stake to a neuron identified by the hotkey ``SS58`` address.</span>
<span class="sd">        Staking is a fundamental process in the Bittensor network that enables neurons to participate actively and earn</span>
<span class="sd">            incentives.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): The wallet to be used for staking.</span>
<span class="sd">            hotkey_ss58 (Optional[str]): The ``SS58`` address of the hotkey associated with the neuron.</span>
<span class="sd">            netuid (Optional[int]): The unique identifier of the subnet to which the neuron belongs.</span>
<span class="sd">            amount (Balance): The amount of TAO to stake.</span>
<span class="sd">            wait_for_inclusion (bool): Waits for the transaction to be included in a block.</span>
<span class="sd">            wait_for_finalization (bool): Waits for the transaction to be finalized on the blockchain.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the staking is successful, False otherwise.</span>

<span class="sd">        This function enables neurons to increase their stake in the network, enhancing their influence and potential</span>
<span class="sd">            rewards in line with Bittensor&#39;s consensus and reward mechanisms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">amount</span> <span class="o">=</span> <span class="n">check_and_convert_to_balance</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">add_stake_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">hotkey_ss58</span><span class="o">=</span><span class="n">hotkey_ss58</span><span class="p">,</span>
            <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
            <span class="n">amount</span><span class="o">=</span><span class="n">amount</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.add_stake_multiple">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.add_stake_multiple">[docs]</a>
    <span class="k">def</span> <span class="nf">add_stake_multiple</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">hotkey_ss58s</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">netuids</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">amounts</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">Balance</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds stakes to multiple neurons identified by their hotkey SS58 addresses.</span>
<span class="sd">        This bulk operation allows for efficient staking across different neurons from a single wallet.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): The wallet used for staking.</span>
<span class="sd">            hotkey_ss58s (list[str]): List of ``SS58`` addresses of hotkeys to stake to.</span>
<span class="sd">            netuids (list[int]): List of network UIDs to stake to.</span>
<span class="sd">            amounts (list[Balance]): Corresponding amounts of TAO to stake for each hotkey.</span>
<span class="sd">            wait_for_inclusion (bool): Waits for the transaction to be included in a block.</span>
<span class="sd">            wait_for_finalization (bool): Waits for the transaction to be finalized on the blockchain.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the staking is successful for all specified neurons, False otherwise.</span>

<span class="sd">        This function is essential for managing stakes across multiple neurons, reflecting the dynamic and collaborative</span>
<span class="sd">            nature of the Bittensor network.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">add_stake_multiple_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">hotkey_ss58s</span><span class="o">=</span><span class="n">hotkey_ss58s</span><span class="p">,</span>
            <span class="n">netuids</span><span class="o">=</span><span class="n">netuids</span><span class="p">,</span>
            <span class="n">amounts</span><span class="o">=</span><span class="n">amounts</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.burned_register">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.burned_register">[docs]</a>
    <span class="k">def</span> <span class="nf">burned_register</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Registers a neuron on the Bittensor network by recycling TAO. This method of registration involves recycling</span>
<span class="sd">            TAO tokens, allowing them to be re-mined by performing work on the network.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): The wallet associated with the neuron to be registered.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block. Defaults to</span>
<span class="sd">                `False`.</span>
<span class="sd">            wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.</span>
<span class="sd">                Defaults to `True`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the registration is successful, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">burned_register_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.commit_weights">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.commit_weights">[docs]</a>
    <span class="k">def</span> <span class="nf">commit_weights</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">salt</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">uids</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">],</span> <span class="nb">list</span><span class="p">],</span>
        <span class="n">weights</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">],</span> <span class="nb">list</span><span class="p">],</span>
        <span class="n">version_key</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">version_as_int</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_retries</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Commits a hash of the neuron&#39;s weights to the Bittensor blockchain using the provided wallet.</span>
<span class="sd">        This action serves as a commitment or snapshot of the neuron&#39;s current weight distribution.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): The wallet associated with the neuron committing the weights.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            salt (list[int]): list of randomly generated integers as salt to generated weighted hash.</span>
<span class="sd">            uids (np.ndarray): NumPy array of neuron UIDs for which weights are being committed.</span>
<span class="sd">            weights (np.ndarray): NumPy array of weight values corresponding to each UID.</span>
<span class="sd">            version_key (int): Version key for compatibility with the network. Default is ``int representation of</span>
<span class="sd">                Bittensor version.``.</span>
<span class="sd">            wait_for_inclusion (bool): Waits for the transaction to be included in a block. Default is ``False``.</span>
<span class="sd">            wait_for_finalization (bool): Waits for the transaction to be finalized on the blockchain. Default is</span>
<span class="sd">                ``False``.</span>
<span class="sd">            max_retries (int): The number of maximum attempts to commit weights. Default is ``5``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[bool, str]: ``True`` if the weight commitment is successful, False otherwise. And `msg`, a string</span>
<span class="sd">                value describing the success or potential error.</span>

<span class="sd">        This function allows neurons to create a tamper-proof record of their weight distribution at a specific point</span>
<span class="sd">            in time, enhancing transparency and accountability within the Bittensor network.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;No attempt made. Perhaps it is too soon to commit weights!&quot;</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Committing weights with params: netuid=</span><span class="si">{</span><span class="n">netuid</span><span class="si">}</span><span class="s2">, uids=</span><span class="si">{</span><span class="n">uids</span><span class="si">}</span><span class="s2">, weights=</span><span class="si">{</span><span class="n">weights</span><span class="si">}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;version_key=</span><span class="si">{</span><span class="n">version_key</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Generate the hash of the weights</span>
        <span class="n">commit_hash</span> <span class="o">=</span> <span class="n">generate_weight_hash</span><span class="p">(</span>
            <span class="n">address</span><span class="o">=</span><span class="n">wallet</span><span class="o">.</span><span class="n">hotkey</span><span class="o">.</span><span class="n">ss58_address</span><span class="p">,</span>
            <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
            <span class="n">uids</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">uids</span><span class="p">),</span>
            <span class="n">values</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">weights</span><span class="p">),</span>
            <span class="n">salt</span><span class="o">=</span><span class="n">salt</span><span class="p">,</span>
            <span class="n">version_key</span><span class="o">=</span><span class="n">version_key</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">while</span> <span class="n">retries</span> <span class="o">&lt;</span> <span class="n">max_retries</span> <span class="ow">and</span> <span class="n">success</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">success</span><span class="p">,</span> <span class="n">message</span> <span class="o">=</span> <span class="n">commit_weights_extrinsic</span><span class="p">(</span>
                    <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
                    <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
                    <span class="n">commit_hash</span><span class="o">=</span><span class="n">commit_hash</span><span class="p">,</span>
                    <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                    <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">success</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error committing weights: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="n">retries</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">success</span><span class="p">,</span> <span class="n">message</span></div>


<div class="viewcode-block" id="Subtensor.move_stake">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.move_stake">[docs]</a>
    <span class="k">def</span> <span class="nf">move_stake</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">origin_hotkey</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">origin_netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">destination_hotkey</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">destination_netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">amount</span><span class="p">:</span> <span class="n">Balance</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Moves stake to a different hotkey and/or subnet.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet to move stake from.</span>
<span class="sd">            origin_hotkey (str): The SS58 address of the source hotkey.</span>
<span class="sd">            origin_netuid (int): The netuid of the source subnet.</span>
<span class="sd">            destination_hotkey (str): The SS58 address of the destination hotkey.</span>
<span class="sd">            destination_netuid (int): The netuid of the destination subnet.</span>
<span class="sd">            amount (Balance): Amount of stake to move.</span>
<span class="sd">            wait_for_inclusion (bool): Waits for the transaction to be included in a block.</span>
<span class="sd">            wait_for_finalization (bool): Waits for the transaction to be finalized on the blockchain.</span>

<span class="sd">        Returns:</span>
<span class="sd">            success (bool): True if the stake movement was successful.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">amount</span> <span class="o">=</span> <span class="n">check_and_convert_to_balance</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">move_stake_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">origin_hotkey</span><span class="o">=</span><span class="n">origin_hotkey</span><span class="p">,</span>
            <span class="n">origin_netuid</span><span class="o">=</span><span class="n">origin_netuid</span><span class="p">,</span>
            <span class="n">destination_hotkey</span><span class="o">=</span><span class="n">destination_hotkey</span><span class="p">,</span>
            <span class="n">destination_netuid</span><span class="o">=</span><span class="n">destination_netuid</span><span class="p">,</span>
            <span class="n">amount</span><span class="o">=</span><span class="n">amount</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.register">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.register">[docs]</a>
    <span class="k">def</span> <span class="nf">register</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">max_allowed_attempts</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
        <span class="n">output_in_place</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">cuda</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">dev_id</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">tpb</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">256</span><span class="p">,</span>
        <span class="n">num_processes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">update_interval</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">log_verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Registers a neuron on the Bittensor network using the provided wallet.</span>

<span class="sd">        Registration is a critical step for a neuron to become an active participant in the network, enabling it to</span>
<span class="sd">            stake, set weights, and receive incentives.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): The wallet associated with the neuron to be registered.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            wait_for_inclusion (bool): Waits for the transaction to be included in a block. Defaults to `False`.</span>
<span class="sd">            wait_for_finalization (bool): Waits for the transaction to be finalized on the blockchain. Defaults to</span>
<span class="sd">                `True`.</span>
<span class="sd">            max_allowed_attempts (int): Maximum number of attempts to register the wallet.</span>
<span class="sd">            output_in_place (bool): If true, prints the progress of the proof of work to the console in-place. Meaning</span>
<span class="sd">                the progress is printed on the same lines. Defaults to `True`.</span>
<span class="sd">            cuda (bool): If ``true``, the wallet should be registered using CUDA device(s). Defaults to `False`.</span>
<span class="sd">            dev_id (Union[List[int], int]): The CUDA device id to use, or a list of device ids. Defaults to `0` (zero).</span>
<span class="sd">            tpb (int): The number of threads per block (CUDA). Default to `256`.</span>
<span class="sd">            num_processes (Optional[int]): The number of processes to use to register. Default to `None`.</span>
<span class="sd">            update_interval (Optional[int]): The number of nonces to solve between updates.  Default to `None`.</span>
<span class="sd">            log_verbose (bool): If ``true``, the registration process will log more information.  Default to `False`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the registration is successful, False otherwise.</span>

<span class="sd">        This function facilitates the entry of new neurons into the network, supporting the decentralized</span>
<span class="sd">        growth and scalability of the Bittensor ecosystem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">register_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">max_allowed_attempts</span><span class="o">=</span><span class="n">max_allowed_attempts</span><span class="p">,</span>
            <span class="n">tpb</span><span class="o">=</span><span class="n">tpb</span><span class="p">,</span>
            <span class="n">update_interval</span><span class="o">=</span><span class="n">update_interval</span><span class="p">,</span>
            <span class="n">num_processes</span><span class="o">=</span><span class="n">num_processes</span><span class="p">,</span>
            <span class="n">cuda</span><span class="o">=</span><span class="n">cuda</span><span class="p">,</span>
            <span class="n">dev_id</span><span class="o">=</span><span class="n">dev_id</span><span class="p">,</span>
            <span class="n">output_in_place</span><span class="o">=</span><span class="n">output_in_place</span><span class="p">,</span>
            <span class="n">log_verbose</span><span class="o">=</span><span class="n">log_verbose</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.register_subnet">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.register_subnet">[docs]</a>
    <span class="k">def</span> <span class="nf">register_subnet</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Registers a new subnetwork on the Bittensor network.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): The wallet to be used for subnet registration.</span>
<span class="sd">            wait_for_inclusion (bool): If set, waits for the extrinsic to enter a block before returning true, or returns</span>
<span class="sd">                false if the extrinsic fails to enter the block within the timeout. Default is False.</span>
<span class="sd">            wait_for_finalization (bool): If set, waits for the extrinsic to be finalized on the chain before returning</span>
<span class="sd">                true, or returns false if the extrinsic fails to be finalized within the timeout. Default is True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if the subnet registration was successful, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">register_subnet_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.reveal_weights">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.reveal_weights">[docs]</a>
    <span class="k">def</span> <span class="nf">reveal_weights</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">uids</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">],</span> <span class="nb">list</span><span class="p">],</span>
        <span class="n">weights</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">],</span> <span class="nb">list</span><span class="p">],</span>
        <span class="n">salt</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">],</span> <span class="nb">list</span><span class="p">],</span>
        <span class="n">version_key</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">version_as_int</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_retries</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reveals the weights for a specific subnet on the Bittensor blockchain using the provided wallet.</span>
<span class="sd">        This action serves as a revelation of the neuron&#39;s previously committed weight distribution.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): The wallet associated with the neuron revealing the weights.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            uids (np.ndarray): NumPy array of neuron UIDs for which weights are being revealed.</span>
<span class="sd">            weights (np.ndarray): NumPy array of weight values corresponding to each UID.</span>
<span class="sd">            salt (np.ndarray): NumPy array of salt values corresponding to the hash function.</span>
<span class="sd">            version_key (int): Version key for compatibility with the network. Default is ``int representation of</span>
<span class="sd">                Bittensor version``.</span>
<span class="sd">            wait_for_inclusion (bool): Waits for the transaction to be included in a block. Default is ``False``.</span>
<span class="sd">            wait_for_finalization (bool): Waits for the transaction to be finalized on the blockchain. Default is</span>
<span class="sd">                ``False``.</span>
<span class="sd">            max_retries (int): The number of maximum attempts to reveal weights. Default is ``5``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[bool, str]: ``True`` if the weight revelation is successful, False otherwise. And `msg`, a string</span>
<span class="sd">                value describing the success or potential error.</span>

<span class="sd">        This function allows neurons to reveal their previously committed weight distribution, ensuring transparency</span>
<span class="sd">            and accountability within the Bittensor network.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;No attempt made. Perhaps it is too soon to reveal weights!&quot;</span>

        <span class="k">while</span> <span class="n">retries</span> <span class="o">&lt;</span> <span class="n">max_retries</span> <span class="ow">and</span> <span class="n">success</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">success</span><span class="p">,</span> <span class="n">message</span> <span class="o">=</span> <span class="n">reveal_weights_extrinsic</span><span class="p">(</span>
                    <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
                    <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
                    <span class="n">uids</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">uids</span><span class="p">),</span>
                    <span class="n">weights</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">weights</span><span class="p">),</span>
                    <span class="n">salt</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">salt</span><span class="p">),</span>
                    <span class="n">version_key</span><span class="o">=</span><span class="n">version_key</span><span class="p">,</span>
                    <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                    <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">success</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error revealing weights: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="n">retries</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">success</span><span class="p">,</span> <span class="n">message</span></div>


<div class="viewcode-block" id="Subtensor.root_register">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.root_register">[docs]</a>
    <span class="k">def</span> <span class="nf">root_register</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register neuron by recycling some TAO.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): Bittensor wallet instance.</span>
<span class="sd">            wait_for_inclusion (bool): Waits for the transaction to be included in a block. Default is ``False``.</span>
<span class="sd">            wait_for_finalization (bool): Waits for the transaction to be finalized on the blockchain. Default is</span>
<span class="sd">                ``False``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            `True` if registration was successful, otherwise `False`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Registering on netuid [blue]0[/blue] on network: [blue]</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="si">}</span><span class="s2">[/blue]&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Check current recycle amount</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Fetching recycle amount &amp; balance.&quot;</span><span class="p">)</span>
        <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_current_block</span><span class="p">()</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">recycle_call</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
                <span class="nb">int</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hyperparameter</span><span class="p">(</span><span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;Burn&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">balance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_balance</span><span class="p">(</span><span class="n">wallet</span><span class="o">.</span><span class="n">coldkeypub</span><span class="o">.</span><span class="n">ss58_address</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unable to retrieve current recycle. </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">current_recycle</span> <span class="o">=</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">recycle_call</span><span class="p">))</span>

        <span class="c1"># Check balance is sufficient</span>
        <span class="k">if</span> <span class="n">balance</span> <span class="o">&lt;</span> <span class="n">current_recycle</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[red]Insufficient balance </span><span class="si">{</span><span class="n">balance</span><span class="si">}</span><span class="s2"> to register neuron. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Current recycle is </span><span class="si">{</span><span class="n">current_recycle</span><span class="si">}</span><span class="s2"> TAO[/red].&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">root_register_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.root_set_weights">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.root_set_weights">[docs]</a>
    <span class="k">def</span> <span class="nf">root_set_weights</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">netuids</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">weights</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">version_key</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set weights for root network.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): bittensor wallet instance.</span>
<span class="sd">            netuids (list[int]): The list of subnet uids.</span>
<span class="sd">            weights (list[float]): The list of weights to be set.</span>
<span class="sd">            version_key (int, optional): Version key for compatibility with the network. Default is ``0``.</span>
<span class="sd">            wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block. Defaults to</span>
<span class="sd">                ``False``.</span>
<span class="sd">            wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.</span>
<span class="sd">                Defaults to ``False``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            `True` if the setting of weights is successful, `False` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">netuids_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">netuids</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
        <span class="n">weights_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Setting weights in network: [blue]</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="si">}</span><span class="s2">[/blue]&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">set_root_weights_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">netuids</span><span class="o">=</span><span class="n">netuids_</span><span class="p">,</span>
            <span class="n">weights</span><span class="o">=</span><span class="n">weights_</span><span class="p">,</span>
            <span class="n">version_key</span><span class="o">=</span><span class="n">version_key</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.set_subnet_identity">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.set_subnet_identity">[docs]</a>
    <span class="k">def</span> <span class="nf">set_subnet_identity</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">subnet_identity</span><span class="p">:</span> <span class="n">SubnetIdentity</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the identity of a subnet for a specific wallet and network.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            wallet (Wallet): The wallet instance that will authorize the transaction.</span>
<span class="sd">            netuid (int): The unique ID of the network on which the operation takes place.</span>
<span class="sd">            subnet_identity (SubnetIdentity): The identity data of the subnet including attributes like name, GitHub</span>
<span class="sd">                repository, contact, URL, discord, description, and any additional metadata.</span>
<span class="sd">            wait_for_inclusion (bool): Indicates if the function should wait for the transaction to be included in the block.</span>
<span class="sd">            wait_for_finalization (bool): Indicates if the function should wait for the transaction to reach finalization.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[bool, str]: A tuple where the first element is a boolean indicating success or failure of the</span>
<span class="sd">             operation, and the second element is a message providing additional information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">set_subnet_identity_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
            <span class="n">subnet_name</span><span class="o">=</span><span class="n">subnet_identity</span><span class="o">.</span><span class="n">subnet_name</span><span class="p">,</span>
            <span class="n">github_repo</span><span class="o">=</span><span class="n">subnet_identity</span><span class="o">.</span><span class="n">github_repo</span><span class="p">,</span>
            <span class="n">subnet_contact</span><span class="o">=</span><span class="n">subnet_identity</span><span class="o">.</span><span class="n">subnet_contact</span><span class="p">,</span>
            <span class="n">subnet_url</span><span class="o">=</span><span class="n">subnet_identity</span><span class="o">.</span><span class="n">subnet_url</span><span class="p">,</span>
            <span class="n">discord</span><span class="o">=</span><span class="n">subnet_identity</span><span class="o">.</span><span class="n">discord</span><span class="p">,</span>
            <span class="n">description</span><span class="o">=</span><span class="n">subnet_identity</span><span class="o">.</span><span class="n">description</span><span class="p">,</span>
            <span class="n">additional</span><span class="o">=</span><span class="n">subnet_identity</span><span class="o">.</span><span class="n">additional</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.set_weights">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.set_weights">[docs]</a>
    <span class="k">def</span> <span class="nf">set_weights</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">uids</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">],</span> <span class="s2">&quot;torch.LongTensor&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">],</span>
        <span class="n">weights</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">],</span> <span class="s2">&quot;torch.FloatTensor&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">],</span>
        <span class="n">version_key</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">version_as_int</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_retries</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the inter-neuronal weights for the specified neuron. This process involves specifying the influence or</span>
<span class="sd">            trust a neuron places on other neurons in the network, which is a fundamental aspect of Bittensor&#39;s</span>
<span class="sd">            decentralized learning architecture.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): The wallet associated with the neuron setting the weights.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            uids (Union[NDArray[np.int64], torch.LongTensor, list]): The list of neuron UIDs that the weights are being</span>
<span class="sd">                set for.</span>
<span class="sd">            weights (Union[NDArray[np.float32], torch.FloatTensor, list]): The corresponding weights to be set for each</span>
<span class="sd">                UID.</span>
<span class="sd">            version_key (int): Version key for compatibility with the network.  Default is int representation of</span>
<span class="sd">                Bittensor version.</span>
<span class="sd">            wait_for_inclusion (bool): Waits for the transaction to be included in a block. Default is ``False``.</span>
<span class="sd">            wait_for_finalization (bool): Waits for the transaction to be finalized on the blockchain. Default is</span>
<span class="sd">                ``False``.</span>
<span class="sd">            max_retries (int): The number of maximum attempts to set weights. Default is ``5``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[bool, str]: ``True`` if the setting of weights is successful, False otherwise. And `msg`, a string</span>
<span class="sd">                value describing the success or potential error.</span>

<span class="sd">        This function is crucial in shaping the network&#39;s collective intelligence, where each neuron&#39;s learning and</span>
<span class="sd">            contribution are influenced by the weights it sets towards others【81†source】.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_blocks_weight_limit</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="n">bslu</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocks_since_last_update</span><span class="p">(</span><span class="n">netuid</span><span class="p">,</span> <span class="n">cast</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">uid</span><span class="p">)))</span>
            <span class="n">wrl</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights_rate_limit</span><span class="p">(</span><span class="n">netuid</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">bslu</span> <span class="o">&gt;</span> <span class="n">wrl</span>

        <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;No attempt made. Perhaps it is too soon to commit weights!&quot;</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">uid</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_uid_for_hotkey_on_subnet</span><span class="p">(</span><span class="n">wallet</span><span class="o">.</span><span class="n">hotkey</span><span class="o">.</span><span class="n">ss58_address</span><span class="p">,</span> <span class="n">netuid</span><span class="p">)</span>
        <span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="kc">False</span><span class="p">,</span>
                <span class="sa">f</span><span class="s2">&quot;Hotkey </span><span class="si">{</span><span class="n">wallet</span><span class="o">.</span><span class="n">hotkey</span><span class="o">.</span><span class="n">ss58_address</span><span class="si">}</span><span class="s2"> not registered in subnet </span><span class="si">{</span><span class="n">netuid</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">commit_reveal_enabled</span><span class="p">(</span><span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># go with `commit reveal v3` extrinsic</span>

            <span class="k">while</span> <span class="n">retries</span> <span class="o">&lt;</span> <span class="n">max_retries</span> <span class="ow">and</span> <span class="n">success</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">_blocks_weight_limit</span><span class="p">():</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Committing weights for subnet #</span><span class="si">{</span><span class="n">netuid</span><span class="si">}</span><span class="s2">. Attempt </span><span class="si">{</span><span class="n">retries</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2"> of </span><span class="si">{</span><span class="n">max_retries</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
                <span class="n">success</span><span class="p">,</span> <span class="n">message</span> <span class="o">=</span> <span class="n">commit_reveal_v3_extrinsic</span><span class="p">(</span>
                    <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
                    <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
                    <span class="n">uids</span><span class="o">=</span><span class="n">uids</span><span class="p">,</span>
                    <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span>
                    <span class="n">version_key</span><span class="o">=</span><span class="n">version_key</span><span class="p">,</span>
                    <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                    <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">retries</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">success</span><span class="p">,</span> <span class="n">message</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># go with classic `set weights extrinsic`</span>

            <span class="k">while</span> <span class="n">retries</span> <span class="o">&lt;</span> <span class="n">max_retries</span> <span class="ow">and</span> <span class="n">success</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">_blocks_weight_limit</span><span class="p">():</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Setting weights for subnet #[blue]</span><span class="si">{</span><span class="n">netuid</span><span class="si">}</span><span class="s2">[/blue]. &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Attempt [blue]</span><span class="si">{</span><span class="n">retries</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2"> of </span><span class="si">{</span><span class="n">max_retries</span><span class="si">}</span><span class="s2">[/blue].&quot;</span>
                    <span class="p">)</span>
                    <span class="n">success</span><span class="p">,</span> <span class="n">message</span> <span class="o">=</span> <span class="n">set_weights_extrinsic</span><span class="p">(</span>
                        <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                        <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
                        <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
                        <span class="n">uids</span><span class="o">=</span><span class="n">uids</span><span class="p">,</span>
                        <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span>
                        <span class="n">version_key</span><span class="o">=</span><span class="n">version_key</span><span class="p">,</span>
                        <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                        <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error setting weights: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">finally</span><span class="p">:</span>
                    <span class="n">retries</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">return</span> <span class="n">success</span><span class="p">,</span> <span class="n">message</span></div>


<div class="viewcode-block" id="Subtensor.serve_axon">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.serve_axon">[docs]</a>
    <span class="k">def</span> <span class="nf">serve_axon</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">axon</span><span class="p">:</span> <span class="s2">&quot;Axon&quot;</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">certificate</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Certificate</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Registers an ``Axon`` serving endpoint on the Bittensor network for a specific neuron. This function is used to</span>
<span class="sd">            set up the Axon, a key component of a neuron that handles incoming queries and data processing tasks.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            axon (bittensor.core.axon.Axon): The Axon instance to be registered for serving.</span>
<span class="sd">            wait_for_inclusion (bool): Waits for the transaction to be included in a block. Default is ``False``.</span>
<span class="sd">            wait_for_finalization (bool): Waits for the transaction to be finalized on the blockchain. Default is</span>
<span class="sd">                ``True``.</span>
<span class="sd">            certificate (bittensor.utils.Certificate): Certificate to use for TLS. If ``None``, no TLS will be used.</span>
<span class="sd">                Defaults to ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the Axon serve registration is successful, False otherwise.</span>

<span class="sd">        By registering an Axon, the neuron becomes an active part of the network&#39;s distributed computing infrastructure,</span>
<span class="sd">            contributing to the collective intelligence of Bittensor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">serve_axon_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
            <span class="n">axon</span><span class="o">=</span><span class="n">axon</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">certificate</span><span class="o">=</span><span class="n">certificate</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.swap_stake">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.swap_stake">[docs]</a>
    <span class="k">def</span> <span class="nf">swap_stake</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">origin_netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">destination_netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">amount</span><span class="p">:</span> <span class="n">Balance</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Moves stake between subnets while keeping the same coldkey-hotkey pair ownership.</span>
<span class="sd">        Like subnet hopping - same owner, same hotkey, just changing which subnet the stake is in.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet to swap stake from.</span>
<span class="sd">            hotkey_ss58 (str): The SS58 address of the hotkey whose stake is being swapped.</span>
<span class="sd">            origin_netuid (int): The netuid from which stake is removed.</span>
<span class="sd">            destination_netuid (int): The netuid to which stake is added.</span>
<span class="sd">            amount (Union[Balance, float]): The amount to swap.</span>
<span class="sd">            wait_for_inclusion (bool): Waits for the transaction to be included in a block.</span>
<span class="sd">            wait_for_finalization (bool): Waits for the transaction to be finalized on the blockchain.</span>

<span class="sd">        Returns:</span>
<span class="sd">            success (bool): True if the extrinsic was successful.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">amount</span> <span class="o">=</span> <span class="n">check_and_convert_to_balance</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">swap_stake_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">hotkey_ss58</span><span class="o">=</span><span class="n">hotkey_ss58</span><span class="p">,</span>
            <span class="n">origin_netuid</span><span class="o">=</span><span class="n">origin_netuid</span><span class="p">,</span>
            <span class="n">destination_netuid</span><span class="o">=</span><span class="n">destination_netuid</span><span class="p">,</span>
            <span class="n">amount</span><span class="o">=</span><span class="n">amount</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.transfer">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.transfer">[docs]</a>
    <span class="k">def</span> <span class="nf">transfer</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">dest</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">amount</span><span class="p">:</span> <span class="n">Balance</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">transfer_all</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">keep_alive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transfer token of amount to destination.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): Source wallet for the transfer.</span>
<span class="sd">            dest (str): Destination address for the transfer.</span>
<span class="sd">            amount (float): Amount of tokens to transfer.</span>
<span class="sd">            transfer_all (bool): Flag to transfer all tokens. Default is ``False``.</span>
<span class="sd">            wait_for_inclusion (bool): Waits for the transaction to be included in a block.  Default is ``True``.</span>
<span class="sd">            wait_for_finalization (bool): Waits for the transaction to be finalized on the blockchain.  Default is</span>
<span class="sd">                ``False``.</span>
<span class="sd">            keep_alive (bool): Flag to keep the connection alive. Default is ``True``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            `True` if the transferring was successful, otherwise `False`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">amount</span> <span class="o">=</span> <span class="n">check_and_convert_to_balance</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">transfer_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">dest</span><span class="o">=</span><span class="n">dest</span><span class="p">,</span>
            <span class="n">amount</span><span class="o">=</span><span class="n">amount</span><span class="p">,</span>
            <span class="n">transfer_all</span><span class="o">=</span><span class="n">transfer_all</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">keep_alive</span><span class="o">=</span><span class="n">keep_alive</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.transfer_stake">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.transfer_stake">[docs]</a>
    <span class="k">def</span> <span class="nf">transfer_stake</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">destination_coldkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">origin_netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">destination_netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">amount</span><span class="p">:</span> <span class="n">Balance</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transfers stake from one subnet to another while changing the coldkey owner.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet to transfer stake from.</span>
<span class="sd">            destination_coldkey_ss58 (str): The destination coldkey SS58 address.</span>
<span class="sd">            hotkey_ss58 (str): The hotkey SS58 address associated with the stake.</span>
<span class="sd">            origin_netuid (int): The source subnet UID.</span>
<span class="sd">            destination_netuid (int): The destination subnet UID.</span>
<span class="sd">            amount (Union[Balance, float, int]): Amount to transfer.</span>
<span class="sd">            wait_for_inclusion (bool): If true, waits for inclusion before returning.</span>
<span class="sd">            wait_for_finalization (bool): If true, waits for finalization before returning.</span>

<span class="sd">        Returns:</span>
<span class="sd">            success (bool): True if the transfer was successful.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">amount</span> <span class="o">=</span> <span class="n">check_and_convert_to_balance</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">transfer_stake_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">destination_coldkey_ss58</span><span class="o">=</span><span class="n">destination_coldkey_ss58</span><span class="p">,</span>
            <span class="n">hotkey_ss58</span><span class="o">=</span><span class="n">hotkey_ss58</span><span class="p">,</span>
            <span class="n">origin_netuid</span><span class="o">=</span><span class="n">origin_netuid</span><span class="p">,</span>
            <span class="n">destination_netuid</span><span class="o">=</span><span class="n">destination_netuid</span><span class="p">,</span>
            <span class="n">amount</span><span class="o">=</span><span class="n">amount</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.unstake">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.unstake">[docs]</a>
    <span class="k">def</span> <span class="nf">unstake</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">amount</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Balance</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes a specified amount of stake from a single hotkey account. This function is critical for adjusting</span>
<span class="sd">            individual neuron stakes within the Bittensor network.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor_wallet.wallet): The wallet associated with the neuron from which the stake is being</span>
<span class="sd">                removed.</span>
<span class="sd">            hotkey_ss58 (Optional[str]): The ``SS58`` address of the hotkey account to unstake from.</span>
<span class="sd">            netuid (Optional[int]): The unique identifier of the subnet.</span>
<span class="sd">            amount (Balance): The amount of TAO to unstake. If not specified, unstakes all.</span>
<span class="sd">            wait_for_inclusion (bool): Waits for the transaction to be included in a block.</span>
<span class="sd">            wait_for_finalization (bool): Waits for the transaction to be finalized on the blockchain.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the unstaking process is successful, False otherwise.</span>

<span class="sd">        This function supports flexible stake management, allowing neurons to adjust their network participation and</span>
<span class="sd">            potential reward accruals.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">amount</span> <span class="o">=</span> <span class="n">check_and_convert_to_balance</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">unstake_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">hotkey_ss58</span><span class="o">=</span><span class="n">hotkey_ss58</span><span class="p">,</span>
            <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
            <span class="n">amount</span><span class="o">=</span><span class="n">amount</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.unstake_multiple">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.unstake_multiple">[docs]</a>
    <span class="k">def</span> <span class="nf">unstake_multiple</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">hotkey_ss58s</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">netuids</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">amounts</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">Balance</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs batch unstaking from multiple hotkey accounts, allowing a neuron to reduce its staked amounts</span>
<span class="sd">            efficiently. This function is useful for managing the distribution of stakes across multiple neurons.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): The wallet linked to the coldkey from which the stakes are being</span>
<span class="sd">                withdrawn.</span>
<span class="sd">            hotkey_ss58s (List[str]): A list of hotkey ``SS58`` addresses to unstake from.</span>
<span class="sd">            netuids (List[int]): The list of subnet uids.</span>
<span class="sd">            amounts (List[Balance]): The amounts of TAO to unstake from each hotkey. If not provided,</span>
<span class="sd">                unstakes all available stakes.</span>
<span class="sd">            wait_for_inclusion (bool): Waits for the transaction to be included in a block.</span>
<span class="sd">            wait_for_finalization (bool): Waits for the transaction to be finalized on the blockchain.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the batch unstaking is successful, False otherwise.</span>

<span class="sd">        This function allows for strategic reallocation or withdrawal of stakes, aligning with the dynamic stake</span>
<span class="sd">            management aspect of the Bittensor network.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">unstake_multiple_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">hotkey_ss58s</span><span class="o">=</span><span class="n">hotkey_ss58s</span><span class="p">,</span>
            <span class="n">netuids</span><span class="o">=</span><span class="n">netuids</span><span class="p">,</span>
            <span class="n">amounts</span><span class="o">=</span><span class="n">amounts</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
        <span class="p">)</span></div>
</div>

</pre></div>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Opentensor Foundation
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2024, Opentensor Foundation.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>