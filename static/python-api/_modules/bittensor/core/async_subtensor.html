
<!DOCTYPE html>


<html lang="en" data-content_root="../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>bittensor.core.async_subtensor &#8212; Bittensor SDK Docs  documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/sphinx-book-theme.css?v=a3416100" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=fd3f3429" />
    <link rel="stylesheet" type="text/css" href="../../../_static/bittensor-custom.css?v=c1dfe055" />
  
  <!-- So that users can add custom icons -->
  <script src="../../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/bittensor/core/async_subtensor';</script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../../_static/logo.svg" class="logo__image only-light" alt="Bittensor SDK Docs  documentation - Home"/>
    <img src="../../../_static/logo-dark-mode.svg" class="logo__image only-dark pst-js-only" alt="Bittensor SDK Docs  documentation - Home"/>
  
  
</a></div>
        <div class="sidebar-primary-item">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Table of Contents</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../autoapi/index.html">API Reference</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../autoapi/bittensor/index.html">bittensor</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../autoapi/bittensor/core/index.html">bittensor.core</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/async_subtensor/index.html">bittensor.core.async_subtensor</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/axon/index.html">bittensor.core.axon</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/chain_data/index.html">bittensor.core.chain_data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/config/index.html">bittensor.core.config</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/dendrite/index.html">bittensor.core.dendrite</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/errors/index.html">bittensor.core.errors</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/extrinsics/index.html">bittensor.core.extrinsics</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/metagraph/index.html">bittensor.core.metagraph</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/settings/index.html">bittensor.core.settings</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/stream/index.html">bittensor.core.stream</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/subtensor/index.html">bittensor.core.subtensor</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/synapse/index.html">bittensor.core.synapse</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/tensor/index.html">bittensor.core.tensor</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/threadpool/index.html">bittensor.core.threadpool</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/types/index.html">bittensor.core.types</a></li>
</ul>
</details></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../autoapi/bittensor/utils/index.html">bittensor.utils</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/axon_utils/index.html">bittensor.utils.axon_utils</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/balance/index.html">bittensor.utils.balance</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/btlogging/index.html">bittensor.utils.btlogging</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/delegates_details/index.html">bittensor.utils.delegates_details</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/deprecated/index.html">bittensor.utils.deprecated</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/formatting/index.html">bittensor.utils.formatting</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/mock/index.html">bittensor.utils.mock</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/networking/index.html">bittensor.utils.networking</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/registration/index.html">bittensor.utils.registration</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/subnets/index.html">bittensor.utils.subnets</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/substrate_utils/index.html">bittensor.utils.substrate_utils</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/version/index.html">bittensor.utils.version</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/weight_utils/index.html">bittensor.utils.weight_utils</a></li>
</ul>
</details></li>
</ul>
</details></li>
</ul>
</details></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/opentensor/btcli" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/opentensor/btcli/issues/new?title=Issue%20on%20page%20%2F_modules/bittensor/core/async_subtensor.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button>


<button class="btn btn-sm pst-navbar-icon search-button search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
</button>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1></h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for bittensor.core.async_subtensor</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">ssl</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">TypedDict</span><span class="p">,</span> <span class="n">Iterable</span>

<span class="kn">import</span> <span class="nn">aiohttp</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scalecodec</span>
<span class="kn">from</span> <span class="nn">bittensor_wallet</span> <span class="kn">import</span> <span class="n">Wallet</span>
<span class="kn">from</span> <span class="nn">bittensor_wallet.utils</span> <span class="kn">import</span> <span class="n">SS58_FORMAT</span>
<span class="kn">from</span> <span class="nn">numpy.typing</span> <span class="kn">import</span> <span class="n">NDArray</span>
<span class="kn">from</span> <span class="nn">scalecodec</span> <span class="kn">import</span> <span class="n">GenericCall</span>
<span class="kn">from</span> <span class="nn">scalecodec.base</span> <span class="kn">import</span> <span class="n">RuntimeConfiguration</span>
<span class="kn">from</span> <span class="nn">scalecodec.type_registry</span> <span class="kn">import</span> <span class="n">load_type_registry_preset</span>
<span class="kn">from</span> <span class="nn">substrateinterface.exceptions</span> <span class="kn">import</span> <span class="n">SubstrateRequestException</span>

<span class="kn">from</span> <span class="nn">bittensor.core.chain_data</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">DelegateInfo</span><span class="p">,</span>
    <span class="n">custom_rpc_type_registry</span><span class="p">,</span>
    <span class="n">StakeInfo</span><span class="p">,</span>
    <span class="n">NeuronInfoLite</span><span class="p">,</span>
    <span class="n">NeuronInfo</span><span class="p">,</span>
    <span class="n">SubnetHyperparameters</span><span class="p">,</span>
    <span class="n">decode_account_id</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">bittensor.core.extrinsics.async_registration</span> <span class="kn">import</span> <span class="n">register_extrinsic</span>
<span class="kn">from</span> <span class="nn">bittensor.core.extrinsics.async_root</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">set_root_weights_extrinsic</span><span class="p">,</span>
    <span class="n">root_register_extrinsic</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">bittensor.core.extrinsics.async_transfer</span> <span class="kn">import</span> <span class="n">transfer_extrinsic</span>
<span class="kn">from</span> <span class="nn">bittensor.core.extrinsics.async_weights</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">commit_weights_extrinsic</span><span class="p">,</span>
    <span class="n">set_weights_extrinsic</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">bittensor.core.settings</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">TYPE_REGISTRY</span><span class="p">,</span>
    <span class="n">DEFAULTS</span><span class="p">,</span>
    <span class="n">NETWORK_MAP</span><span class="p">,</span>
    <span class="n">DELEGATES_DETAILS_URL</span><span class="p">,</span>
    <span class="n">DEFAULT_NETWORK</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">bittensor.core.settings</span> <span class="kn">import</span> <span class="n">version_as_int</span>
<span class="kn">from</span> <span class="nn">bittensor.utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">torch</span><span class="p">,</span>
    <span class="n">ss58_to_vec_u8</span><span class="p">,</span>
    <span class="n">format_error_message</span><span class="p">,</span>
    <span class="n">decode_hex_identity_dict</span><span class="p">,</span>
    <span class="n">validate_chain_endpoint</span><span class="p">,</span>
    <span class="n">hex_to_bytes</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">bittensor.utils.async_substrate_interface</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">AsyncSubstrateInterface</span><span class="p">,</span>
    <span class="n">TimeoutException</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">bittensor.utils.balance</span> <span class="kn">import</span> <span class="n">Balance</span>
<span class="kn">from</span> <span class="nn">bittensor.utils.btlogging</span> <span class="kn">import</span> <span class="n">logging</span>
<span class="kn">from</span> <span class="nn">bittensor.utils.delegates_details</span> <span class="kn">import</span> <span class="n">DelegatesDetails</span>
<span class="kn">from</span> <span class="nn">bittensor.utils.weight_utils</span> <span class="kn">import</span> <span class="n">generate_weight_hash</span>


<span class="k">class</span> <span class="nc">ParamWithTypes</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>  <span class="c1"># Name of the parameter.</span>
    <span class="nb">type</span><span class="p">:</span> <span class="nb">str</span>  <span class="c1"># ScaleType string of the parameter.</span>


<span class="k">class</span> <span class="nc">ProposalVoteData</span><span class="p">:</span>
    <span class="n">index</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">threshold</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">ayes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="n">nays</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="n">end</span><span class="p">:</span> <span class="nb">int</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proposal_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">proposal_dict</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="n">proposal_dict</span><span class="p">[</span><span class="s2">&quot;threshold&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ayes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decode_ss58_tuples</span><span class="p">(</span><span class="n">proposal_dict</span><span class="p">[</span><span class="s2">&quot;ayes&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nays</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decode_ss58_tuples</span><span class="p">(</span><span class="n">proposal_dict</span><span class="p">[</span><span class="s2">&quot;nays&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">proposal_dict</span><span class="p">[</span><span class="s2">&quot;end&quot;</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">decode_ss58_tuples</span><span class="p">(</span><span class="n">line</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Decodes a tuple of ss58 addresses formatted as bytes tuples.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">decode_account_id</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">))]</span>


<span class="k">def</span> <span class="nf">_decode_hex_identity_dict</span><span class="p">(</span><span class="n">info_dictionary</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Decodes a dictionary of hexadecimal identities.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">info_dictionary</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">item</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">item</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="n">item</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">info_dictionary</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="nb">bytes</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="o">.</span><span class="n">hex</span><span class="p">(</span><span class="n">sep</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="n">bytes_per_sep</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
                    <span class="p">)</span>
                <span class="k">except</span> <span class="ne">UnicodeDecodeError</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not decode: </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">info_dictionary</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">UnicodeDecodeError</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not decode: </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">info_dictionary</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span>

    <span class="k">return</span> <span class="n">info_dictionary</span>


<div class="viewcode-block" id="AsyncSubtensor">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor">[docs]</a>
<span class="k">class</span> <span class="nc">AsyncSubtensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Thin layer for interacting with Substrate Interface. Mostly a collection of frequently-used calls.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">network</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">DEFAULT_NETWORK</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">network</span> <span class="ow">in</span> <span class="n">NETWORK_MAP</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">chain_endpoint</span> <span class="o">=</span> <span class="n">NETWORK_MAP</span><span class="p">[</span><span class="n">network</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">network</span> <span class="o">=</span> <span class="n">network</span>
            <span class="k">if</span> <span class="n">network</span> <span class="o">==</span> <span class="s2">&quot;local&quot;</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Warning: Verify your local subtensor is running on port 9944.&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">is_valid</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">validate_chain_endpoint</span><span class="p">(</span><span class="n">network</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_valid</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">chain_endpoint</span> <span class="o">=</span> <span class="n">network</span>
                <span class="k">if</span> <span class="n">network</span> <span class="ow">in</span> <span class="n">NETWORK_MAP</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">network</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span>
                        <span class="n">key</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">NETWORK_MAP</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="n">network</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">network</span> <span class="o">=</span> <span class="s2">&quot;custom&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Network not specified or not valid. Using default chain endpoint: [blue]</span><span class="si">{</span><span class="n">NETWORK_MAP</span><span class="p">[</span><span class="n">DEFAULTS</span><span class="o">.</span><span class="n">subtensor</span><span class="o">.</span><span class="n">network</span><span class="p">]</span><span class="si">}</span><span class="s2">[/blue].&quot;</span>
                <span class="p">)</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">&quot;You can set this for commands with the [blue]--network[/blue] flag, or by setting this in the config.&quot;</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">chain_endpoint</span> <span class="o">=</span> <span class="n">NETWORK_MAP</span><span class="p">[</span><span class="n">DEFAULTS</span><span class="o">.</span><span class="n">subtensor</span><span class="o">.</span><span class="n">network</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">network</span> <span class="o">=</span> <span class="n">DEFAULTS</span><span class="o">.</span><span class="n">subtensor</span><span class="o">.</span><span class="n">network</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span> <span class="o">=</span> <span class="n">AsyncSubstrateInterface</span><span class="p">(</span>
            <span class="n">chain_endpoint</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_endpoint</span><span class="p">,</span>
            <span class="n">ss58_format</span><span class="o">=</span><span class="n">SS58_FORMAT</span><span class="p">,</span>
            <span class="n">type_registry</span><span class="o">=</span><span class="n">TYPE_REGISTRY</span><span class="p">,</span>
            <span class="n">chain_name</span><span class="o">=</span><span class="s2">&quot;Bittensor&quot;</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Network: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="si">}</span><span class="s2">, Chain: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_endpoint</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">async</span> <span class="k">def</span> <span class="fm">__aenter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;[magenta]Connecting to Substrate:[/magenta] [blue]</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">[/blue][magenta]...[/magenta]&quot;</span>
        <span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">async</span> <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span>
        <span class="k">except</span> <span class="n">TimeoutException</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[red]Error[/red]: Timeout occurred connecting to substrate. Verify your chain and network settings: </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ConnectionError</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ConnectionRefusedError</span><span class="p">,</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLError</span><span class="p">)</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[red]Error[/red]: Connection refused when connecting to substrate. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Verify your chain and network settings: </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">. Error: </span><span class="si">{</span><span class="n">error</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ConnectionError</span>

    <span class="k">async</span> <span class="k">def</span> <span class="fm">__aexit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_val</span><span class="p">,</span> <span class="n">exc_tb</span><span class="p">):</span>
        <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<div class="viewcode-block" id="AsyncSubtensor.encode_params">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.encode_params">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">encode_params</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">call_definition</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="s2">&quot;ParamWithTypes&quot;</span><span class="p">]],</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a hex encoded string of the params using their types.&quot;&quot;&quot;</span>
        <span class="n">param_data</span> <span class="o">=</span> <span class="n">scalecodec</span><span class="o">.</span><span class="n">ScaleBytes</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">call_definition</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">]):</span>
            <span class="n">scale_obj</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">create_scale_object</span><span class="p">(</span><span class="n">param</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">param_data</span> <span class="o">+=</span> <span class="n">scale_obj</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">param</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Missing param </span><span class="si">{</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> in params dict.&quot;</span><span class="p">)</span>

                <span class="n">param_data</span> <span class="o">+=</span> <span class="n">scale_obj</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">param</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]])</span>

        <span class="k">return</span> <span class="n">param_data</span><span class="o">.</span><span class="n">to_hex</span><span class="p">()</span></div>


<div class="viewcode-block" id="AsyncSubtensor.get_hyperparameter">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.get_hyperparameter">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">get_hyperparameter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">param_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">block_hash</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">reuse_block</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a specified hyperparameter for a specific subnet.</span>

<span class="sd">        Args:</span>
<span class="sd">            param_name (str): The name of the hyperparameter to retrieve.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block_hash (Optional[str]): The hash of blockchain block number for the query.</span>
<span class="sd">            reuse_block (bool): Whether to reuse the last-used block hash.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The value of the specified hyperparameter if the subnet exists, or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">subnet_exists</span><span class="p">(</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block_hash</span><span class="p">):</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;subnet </span><span class="si">{</span><span class="n">netuid</span><span class="si">}</span><span class="s2"> does not exist&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="n">param_name</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
            <span class="n">reuse_block_hash</span><span class="o">=</span><span class="n">reuse_block</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span></div>


    <span class="c1"># Common subtensor methods =========================================================================================</span>

<div class="viewcode-block" id="AsyncSubtensor.get_current_block">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.get_current_block">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">get_current_block</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the current block number on the Bittensor blockchain. This function provides the latest block number, indicating the most recent state of the blockchain.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: The current chain block number.</span>

<span class="sd">        Knowing the current block number is essential for querying real-time data and performing time-sensitive operations on the blockchain. It serves as a reference point for network activities and data synchronization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_block_number</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span></div>


<div class="viewcode-block" id="AsyncSubtensor.get_block_hash">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.get_block_hash">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">get_block_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the hash of a specific block on the Bittensor blockchain. The block hash is a unique identifier representing the cryptographic hash of the block&#39;s content, ensuring its integrity and immutability.</span>

<span class="sd">        Args:</span>
<span class="sd">            block_id (int): The block number for which the hash is to be retrieved.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: The cryptographic hash of the specified block.</span>

<span class="sd">        The block hash is a fundamental aspect of blockchain technology, providing a secure reference to each block&#39;s data. It is crucial for verifying transactions, ensuring data consistency, and maintaining the trustworthiness of the blockchain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">block_id</span><span class="p">:</span>
            <span class="k">return</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_block_hash</span><span class="p">(</span><span class="n">block_id</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_chain_head</span><span class="p">()</span></div>


<div class="viewcode-block" id="AsyncSubtensor.is_hotkey_registered_any">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.is_hotkey_registered_any">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">is_hotkey_registered_any</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">block_hash</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">reuse_block</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if a neuron&#39;s hotkey is registered on any subnet within the Bittensor network.</span>

<span class="sd">        Args:</span>
<span class="sd">            hotkey_ss58 (str): The ``SS58`` address of the neuron&#39;s hotkey.</span>
<span class="sd">            block_hash (Optional[str]): The blockchain block_hash representation of block id.</span>
<span class="sd">            reuse_block (bool): Whether to reuse the last-used block hash.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the hotkey is registered on any subnet, False otherwise.</span>

<span class="sd">        This function is essential for determining the network-wide presence and participation of a neuron.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_netuids_for_hotkey</span><span class="p">(</span><span class="n">hotkey_ss58</span><span class="p">,</span> <span class="n">block_hash</span><span class="p">,</span> <span class="n">reuse_block</span><span class="p">))</span>
            <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="AsyncSubtensor.get_subnet_burn_cost">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.get_subnet_burn_cost">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">get_subnet_burn_cost</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">block_hash</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">reuse_block</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the burn cost for registering a new subnet within the Bittensor network. This cost represents the amount of Tao that needs to be locked or burned to establish a new subnet.</span>

<span class="sd">        Args:</span>
<span class="sd">            block_hash (Optional[int]): The blockchain block_hash of the block id.</span>
<span class="sd">            reuse_block (bool): Whether to reuse the last-used block hash.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: The burn cost for subnet registration.</span>

<span class="sd">        The subnet burn cost is an important economic parameter, reflecting the network&#39;s mechanisms for controlling the proliferation of subnets and ensuring their commitment to the network&#39;s long-term viability.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lock_cost</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_runtime_api</span><span class="p">(</span>
            <span class="n">runtime_api</span><span class="o">=</span><span class="s2">&quot;SubnetRegistrationRuntimeApi&quot;</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;get_network_registration_cost&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
            <span class="n">reuse_block</span><span class="o">=</span><span class="n">reuse_block</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">lock_cost</span></div>


<div class="viewcode-block" id="AsyncSubtensor.get_total_subnets">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.get_total_subnets">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">get_total_subnets</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">block_hash</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">reuse_block</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the total number of subnets within the Bittensor network as of a specific blockchain block.</span>

<span class="sd">        Args:</span>
<span class="sd">            block_hash (Optional[str]): The blockchain block_hash representation of block id.</span>
<span class="sd">            reuse_block (bool): Whether to reuse the last-used block hash.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[str]: The total number of subnets in the network.</span>

<span class="sd">        Understanding the total number of subnets is essential for assessing the network&#39;s growth and the extent of its decentralized infrastructure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;TotalNetworks&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
            <span class="n">reuse_block_hash</span><span class="o">=</span><span class="n">reuse_block</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="AsyncSubtensor.get_subnets">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.get_subnets">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">get_subnets</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">block_hash</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">reuse_block</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the list of all subnet unique identifiers (netuids) currently present in the Bittensor network.</span>

<span class="sd">        Args:</span>
<span class="sd">            block_hash (Optional[str]): The hash of the block to retrieve the subnet unique identifiers from.</span>
<span class="sd">            reuse_block (bool): Whether to reuse the last-used block hash.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of subnet netuids.</span>

<span class="sd">        This function provides a comprehensive view of the subnets within the Bittensor network,</span>
<span class="sd">        offering insights into its diversity and scale.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query_map</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;NetworksAdded&quot;</span><span class="p">,</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
            <span class="n">reuse_block_hash</span><span class="o">=</span><span class="n">reuse_block</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="p">[]</span>
            <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;records&quot;</span><span class="p">)</span>
            <span class="k">else</span> <span class="p">[</span><span class="n">netuid</span> <span class="k">async</span> <span class="k">for</span> <span class="n">netuid</span><span class="p">,</span> <span class="n">exists</span> <span class="ow">in</span> <span class="n">result</span> <span class="k">if</span> <span class="n">exists</span><span class="p">]</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="AsyncSubtensor.is_hotkey_delegate">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.is_hotkey_delegate">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">is_hotkey_delegate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">block_hash</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">reuse_block</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines whether a given hotkey (public key) is a delegate on the Bittensor network. This function checks if the neuron associated with the hotkey is part of the network&#39;s delegation system.</span>

<span class="sd">        Args:</span>
<span class="sd">            hotkey_ss58 (str): The SS58 address of the neuron&#39;s hotkey.</span>
<span class="sd">            block_hash (Optional[str]): The hash of the blockchain block number for the query.</span>
<span class="sd">            reuse_block (Optional[bool]): Whether to reuse the last-used block hash.</span>

<span class="sd">        Returns:</span>
<span class="sd">            `True` if the hotkey is a delegate, `False` otherwise.</span>

<span class="sd">        Being a delegate is a significant status within the Bittensor network, indicating a neuron&#39;s involvement in consensus and governance processes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">delegates</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_delegates</span><span class="p">(</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span> <span class="n">reuse_block</span><span class="o">=</span><span class="n">reuse_block</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">hotkey_ss58</span> <span class="ow">in</span> <span class="p">[</span><span class="n">info</span><span class="o">.</span><span class="n">hotkey_ss58</span> <span class="k">for</span> <span class="n">info</span> <span class="ow">in</span> <span class="n">delegates</span><span class="p">]</span></div>


<div class="viewcode-block" id="AsyncSubtensor.get_delegates">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.get_delegates">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">get_delegates</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">block_hash</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">reuse_block</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">DelegateInfo</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fetches all delegates on the chain</span>

<span class="sd">        Args:</span>
<span class="sd">            block_hash (Optional[str]): hash of the blockchain block number for the query.</span>
<span class="sd">            reuse_block (Optional[bool]): whether to reuse the last-used block hash.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of DelegateInfo objects, or an empty list if there are no delegates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hex_bytes_result</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_runtime_api</span><span class="p">(</span>
            <span class="n">runtime_api</span><span class="o">=</span><span class="s2">&quot;DelegateInfoRuntimeApi&quot;</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;get_delegates&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
            <span class="n">reuse_block</span><span class="o">=</span><span class="n">reuse_block</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">hex_bytes_result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">DelegateInfo</span><span class="o">.</span><span class="n">list_from_vec_u8</span><span class="p">(</span><span class="n">hex_to_bytes</span><span class="p">(</span><span class="n">hex_bytes_result</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span></div>


<div class="viewcode-block" id="AsyncSubtensor.get_stake_info_for_coldkey">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.get_stake_info_for_coldkey">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">get_stake_info_for_coldkey</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">coldkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">block_hash</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">reuse_block</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">StakeInfo</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves stake information associated with a specific coldkey. This function provides details about the stakes held by an account, including the staked amounts and associated delegates.</span>

<span class="sd">        Args:</span>
<span class="sd">            coldkey_ss58 (str): The ``SS58`` address of the account&#39;s coldkey.</span>
<span class="sd">            block_hash (Optional[str]): The hash of the blockchain block number for the query.</span>
<span class="sd">            reuse_block (bool): Whether to reuse the last-used block hash.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of StakeInfo objects detailing the stake allocations for the account.</span>

<span class="sd">        Stake information is vital for account holders to assess their investment and participation in the network&#39;s delegation and consensus processes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">encoded_coldkey</span> <span class="o">=</span> <span class="n">ss58_to_vec_u8</span><span class="p">(</span><span class="n">coldkey_ss58</span><span class="p">)</span>

        <span class="n">hex_bytes_result</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_runtime_api</span><span class="p">(</span>
            <span class="n">runtime_api</span><span class="o">=</span><span class="s2">&quot;StakeInfoRuntimeApi&quot;</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;get_stake_info_for_coldkey&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">encoded_coldkey</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
            <span class="n">reuse_block</span><span class="o">=</span><span class="n">reuse_block</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">hex_bytes_result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="n">StakeInfo</span><span class="o">.</span><span class="n">list_from_vec_u8</span><span class="p">(</span><span class="n">hex_to_bytes</span><span class="p">(</span><span class="n">hex_bytes_result</span><span class="p">))</span></div>


<div class="viewcode-block" id="AsyncSubtensor.get_stake_for_coldkey_and_hotkey">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.get_stake_for_coldkey_and_hotkey">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">get_stake_for_coldkey_and_hotkey</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">coldkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">block_hash</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">reuse_block</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Balance</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves stake information associated with a specific coldkey and hotkey.</span>

<span class="sd">        Args:</span>
<span class="sd">            hotkey_ss58 (str): the hotkey SS58 address to query</span>
<span class="sd">            coldkey_ss58 (str): the coldkey SS58 address to query</span>
<span class="sd">            block_hash (Optional[str]): the hash of the blockchain block number for the query.</span>
<span class="sd">            reuse_block (Optional[bool]): whether to reuse the last-used block hash.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Stake Balance for the given coldkey and hotkey</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_result</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;Stake&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">hotkey_ss58</span><span class="p">,</span> <span class="n">coldkey_ss58</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
            <span class="n">reuse_block_hash</span><span class="o">=</span><span class="n">reuse_block</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="n">_result</span> <span class="ow">or</span> <span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="AsyncSubtensor.query_runtime_api">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.query_runtime_api">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">query_runtime_api</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">runtime_api</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]],</span>
        <span class="n">block_hash</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">reuse_block</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Queries the runtime API of the Bittensor blockchain, providing a way to interact with the underlying runtime and retrieve data encoded in Scale Bytes format. This function is essential for advanced users who need to interact with specific runtime methods and decode complex data types.</span>

<span class="sd">        Args:</span>
<span class="sd">            runtime_api (str): The name of the runtime API to query.</span>
<span class="sd">            method (str): The specific method within the runtime API to call.</span>
<span class="sd">            params (Optional[Union[list[list[int]], dict[str, int]]]): The parameters to pass to the method call.</span>
<span class="sd">            block_hash (Optional[str]): The hash of the blockchain block number at which to perform the query.</span>
<span class="sd">            reuse_block (bool): Whether to reuse the last-used block hash.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The Scale Bytes encoded result from the runtime API call, or ``None`` if the call fails.</span>

<span class="sd">        This function enables access to the deeper layers of the Bittensor blockchain, allowing for detailed and specific interactions with the network&#39;s runtime environment.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call_definition</span> <span class="o">=</span> <span class="n">TYPE_REGISTRY</span><span class="p">[</span><span class="s2">&quot;runtime_api&quot;</span><span class="p">][</span><span class="n">runtime_api</span><span class="p">][</span><span class="s2">&quot;methods&quot;</span><span class="p">][</span><span class="n">method</span><span class="p">]</span>

        <span class="n">data</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;0x&quot;</span>
            <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">encode_params</span><span class="p">(</span>
                <span class="n">call_definition</span><span class="o">=</span><span class="n">call_definition</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">api_method</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">runtime_api</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="n">json_result</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">rpc_request</span><span class="p">(</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;state_call&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">api_method</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">block_hash</span><span class="p">]</span> <span class="k">if</span> <span class="n">block_hash</span> <span class="k">else</span> <span class="p">[</span><span class="n">api_method</span><span class="p">,</span> <span class="n">data</span><span class="p">],</span>
            <span class="n">reuse_block_hash</span><span class="o">=</span><span class="n">reuse_block</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">json_result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">return_type</span> <span class="o">=</span> <span class="n">call_definition</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span>

        <span class="n">as_scale_bytes</span> <span class="o">=</span> <span class="n">scalecodec</span><span class="o">.</span><span class="n">ScaleBytes</span><span class="p">(</span><span class="n">json_result</span><span class="p">[</span><span class="s2">&quot;result&quot;</span><span class="p">])</span>

        <span class="n">rpc_runtime_config</span> <span class="o">=</span> <span class="n">RuntimeConfiguration</span><span class="p">()</span>
        <span class="n">rpc_runtime_config</span><span class="o">.</span><span class="n">update_type_registry</span><span class="p">(</span><span class="n">load_type_registry_preset</span><span class="p">(</span><span class="s2">&quot;legacy&quot;</span><span class="p">))</span>
        <span class="n">rpc_runtime_config</span><span class="o">.</span><span class="n">update_type_registry</span><span class="p">(</span><span class="n">custom_rpc_type_registry</span><span class="p">)</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="n">rpc_runtime_config</span><span class="o">.</span><span class="n">create_scale_object</span><span class="p">(</span><span class="n">return_type</span><span class="p">,</span> <span class="n">as_scale_bytes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">to_hex</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;0x0400&quot;</span><span class="p">:</span>  <span class="c1"># RPC returned None result</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span></div>


<div class="viewcode-block" id="AsyncSubtensor.get_balance">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.get_balance">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">get_balance</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">addresses</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">block_hash</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">reuse_block</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Balance</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the balance for given coldkey(s)</span>

<span class="sd">        Args:</span>
<span class="sd">            addresses (str): coldkey addresses(s).</span>
<span class="sd">            block_hash (Optional[str]): the block hash, optional.</span>
<span class="sd">            reuse_block (Optional[bool]): whether to reuse the last-used block hash.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dict of {address: Balance objects}.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">reuse_block</span><span class="p">:</span>
            <span class="n">block_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">last_block_hash</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">block_hash</span><span class="p">:</span>
            <span class="n">block_hash</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_block_hash</span><span class="p">()</span>
        <span class="n">calls</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span>
                <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">create_storage_key</span><span class="p">(</span>
                    <span class="s2">&quot;System&quot;</span><span class="p">,</span> <span class="s2">&quot;Account&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">address</span><span class="p">],</span> <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">address</span> <span class="ow">in</span> <span class="n">addresses</span>
        <span class="p">]</span>
        <span class="n">batch_call</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query_multi</span><span class="p">(</span><span class="n">calls</span><span class="p">,</span> <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">batch_call</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="p">{</span><span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;free&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}}</span>
            <span class="n">results</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">Balance</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">][</span><span class="s2">&quot;free&quot;</span><span class="p">])})</span>
        <span class="k">return</span> <span class="n">results</span></div>


<div class="viewcode-block" id="AsyncSubtensor.get_transfer_fee">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.get_transfer_fee">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">get_transfer_fee</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;Balance&quot;</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Balance&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the transaction fee for transferring tokens from a wallet to a specified destination address. This function simulates the transfer to estimate the associated cost, taking into account the current network conditions and transaction complexity.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): The wallet from which the transfer is initiated.</span>
<span class="sd">            dest (str): The ``SS58`` address of the destination account.</span>
<span class="sd">            value (Union[bittensor.utils.balance.Balance, float, int]): The amount of tokens to be transferred, specified as a Balance object, or in Tao (float) or Rao (int) units.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bittensor.utils.balance.Balance: The estimated transaction fee for the transfer, represented as a Balance object.</span>

<span class="sd">        Estimating the transfer fee is essential for planning and executing token transactions, ensuring that the wallet has sufficient funds to cover both the transfer amount and the associated costs. This function provides a crucial tool for managing financial operations within the Bittensor network.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_tao</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Balance</span><span class="p">):</span>
            <span class="n">call</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">compose_call</span><span class="p">(</span>
                <span class="n">call_module</span><span class="o">=</span><span class="s2">&quot;Balances&quot;</span><span class="p">,</span>
                <span class="n">call_function</span><span class="o">=</span><span class="s2">&quot;transfer_allow_death&quot;</span><span class="p">,</span>
                <span class="n">call_params</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;dest&quot;</span><span class="p">:</span> <span class="n">dest</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">value</span><span class="o">.</span><span class="n">rao</span><span class="p">},</span>
            <span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">payment_info</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_payment_info</span><span class="p">(</span>
                    <span class="n">call</span><span class="o">=</span><span class="n">call</span><span class="p">,</span> <span class="n">keypair</span><span class="o">=</span><span class="n">wallet</span><span class="o">.</span><span class="n">coldkeypub</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;:cross_mark: [red]Failed to get payment info: [/red]</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="n">payment_info</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;partialFee&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="mf">2e7</span><span class="p">)}</span>  <span class="c1"># assume  0.02 Tao</span>

            <span class="k">return</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="n">payment_info</span><span class="p">[</span><span class="s2">&quot;partialFee&quot;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fee</span> <span class="o">=</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="mf">2e7</span><span class="p">))</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;To calculate the transaction fee, the value must be Balance, float, or int. Received type: </span><span class="si">%s</span><span class="s2">. Fee &quot;</span>
                <span class="s2">&quot;is </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">),</span>
                <span class="mf">2e7</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">fee</span></div>


<div class="viewcode-block" id="AsyncSubtensor.get_total_stake_for_coldkey">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.get_total_stake_for_coldkey">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">get_total_stake_for_coldkey</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">ss58_addresses</span><span class="p">,</span>
        <span class="n">block_hash</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">reuse_block</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Balance</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the total stake held on a coldkey.</span>

<span class="sd">        Args:</span>
<span class="sd">            ss58_addresses (tuple[str]): The SS58 address(es) of the coldkey(s)</span>
<span class="sd">            block_hash (str): The hash of the block number to retrieve the stake from.</span>
<span class="sd">            reuse_block (bool): Whether to reuse the last-used block hash.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dict in view {address: Balance objects}.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">reuse_block</span><span class="p">:</span>
            <span class="n">block_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">last_block_hash</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">block_hash</span><span class="p">:</span>
            <span class="n">block_hash</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_block_hash</span><span class="p">()</span>
        <span class="n">calls</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span>
                <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">create_storage_key</span><span class="p">(</span>
                    <span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;TotalColdkeyStake&quot;</span><span class="p">,</span>
                    <span class="p">[</span><span class="n">address</span><span class="p">],</span>
                    <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">address</span> <span class="ow">in</span> <span class="n">ss58_addresses</span>
        <span class="p">]</span>
        <span class="n">batch_call</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query_multi</span><span class="p">(</span><span class="n">calls</span><span class="p">,</span> <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">batch_call</span><span class="p">:</span>
            <span class="n">results</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="mi">0</span><span class="p">)})</span>
        <span class="k">return</span> <span class="n">results</span></div>


<div class="viewcode-block" id="AsyncSubtensor.get_total_stake_for_hotkey">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.get_total_stake_for_hotkey">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">get_total_stake_for_hotkey</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">ss58_addresses</span><span class="p">,</span>
        <span class="n">block_hash</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">reuse_block</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Balance</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the total stake held on a hotkey.</span>

<span class="sd">        Args:</span>
<span class="sd">            ss58_addresses (tuple[str]): The SS58 address(es) of the hotkey(s)</span>
<span class="sd">            block_hash (str): The hash of the block number to retrieve the stake from.</span>
<span class="sd">            reuse_block (bool): Whether to reuse the last-used block hash when retrieving info.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dict {address: Balance objects}.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">results</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query_multiple</span><span class="p">(</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">ss58_addresses</span><span class="p">],</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;TotalHotkeyStake&quot;</span><span class="p">,</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
            <span class="n">reuse_block_hash</span><span class="o">=</span><span class="n">reuse_block</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="n">r</span> <span class="ow">or</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="ow">in</span> <span class="n">results</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span></div>


<div class="viewcode-block" id="AsyncSubtensor.get_netuids_for_hotkey">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.get_netuids_for_hotkey">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">get_netuids_for_hotkey</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">block_hash</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">reuse_block</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a list of subnet UIDs (netuids) for which a given hotkey is a member. This function identifies the specific subnets within the Bittensor network where the neuron associated with the hotkey is active.</span>

<span class="sd">        Args:</span>
<span class="sd">            hotkey_ss58 (str): The ``SS58`` address of the neuron&#39;s hotkey.</span>
<span class="sd">            block_hash (Optional[str]): The hash of the blockchain block number at which to perform the query.</span>
<span class="sd">            reuse_block (Optional[bool]): Whether to reuse the last-used block hash when retrieving info.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of netuids where the neuron is a member.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query_map</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;IsNetworkMember&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">hotkey_ss58</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
            <span class="n">reuse_block_hash</span><span class="o">=</span><span class="n">reuse_block</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="p">[</span><span class="n">record</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">async</span> <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">result</span> <span class="k">if</span> <span class="n">record</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">result</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;records&quot;</span><span class="p">)</span>
            <span class="k">else</span> <span class="p">[]</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="AsyncSubtensor.subnet_exists">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.subnet_exists">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">subnet_exists</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block_hash</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">reuse_block</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if a subnet with the specified unique identifier (netuid) exists within the Bittensor network.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block_hash (Optional[str]): The hash of the blockchain block number at which to check the subnet existence.</span>
<span class="sd">            reuse_block (bool): Whether to reuse the last-used block hash.</span>

<span class="sd">        Returns:</span>
<span class="sd">            `True` if the subnet exists, `False` otherwise.</span>

<span class="sd">        This function is critical for verifying the presence of specific subnets in the network,</span>
<span class="sd">        enabling a deeper understanding of the network&#39;s structure and composition.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;NetworksAdded&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
            <span class="n">reuse_block_hash</span><span class="o">=</span><span class="n">reuse_block</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="AsyncSubtensor.filter_netuids_by_registered_hotkeys">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.filter_netuids_by_registered_hotkeys">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">filter_netuids_by_registered_hotkeys</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">all_netuids</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">filter_for_netuids</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">all_hotkeys</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Wallet</span><span class="p">],</span>
        <span class="n">block_hash</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">reuse_block</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filters a given list of all netuids for certain specified netuids and hotkeys</span>

<span class="sd">        Args:</span>
<span class="sd">            all_netuids (Iterable[int]): A list of netuids to filter.</span>
<span class="sd">            filter_for_netuids (Iterable[int]): A subset of all_netuids to filter from the main list</span>
<span class="sd">            all_hotkeys (Iterable[Wallet]): Hotkeys to filter from the main list</span>
<span class="sd">            block_hash (str): hash of the blockchain block number at which to perform the query.</span>
<span class="sd">            reuse_block (bool): whether to reuse the last-used blockchain hash when retrieving info.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The filtered list of netuids.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">netuids_with_registered_hotkeys</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">item</span>
            <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span>
                <span class="o">*</span><span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">get_netuids_for_hotkey</span><span class="p">(</span>
                        <span class="n">wallet</span><span class="o">.</span><span class="n">hotkey</span><span class="o">.</span><span class="n">ss58_address</span><span class="p">,</span>
                        <span class="n">reuse_block</span><span class="o">=</span><span class="n">reuse_block</span><span class="p">,</span>
                        <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">wallet</span> <span class="ow">in</span> <span class="n">all_hotkeys</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sublist</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">filter_for_netuids</span><span class="p">:</span>
            <span class="n">all_netuids</span> <span class="o">=</span> <span class="n">netuids_with_registered_hotkeys</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">filtered_netuids</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">netuid</span> <span class="k">for</span> <span class="n">netuid</span> <span class="ow">in</span> <span class="n">all_netuids</span> <span class="k">if</span> <span class="n">netuid</span> <span class="ow">in</span> <span class="n">filter_for_netuids</span>
            <span class="p">]</span>

            <span class="n">registered_hotkeys_filtered</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">netuid</span>
                <span class="k">for</span> <span class="n">netuid</span> <span class="ow">in</span> <span class="n">netuids_with_registered_hotkeys</span>
                <span class="k">if</span> <span class="n">netuid</span> <span class="ow">in</span> <span class="n">filter_for_netuids</span>
            <span class="p">]</span>

            <span class="c1"># Combine both filtered lists</span>
            <span class="n">all_netuids</span> <span class="o">=</span> <span class="n">filtered_netuids</span> <span class="o">+</span> <span class="n">registered_hotkeys_filtered</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">all_netuids</span><span class="p">))</span></div>


<div class="viewcode-block" id="AsyncSubtensor.get_existential_deposit">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.get_existential_deposit">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">get_existential_deposit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">block_hash</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">reuse_block</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Balance</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the existential deposit amount for the Bittensor blockchain.</span>
<span class="sd">        The existential deposit is the minimum amount of TAO required for an account to exist on the blockchain.</span>
<span class="sd">        Accounts with balances below this threshold can be reaped to conserve network resources.</span>

<span class="sd">        Args:</span>
<span class="sd">            block_hash (str): Block hash at which to query the deposit amount. If `None`, the current block is used.</span>
<span class="sd">            reuse_block (bool): Whether to reuse the last-used blockchain block hash.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The existential deposit amount.</span>

<span class="sd">        The existential deposit is a fundamental economic parameter in the Bittensor network, ensuring efficient use of storage and preventing the proliferation of dust accounts.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_constant</span><span class="p">(</span>
            <span class="n">module_name</span><span class="o">=</span><span class="s2">&quot;Balances&quot;</span><span class="p">,</span>
            <span class="n">constant_name</span><span class="o">=</span><span class="s2">&quot;ExistentialDeposit&quot;</span><span class="p">,</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
            <span class="n">reuse_block_hash</span><span class="o">=</span><span class="n">reuse_block</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unable to retrieve existential deposit amount.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>


<div class="viewcode-block" id="AsyncSubtensor.neurons">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.neurons">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">neurons</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block_hash</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">reuse_block</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">NeuronInfo</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a list of all neurons within a specified subnet of the Bittensor network.</span>
<span class="sd">        This function provides a snapshot of the subnet&#39;s neuron population, including each neuron&#39;s attributes and network interactions.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block_hash (str): The hash of the blockchain block number for the query.</span>
<span class="sd">            reuse_block (bool): Whether to reuse the last-used blockchain block hash.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of NeuronInfo objects detailing each neuron&#39;s characteristics in the subnet.</span>

<span class="sd">        Understanding the distribution and status of neurons within a subnet is key to comprehending the network&#39;s decentralized structure and the dynamics of its consensus and governance processes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hex_bytes_result</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_runtime_api</span><span class="p">(</span>
            <span class="n">runtime_api</span><span class="o">=</span><span class="s2">&quot;NeuronInfoRuntimeApi&quot;</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;get_neurons&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
            <span class="n">reuse_block</span><span class="o">=</span><span class="n">reuse_block</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">hex_bytes_result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="n">NeuronInfo</span><span class="o">.</span><span class="n">list_from_vec_u8</span><span class="p">(</span><span class="n">hex_to_bytes</span><span class="p">(</span><span class="n">hex_bytes_result</span><span class="p">))</span></div>


<div class="viewcode-block" id="AsyncSubtensor.neurons_lite">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.neurons_lite">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">neurons_lite</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block_hash</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">reuse_block</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">NeuronInfoLite</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a list of neurons in a &#39;lite&#39; format from a specific subnet of the Bittensor network.</span>
<span class="sd">        This function provides a streamlined view of the neurons, focusing on key attributes such as stake and network participation.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block_hash (str): The hash of the blockchain block number for the query.</span>
<span class="sd">            reuse_block (bool): Whether to reuse the last-used blockchain block hash.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of simplified neuron information for the subnet.</span>

<span class="sd">        This function offers a quick overview of the neuron population within a subnet, facilitating efficient analysis of the network&#39;s decentralized structure and neuron dynamics.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hex_bytes_result</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_runtime_api</span><span class="p">(</span>
            <span class="n">runtime_api</span><span class="o">=</span><span class="s2">&quot;NeuronInfoRuntimeApi&quot;</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;get_neurons_lite&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span>
                <span class="n">netuid</span>
            <span class="p">],</span>  <span class="c1"># TODO check to see if this can accept more than one at a time</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
            <span class="n">reuse_block</span><span class="o">=</span><span class="n">reuse_block</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">hex_bytes_result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="n">NeuronInfoLite</span><span class="o">.</span><span class="n">list_from_vec_u8</span><span class="p">(</span><span class="n">hex_to_bytes</span><span class="p">(</span><span class="n">hex_bytes_result</span><span class="p">))</span></div>


<div class="viewcode-block" id="AsyncSubtensor.get_neuron_for_pubkey_and_subnet">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.get_neuron_for_pubkey_and_subnet">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">get_neuron_for_pubkey_and_subnet</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">block_hash</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">reuse_block</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;NeuronInfo&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves information about a neuron based on its public key (hotkey SS58 address) and the specific subnet UID (netuid). This function provides detailed neuron information for a particular subnet within the Bittensor network.</span>

<span class="sd">        Args:</span>
<span class="sd">            hotkey_ss58 (str): The ``SS58`` address of the neuron&#39;s hotkey.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block_hash (Optional[int]): The blockchain block number at which to perform the query.</span>
<span class="sd">            reuse_block (bool): Whether to reuse the last-used blockchain block hash.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[bittensor.core.chain_data.neuron_info.NeuronInfo]: Detailed information about the neuron if found, ``None`` otherwise.</span>

<span class="sd">        This function is crucial for accessing specific neuron data and understanding its status, stake, and other attributes within a particular subnet of the Bittensor ecosystem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">uid</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;Uids&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
            <span class="n">reuse_block_hash</span><span class="o">=</span><span class="n">reuse_block</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">uid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">NeuronInfo</span><span class="o">.</span><span class="n">get_null_neuron</span><span class="p">()</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">netuid</span><span class="p">,</span> <span class="n">uid</span><span class="p">]</span>
        <span class="n">json_body</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">rpc_request</span><span class="p">(</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;neuronInfo_getNeuron&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">result</span> <span class="o">:=</span> <span class="n">json_body</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;result&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">NeuronInfo</span><span class="o">.</span><span class="n">get_null_neuron</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">NeuronInfo</span><span class="o">.</span><span class="n">from_vec_u8</span><span class="p">(</span><span class="nb">bytes</span><span class="p">(</span><span class="n">result</span><span class="p">))</span></div>


<div class="viewcode-block" id="AsyncSubtensor.neuron_for_uid">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.neuron_for_uid">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">neuron_for_uid</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">uid</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">block_hash</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">reuse_block</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NeuronInfo</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves detailed information about a specific neuron identified by its unique identifier (UID) within a specified subnet (netuid) of the Bittensor network. This function provides a comprehensive view of a neuron&#39;s attributes, including its stake, rank, and operational status.</span>

<span class="sd">        Args:</span>
<span class="sd">            uid (int): The unique identifier of the neuron.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block_hash (str): The hash of the blockchain block number for the query.</span>
<span class="sd">            reuse_block (bool): Whether to reuse the last-used blockchain block hash.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Detailed information about the neuron if found, a null neuron otherwise</span>

<span class="sd">        This function is crucial for analyzing individual neurons&#39; contributions and status within a specific subnet, offering insights into their roles in the network&#39;s consensus and validation mechanisms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">uid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">NeuronInfo</span><span class="o">.</span><span class="n">get_null_neuron</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">reuse_block</span><span class="p">:</span>
            <span class="n">block_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">last_block_hash</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">netuid</span><span class="p">,</span> <span class="n">uid</span><span class="p">,</span> <span class="n">block_hash</span><span class="p">]</span> <span class="k">if</span> <span class="n">block_hash</span> <span class="k">else</span> <span class="p">[</span><span class="n">netuid</span><span class="p">,</span> <span class="n">uid</span><span class="p">]</span>
        <span class="n">json_body</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">rpc_request</span><span class="p">(</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;neuronInfo_getNeuron&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>  <span class="c1"># custom rpc method</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">result</span> <span class="o">:=</span> <span class="n">json_body</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;result&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">NeuronInfo</span><span class="o">.</span><span class="n">get_null_neuron</span><span class="p">()</span>

        <span class="n">bytes_result</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">NeuronInfo</span><span class="o">.</span><span class="n">from_vec_u8</span><span class="p">(</span><span class="n">bytes_result</span><span class="p">)</span></div>


<div class="viewcode-block" id="AsyncSubtensor.get_delegated">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.get_delegated">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">get_delegated</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">coldkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">block_hash</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">reuse_block</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">DelegateInfo</span><span class="p">,</span> <span class="n">Balance</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a list of delegates and their associated stakes for a given coldkey. This function identifies the delegates that a specific account has staked tokens on.</span>

<span class="sd">        Args:</span>
<span class="sd">            coldkey_ss58 (str): The `SS58` address of the account&#39;s coldkey.</span>
<span class="sd">            block_hash (Optional[str]): The hash of the blockchain block number for the query.</span>
<span class="sd">            reuse_block (bool): Whether to reuse the last-used blockchain block hash.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of tuples, each containing a delegate&#39;s information and staked amount.</span>

<span class="sd">        This function is important for account holders to understand their stake allocations and their involvement in the network&#39;s delegation and consensus mechanisms.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">block_hash</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">block_hash</span>
            <span class="k">if</span> <span class="n">block_hash</span>
            <span class="k">else</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">last_block_hash</span> <span class="k">if</span> <span class="n">reuse_block</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">encoded_coldkey</span> <span class="o">=</span> <span class="n">ss58_to_vec_u8</span><span class="p">(</span><span class="n">coldkey_ss58</span><span class="p">)</span>
        <span class="n">json_body</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">rpc_request</span><span class="p">(</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;delegateInfo_getDelegated&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">([</span><span class="n">block_hash</span><span class="p">,</span> <span class="n">encoded_coldkey</span><span class="p">]</span> <span class="k">if</span> <span class="n">block_hash</span> <span class="k">else</span> <span class="p">[</span><span class="n">encoded_coldkey</span><span class="p">]),</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">result</span> <span class="o">:=</span> <span class="n">json_body</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;result&quot;</span><span class="p">)):</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="n">DelegateInfo</span><span class="o">.</span><span class="n">delegated_list_from_vec_u8</span><span class="p">(</span><span class="nb">bytes</span><span class="p">(</span><span class="n">result</span><span class="p">))</span></div>


<div class="viewcode-block" id="AsyncSubtensor.query_identity">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.query_identity">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">query_identity</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">block_hash</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">reuse_block</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Queries the identity of a neuron on the Bittensor blockchain using the given key. This function retrieves detailed identity information about a specific neuron, which is a crucial aspect of the network&#39;s decentralized identity and governance system.</span>

<span class="sd">        Args:</span>
<span class="sd">            key (str): The key used to query the neuron&#39;s identity, typically the neuron&#39;s SS58 address.</span>
<span class="sd">            block_hash (str): The hash of the blockchain block number at which to perform the query.</span>
<span class="sd">            reuse_block (bool): Whether to reuse the last-used blockchain block hash.</span>

<span class="sd">        Returns:</span>
<span class="sd">            An object containing the identity information of the neuron if found, ``None`` otherwise.</span>

<span class="sd">        The identity information can include various attributes such as the neuron&#39;s stake, rank, and other network-specific details, providing insights into the neuron&#39;s role and status within the Bittensor network.</span>

<span class="sd">        Note:</span>
<span class="sd">            See the `Bittensor CLI documentation &lt;https://docs.bittensor.com/reference/btcli&gt;`_ for supported identity parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">identity_info</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;Registry&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;IdentityOf&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
            <span class="n">reuse_block_hash</span><span class="o">=</span><span class="n">reuse_block</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_decode_hex_identity_dict</span><span class="p">(</span><span class="n">identity_info</span><span class="p">[</span><span class="s2">&quot;info&quot;</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{}</span></div>


<div class="viewcode-block" id="AsyncSubtensor.weights">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.weights">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">weights</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block_hash</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">reuse_block</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the weight distribution set by neurons within a specific subnet of the Bittensor network.</span>
<span class="sd">        This function maps each neuron&#39;s UID to the weights it assigns to other neurons, reflecting the network&#39;s trust and value assignment mechanisms.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The network UID of the subnet to query.</span>
<span class="sd">            block_hash (str): The hash of the blockchain block for the query.</span>
<span class="sd">            reuse_block (bool): Whether to reuse the last-used blockchain block hash.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of tuples mapping each neuron&#39;s UID to its assigned weights.</span>

<span class="sd">        The weight distribution is a key factor in the network&#39;s consensus algorithm and the ranking of neurons, influencing their influence and reward allocation within the subnet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO look into seeing if we can speed this up with storage query</span>
        <span class="n">w_map_encoded</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query_map</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;Weights&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
            <span class="n">reuse_block_hash</span><span class="o">=</span><span class="n">reuse_block</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">w_map</span> <span class="o">=</span> <span class="p">[(</span><span class="n">uid</span><span class="p">,</span> <span class="n">w</span> <span class="ow">or</span> <span class="p">[])</span> <span class="k">async</span> <span class="k">for</span> <span class="n">uid</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">w_map_encoded</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">w_map</span></div>


<div class="viewcode-block" id="AsyncSubtensor.bonds">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.bonds">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">bonds</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block_hash</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">reuse_block</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the bond distribution set by neurons within a specific subnet of the Bittensor network.</span>
<span class="sd">        Bonds represent the investments or commitments made by neurons in one another, indicating a level of trust and perceived value. This bonding mechanism is integral to the network&#39;s market-based approach to measuring and rewarding machine intelligence.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The network UID of the subnet to query.</span>
<span class="sd">            block_hash (Optional[str]): The hash of the blockchain block number for the query.</span>
<span class="sd">            reuse_block (bool): Whether to reuse the last-used blockchain block hash.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of tuples mapping each neuron&#39;s UID to its bonds with other neurons.</span>

<span class="sd">        Understanding bond distributions is crucial for analyzing the trust dynamics and market behavior within the subnet. It reflects how neurons recognize and invest in each other&#39;s intelligence and contributions, supporting diverse and niche systems within the Bittensor ecosystem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">b_map_encoded</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query_map</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;Bonds&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
            <span class="n">reuse_block_hash</span><span class="o">=</span><span class="n">reuse_block</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">b_map</span> <span class="o">=</span> <span class="p">[(</span><span class="n">uid</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">async</span> <span class="k">for</span> <span class="n">uid</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">b_map_encoded</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">b_map</span></div>


<div class="viewcode-block" id="AsyncSubtensor.does_hotkey_exist">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.does_hotkey_exist">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">does_hotkey_exist</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">block_hash</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">reuse_block</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns true if the hotkey is known by the chain and there are accounts.</span>

<span class="sd">        Args:</span>
<span class="sd">            hotkey_ss58 (str): The SS58 address of the hotkey.</span>
<span class="sd">            block_hash (Optional[str]): The hash of the block number to check the hotkey against.</span>
<span class="sd">            reuse_block (bool): Whether to reuse the last-used blockchain hash.</span>

<span class="sd">        Returns:</span>
<span class="sd">            `True` if the hotkey is known by the chain and there are accounts, `False` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_result</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;Owner&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">hotkey_ss58</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
            <span class="n">reuse_block_hash</span><span class="o">=</span><span class="n">reuse_block</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">decode_account_id</span><span class="p">(</span><span class="n">_result</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">return_val</span> <span class="o">=</span> <span class="p">(</span>
            <span class="kc">False</span>
            <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="n">result</span> <span class="o">!=</span> <span class="s2">&quot;5C4hrfjw9DjXZTzV3MwzrrAr9P1MJhSrvWGWqi1eSuyUpnhM&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">return_val</span></div>


<div class="viewcode-block" id="AsyncSubtensor.get_hotkey_owner">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.get_hotkey_owner">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">get_hotkey_owner</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">block_hash</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">reuse_block</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the owner of the given hotkey at a specific block hash.</span>
<span class="sd">        This function queries the blockchain for the owner of the provided hotkey. If the hotkey does not exist at the specified block hash, it returns None.</span>

<span class="sd">        Args:</span>
<span class="sd">            hotkey_ss58 (str): The SS58 address of the hotkey.</span>
<span class="sd">            block_hash (Optional[str]): The hash of the block at which to check the hotkey ownership.</span>
<span class="sd">            reuse_block (bool): Whether to reuse the last-used blockchain hash.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[str]: The SS58 address of the owner if the hotkey exists, or None if it doesn&#39;t.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hk_owner_query</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;Owner&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">hotkey_ss58</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
            <span class="n">reuse_block_hash</span><span class="o">=</span><span class="n">reuse_block</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">decode_account_id</span><span class="p">(</span><span class="n">hk_owner_query</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">val</span><span class="p">:</span>
            <span class="n">exists</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">does_hotkey_exist</span><span class="p">(</span><span class="n">hotkey_ss58</span><span class="p">,</span> <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">exists</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">hotkey_owner</span> <span class="o">=</span> <span class="n">val</span> <span class="k">if</span> <span class="n">exists</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">hotkey_owner</span></div>


<div class="viewcode-block" id="AsyncSubtensor.sign_and_send_extrinsic">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.sign_and_send_extrinsic">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">sign_and_send_extrinsic</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">call</span><span class="p">:</span> <span class="s2">&quot;GenericCall&quot;</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper method to sign and submit an extrinsic call to chain.</span>

<span class="sd">        Args:</span>
<span class="sd">            call (scalecodec.types.GenericCall): a prepared Call object</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): the wallet whose coldkey will be used to sign the extrinsic</span>
<span class="sd">            wait_for_inclusion (bool): whether to wait until the extrinsic call is included on the chain</span>
<span class="sd">            wait_for_finalization (bool): whether to wait until the extrinsic call is finalized on the chain</span>

<span class="sd">        Returns:</span>
<span class="sd">            (success, error message)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">extrinsic</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">create_signed_extrinsic</span><span class="p">(</span>
            <span class="n">call</span><span class="o">=</span><span class="n">call</span><span class="p">,</span> <span class="n">keypair</span><span class="o">=</span><span class="n">wallet</span><span class="o">.</span><span class="n">coldkey</span>
        <span class="p">)</span>  <span class="c1"># sign with coldkey</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">response</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">submit_extrinsic</span><span class="p">(</span>
                <span class="n">extrinsic</span><span class="p">,</span>
                <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># We only wait here if we expect finalization.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">wait_for_finalization</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">wait_for_inclusion</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;&quot;</span>
            <span class="k">await</span> <span class="n">response</span><span class="o">.</span><span class="n">process_events</span><span class="p">()</span>
            <span class="k">if</span> <span class="k">await</span> <span class="n">response</span><span class="o">.</span><span class="n">is_success</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">format_error_message</span><span class="p">(</span><span class="k">await</span> <span class="n">response</span><span class="o">.</span><span class="n">error_message</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">SubstrateRequestException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">format_error_message</span><span class="p">(</span><span class="n">e</span><span class="p">)</span></div>


<div class="viewcode-block" id="AsyncSubtensor.get_children">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.get_children">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">get_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hotkey</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method retrieves the children of a given hotkey and netuid. It queries the SubtensorModule&#39;s ChildKeys storage function to get the children and formats them before returning as a tuple.</span>

<span class="sd">        Args:</span>
<span class="sd">            hotkey (str): The hotkey value.</span>
<span class="sd">            netuid (int): The netuid value.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A tuple containing a boolean indicating success or failure, a list of formatted children, and an error message (if applicable)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">children</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
                <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
                <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;ChildKeys&quot;</span><span class="p">,</span>
                <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">hotkey</span><span class="p">,</span> <span class="n">netuid</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">children</span><span class="p">:</span>
                <span class="n">formatted_children</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">proportion</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                    <span class="c1"># Convert U64 to int</span>
                    <span class="n">formatted_child</span> <span class="o">=</span> <span class="n">decode_account_id</span><span class="p">(</span><span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">int_proportion</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">proportion</span><span class="p">)</span>
                    <span class="n">formatted_children</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">int_proportion</span><span class="p">,</span> <span class="n">formatted_child</span><span class="p">))</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">formatted_children</span><span class="p">,</span> <span class="s2">&quot;&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="p">[],</span> <span class="s2">&quot;&quot;</span>
        <span class="k">except</span> <span class="n">SubstrateRequestException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="p">[],</span> <span class="n">format_error_message</span><span class="p">(</span><span class="n">e</span><span class="p">)</span></div>


<div class="viewcode-block" id="AsyncSubtensor.get_subnet_hyperparameters">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.get_subnet_hyperparameters">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">get_subnet_hyperparameters</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block_hash</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">reuse_block</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="n">SubnetHyperparameters</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the hyperparameters for a specific subnet within the Bittensor network. These hyperparameters define the operational settings and rules governing the subnet&#39;s behavior.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The network UID of the subnet to query.</span>
<span class="sd">            block_hash (Optional[str]): The hash of the blockchain block number for the query.</span>
<span class="sd">            reuse_block (bool): Whether to reuse the last-used blockchain hash.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The subnet&#39;s hyperparameters, or `None` if not available.</span>

<span class="sd">        Understanding the hyperparameters is crucial for comprehending how subnets are configured and managed, and how they interact with the network&#39;s consensus and incentive mechanisms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hex_bytes_result</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_runtime_api</span><span class="p">(</span>
            <span class="n">runtime_api</span><span class="o">=</span><span class="s2">&quot;SubnetInfoRuntimeApi&quot;</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;get_subnet_hyperparams&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
            <span class="n">reuse_block</span><span class="o">=</span><span class="n">reuse_block</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">hex_bytes_result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="n">SubnetHyperparameters</span><span class="o">.</span><span class="n">from_vec_u8</span><span class="p">(</span><span class="n">hex_to_bytes</span><span class="p">(</span><span class="n">hex_bytes_result</span><span class="p">))</span></div>


<div class="viewcode-block" id="AsyncSubtensor.get_vote_data">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.get_vote_data">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">get_vote_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">proposal_hash</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">block_hash</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">reuse_block</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;ProposalVoteData&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the voting data for a specific proposal on the Bittensor blockchain. This data includes information about how senate members have voted on the proposal.</span>

<span class="sd">        Args:</span>
<span class="sd">            proposal_hash (str): The hash of the proposal for which voting data is requested.</span>
<span class="sd">            block_hash (Optional[str]): The hash of the blockchain block number to query the voting data.</span>
<span class="sd">            reuse_block (bool): Whether to reuse the last-used blockchain block hash.</span>

<span class="sd">        Returns:</span>
<span class="sd">            An object containing the proposal&#39;s voting data, or `None` if not found.</span>

<span class="sd">        This function is important for tracking and understanding the decision-making processes within the Bittensor network, particularly how proposals are received and acted upon by the governing body.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vote_data</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;Triumvirate&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;Voting&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">proposal_hash</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
            <span class="n">reuse_block_hash</span><span class="o">=</span><span class="n">reuse_block</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">vote_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ProposalVoteData</span><span class="p">(</span><span class="n">vote_data</span><span class="p">)</span></div>


<div class="viewcode-block" id="AsyncSubtensor.get_delegate_identities">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.get_delegate_identities">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">get_delegate_identities</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">block_hash</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">reuse_block</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">DelegatesDetails</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fetches delegates identities from the chain and GitHub. Preference is given to chain data, and missing info is filled-in by the info from GitHub. At some point, we want to totally move away from fetching this info from GitHub, but chain data is still limited in that regard.</span>

<span class="sd">        Args:</span>
<span class="sd">            block_hash (str): the hash of the blockchain block for the query</span>
<span class="sd">            reuse_block (bool): Whether to reuse the last-used blockchain block hash.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dict {ss58: DelegatesDetails, ...}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">timeout</span> <span class="o">=</span> <span class="n">aiohttp</span><span class="o">.</span><span class="n">ClientTimeout</span><span class="p">(</span><span class="mf">10.0</span><span class="p">)</span>
        <span class="k">async</span> <span class="k">with</span> <span class="n">aiohttp</span><span class="o">.</span><span class="n">ClientSession</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
            <span class="n">identities_info</span><span class="p">,</span> <span class="n">response</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query_map</span><span class="p">(</span>
                    <span class="n">module</span><span class="o">=</span><span class="s2">&quot;Registry&quot;</span><span class="p">,</span>
                    <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;IdentityOf&quot;</span><span class="p">,</span>
                    <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
                    <span class="n">reuse_block_hash</span><span class="o">=</span><span class="n">reuse_block</span><span class="p">,</span>
                <span class="p">),</span>
                <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">DELEGATES_DETAILS_URL</span><span class="p">),</span>
            <span class="p">)</span>

            <span class="n">all_delegates_details</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">decode_account_id</span><span class="p">(</span><span class="n">ss58_address</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span> <span class="n">DelegatesDetails</span><span class="o">.</span><span class="n">from_chain_data</span><span class="p">(</span>
                    <span class="n">decode_hex_identity_dict</span><span class="p">(</span><span class="n">identity</span><span class="p">[</span><span class="s2">&quot;info&quot;</span><span class="p">])</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">ss58_address</span><span class="p">,</span> <span class="n">identity</span> <span class="ow">in</span> <span class="n">identities_info</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="n">response</span><span class="o">.</span><span class="n">ok</span><span class="p">:</span>
                <span class="n">all_delegates</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="k">await</span> <span class="n">response</span><span class="o">.</span><span class="n">json</span><span class="p">(</span><span class="n">content_type</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">delegate_hotkey</span><span class="p">,</span> <span class="n">delegate_details</span> <span class="ow">in</span> <span class="n">all_delegates</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">delegate_info</span> <span class="o">=</span> <span class="n">all_delegates_details</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span>
                        <span class="n">delegate_hotkey</span><span class="p">,</span>
                        <span class="n">DelegatesDetails</span><span class="p">(</span>
                            <span class="n">display</span><span class="o">=</span><span class="n">delegate_details</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">),</span>
                            <span class="n">web</span><span class="o">=</span><span class="n">delegate_details</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;url&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">),</span>
                            <span class="n">additional</span><span class="o">=</span><span class="n">delegate_details</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;description&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">),</span>
                            <span class="n">pgp_fingerprint</span><span class="o">=</span><span class="n">delegate_details</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;fingerprint&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">),</span>
                        <span class="p">),</span>
                    <span class="p">)</span>
                    <span class="n">delegate_info</span><span class="o">.</span><span class="n">display</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">delegate_info</span><span class="o">.</span><span class="n">display</span> <span class="ow">or</span> <span class="n">delegate_details</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="n">delegate_info</span><span class="o">.</span><span class="n">web</span> <span class="o">=</span> <span class="n">delegate_info</span><span class="o">.</span><span class="n">web</span> <span class="ow">or</span> <span class="n">delegate_details</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                        <span class="s2">&quot;url&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span>
                    <span class="p">)</span>
                    <span class="n">delegate_info</span><span class="o">.</span><span class="n">additional</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">delegate_info</span><span class="o">.</span><span class="n">additional</span>
                        <span class="ow">or</span> <span class="n">delegate_details</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;description&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="n">delegate_info</span><span class="o">.</span><span class="n">pgp_fingerprint</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">delegate_info</span><span class="o">.</span><span class="n">pgp_fingerprint</span>
                        <span class="ow">or</span> <span class="n">delegate_details</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;fingerprint&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                    <span class="p">)</span>

        <span class="k">return</span> <span class="n">all_delegates_details</span></div>


<div class="viewcode-block" id="AsyncSubtensor.is_hotkey_registered">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.is_hotkey_registered">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">is_hotkey_registered</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">block_hash</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">reuse_block</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Checks to see if the hotkey is registered on a given netuid&quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;Uids&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
            <span class="n">reuse_block_hash</span><span class="o">=</span><span class="n">reuse_block</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="AsyncSubtensor.get_uid_for_hotkey_on_subnet">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.get_uid_for_hotkey_on_subnet">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">get_uid_for_hotkey_on_subnet</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">block_hash</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">reuse_block</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the unique identifier (UID) for a neuron&#39;s hotkey on a specific subnet.</span>

<span class="sd">        Args:</span>
<span class="sd">            hotkey_ss58 (str): The ``SS58`` address of the neuron&#39;s hotkey.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block_hash (Optional[str]): The blockchain block_hash representation of the block id.</span>
<span class="sd">            reuse_block (bool): Whether to reuse the last-used blockchain block hash.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The UID of the neuron if it is registered on the subnet, ``None`` otherwise.</span>

<span class="sd">        The UID is a critical identifier within the network, linking the neuron&#39;s hotkey to its operational and governance activities on a particular subnet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;Uids&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
            <span class="n">reuse_block_hash</span><span class="o">=</span><span class="n">reuse_block</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="AsyncSubtensor.weights_rate_limit">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.weights_rate_limit">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">weights_rate_limit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block_hash</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">reuse_block</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns network WeightsSetRateLimit hyperparameter.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            block_hash (Optional[str]): The blockchain block_hash representation of the block id.</span>
<span class="sd">            reuse_block (bool): Whether to reuse the last-used blockchain block hash.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The value of the WeightsSetRateLimit hyperparameter, or ``None`` if the subnetwork does not exist or the parameter is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hyperparameter</span><span class="p">(</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;WeightsSetRateLimit&quot;</span><span class="p">,</span>
            <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
            <span class="n">reuse_block</span><span class="o">=</span><span class="n">reuse_block</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">)</span></div>


<div class="viewcode-block" id="AsyncSubtensor.blocks_since_last_update">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.blocks_since_last_update">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">blocks_since_last_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">uid</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of blocks since the last update for a specific UID in the subnetwork.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            uid (int): The unique identifier of the neuron.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The number of blocks since the last update, or ``None`` if the subnetwork or UID does not exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hyperparameter</span><span class="p">(</span><span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;LastUpdate&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_current_block</span><span class="p">()</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">[</span><span class="n">uid</span><span class="p">])</span></div>


<div class="viewcode-block" id="AsyncSubtensor.commit_reveal_enabled">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.commit_reveal_enabled">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">commit_reveal_enabled</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block_hash</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if commit-reveal mechanism is enabled for a given network at a specific block.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            netuid (int): The network identifier for which to check the commit-reveal mechanism.</span>
<span class="sd">            block_hash (Optional[str]): The block hash of block at which to check the parameter (default is None, which implies the current block).</span>

<span class="sd">        Returns:</span>
<span class="sd">            (bool): Returns the integer value of the hyperparameter if available; otherwise, returns None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hyperparameter</span><span class="p">(</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;CommitRevealWeightsEnabled&quot;</span><span class="p">,</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
            <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">True</span> <span class="k">else</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="AsyncSubtensor.get_subnet_reveal_period_epochs">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.get_subnet_reveal_period_epochs">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">get_subnet_reveal_period_epochs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block_hash</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve the SubnetRevealPeriodEpochs hyperparameter.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hyperparameter</span><span class="p">(</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;RevealPeriodEpochs&quot;</span><span class="p">,</span> <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span>
        <span class="p">)</span></div>


    <span class="c1"># Extrinsics =======================================================================================================</span>

<div class="viewcode-block" id="AsyncSubtensor.transfer">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.transfer">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">transfer</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">destination</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">amount</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">transfer_all</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transfer token of amount to destination.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): Source wallet for the transfer.</span>
<span class="sd">            destination (str): Destination address for the transfer.</span>
<span class="sd">            amount (float): Amount of tokens to transfer.</span>
<span class="sd">            transfer_all (bool): Flag to transfer all tokens.</span>

<span class="sd">        Returns:</span>
<span class="sd">            `True` if the transferring was successful, otherwise `False`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="k">await</span> <span class="n">transfer_extrinsic</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="p">,</span>
            <span class="n">destination</span><span class="p">,</span>
            <span class="n">Balance</span><span class="o">.</span><span class="n">from_tao</span><span class="p">(</span><span class="n">amount</span><span class="p">),</span>
            <span class="n">transfer_all</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="AsyncSubtensor.register">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.register">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">register</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">block_hash</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register neuron by recycling some TAO.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): Bittensor wallet instance.</span>
<span class="sd">            netuid (int): Subnet uniq id.</span>
<span class="sd">            block_hash (Optional[str]): The hash of the blockchain block for the query.</span>
<span class="sd">            wait_for_inclusion (bool): Waits for the transaction to be included in a block. Default is ``False``.</span>
<span class="sd">            wait_for_finalization (bool): Waits for the transaction to be finalized on the blockchain. Default is ``False``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            `True` if registration was successful, otherwise `False`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Registering on netuid [blue]0[/blue] on network: [blue]</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="si">}</span><span class="s2">[/blue]&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Check current recycle amount</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Fetching recycle amount &amp; balance.&quot;</span><span class="p">)</span>
        <span class="n">block_hash</span> <span class="o">=</span> <span class="n">block_hash</span> <span class="k">if</span> <span class="n">block_hash</span> <span class="k">else</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_block_hash</span><span class="p">()</span>
        <span class="n">recycle_call</span><span class="p">,</span> <span class="n">balance_</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_hyperparameter</span><span class="p">(</span><span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;Burn&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">reuse_block</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_balance</span><span class="p">(</span><span class="n">wallet</span><span class="o">.</span><span class="n">coldkeypub</span><span class="o">.</span><span class="n">ss58_address</span><span class="p">,</span> <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">current_recycle</span> <span class="o">=</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">recycle_call</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">balance</span><span class="p">:</span> <span class="n">Balance</span> <span class="o">=</span> <span class="n">balance_</span><span class="p">[</span><span class="n">wallet</span><span class="o">.</span><span class="n">coldkeypub</span><span class="o">.</span><span class="n">ss58_address</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unable to retrieve current recycle. </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Unable to retrieve current balance.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Check balance is sufficient</span>
        <span class="k">if</span> <span class="n">balance</span> <span class="o">&lt;</span> <span class="n">current_recycle</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[red]Insufficient balance </span><span class="si">{</span><span class="n">balance</span><span class="si">}</span><span class="s2"> to register neuron. Current recycle is </span><span class="si">{</span><span class="n">current_recycle</span><span class="si">}</span><span class="s2"> TAO[/red].&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="k">await</span> <span class="n">root_register_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="k">async</span> <span class="k">def</span> <span class="nf">pow_register</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;AsyncSubtensor&quot;</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">processors</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">update_interval</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">output_in_place</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">use_cuda</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">dev_id</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">threads_per_block</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Register neuron.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="k">await</span> <span class="n">register_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
            <span class="n">tpb</span><span class="o">=</span><span class="n">threads_per_block</span><span class="p">,</span>
            <span class="n">update_interval</span><span class="o">=</span><span class="n">update_interval</span><span class="p">,</span>
            <span class="n">num_processes</span><span class="o">=</span><span class="n">processors</span><span class="p">,</span>
            <span class="n">cuda</span><span class="o">=</span><span class="n">use_cuda</span><span class="p">,</span>
            <span class="n">dev_id</span><span class="o">=</span><span class="n">dev_id</span><span class="p">,</span>
            <span class="n">output_in_place</span><span class="o">=</span><span class="n">output_in_place</span><span class="p">,</span>
            <span class="n">log_verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="AsyncSubtensor.set_weights">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.set_weights">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">set_weights</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">uids</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">],</span> <span class="s2">&quot;torch.LongTensor&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">],</span>
        <span class="n">weights</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">],</span> <span class="s2">&quot;torch.FloatTensor&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">],</span>
        <span class="n">version_key</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">version_as_int</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_retries</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the inter-neuronal weights for the specified neuron. This process involves specifying the influence or trust a neuron places on other neurons in the network, which is a fundamental aspect of Bittensor&#39;s decentralized learning architecture.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): The wallet associated with the neuron setting the weights.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            uids (Union[NDArray[np.int64], torch.LongTensor, list]): The list of neuron UIDs that the weights are being set for.</span>
<span class="sd">            weights (Union[NDArray[np.float32], torch.FloatTensor, list]): The corresponding weights to be set for each UID.</span>
<span class="sd">            version_key (int): Version key for compatibility with the network.  Default is ``int representation of Bittensor version.``.</span>
<span class="sd">            wait_for_inclusion (bool): Waits for the transaction to be included in a block. Default is ``False``.</span>
<span class="sd">            wait_for_finalization (bool): Waits for the transaction to be finalized on the blockchain. Default is ``False``.</span>
<span class="sd">            max_retries (int): The number of maximum attempts to set weights. Default is ``5``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[bool, str]: ``True`` if the setting of weights is successful, False otherwise. And `msg`, a string value describing the success or potential error.</span>

<span class="sd">        This function is crucial in shaping the network&#39;s collective intelligence, where each neuron&#39;s learning and contribution are influenced by the weights it sets towards others【81†source】.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">commit_reveal_enabled</span><span class="p">(</span><span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># go with `commit reveal v3` extrinsic</span>
            <span class="k">raise</span> <span class="bp">NotImplemented</span><span class="p">(</span><span class="s2">&quot;Not implemented yet for AsyncSubtensor. Coming soon.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># go with classic `set weights extrinsic`</span>
            <span class="n">uid</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_uid_for_hotkey_on_subnet</span><span class="p">(</span>
                <span class="n">wallet</span><span class="o">.</span><span class="n">hotkey</span><span class="o">.</span><span class="n">ss58_address</span><span class="p">,</span> <span class="n">netuid</span>
            <span class="p">)</span>
            <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;No attempt made. Perhaps it is too soon to set weights!&quot;</span>
            <span class="k">while</span> <span class="p">(</span>
                <span class="n">retries</span> <span class="o">&lt;</span> <span class="n">max_retries</span>
                <span class="ow">and</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocks_since_last_update</span><span class="p">(</span><span class="n">netuid</span><span class="p">,</span> <span class="n">uid</span><span class="p">)</span>
                <span class="o">&gt;</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights_rate_limit</span><span class="p">(</span><span class="n">netuid</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">success</span> <span class="ow">is</span> <span class="kc">False</span>
            <span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Setting weights for subnet #[blue]</span><span class="si">{</span><span class="n">netuid</span><span class="si">}</span><span class="s2">[/blue]. Attempt [blue]</span><span class="si">{</span><span class="n">retries</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2"> of </span><span class="si">{</span><span class="n">max_retries</span><span class="si">}</span><span class="s2">[/blue].&quot;</span>
                    <span class="p">)</span>
                    <span class="n">success</span><span class="p">,</span> <span class="n">message</span> <span class="o">=</span> <span class="k">await</span> <span class="n">set_weights_extrinsic</span><span class="p">(</span>
                        <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                        <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
                        <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
                        <span class="n">uids</span><span class="o">=</span><span class="n">uids</span><span class="p">,</span>
                        <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span>
                        <span class="n">version_key</span><span class="o">=</span><span class="n">version_key</span><span class="p">,</span>
                        <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                        <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error setting weights: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">finally</span><span class="p">:</span>
                    <span class="n">retries</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">return</span> <span class="n">success</span><span class="p">,</span> <span class="n">message</span></div>


<div class="viewcode-block" id="AsyncSubtensor.root_set_weights">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.root_set_weights">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">root_set_weights</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">netuids</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">weights</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set weights for root network.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): bittensor wallet instance.</span>
<span class="sd">            netuids (list[int]): The list of subnet uids.</span>
<span class="sd">            weights (list[float]): The list of weights to be set.</span>

<span class="sd">        Returns:</span>
<span class="sd">            `True` if the setting of weights is successful, `False` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">netuids_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">netuids</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
        <span class="n">weights_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Setting weights in network: [blue]</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="si">}</span><span class="s2">[/blue]&quot;</span><span class="p">)</span>
        <span class="c1"># Run the set weights operation.</span>
        <span class="k">return</span> <span class="k">await</span> <span class="n">set_root_weights_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">netuids</span><span class="o">=</span><span class="n">netuids_</span><span class="p">,</span>
            <span class="n">weights</span><span class="o">=</span><span class="n">weights_</span><span class="p">,</span>
            <span class="n">version_key</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="AsyncSubtensor.commit_weights">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/async_subtensor/index.html#bittensor.core.async_subtensor.AsyncSubtensor.commit_weights">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">commit_weights</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">salt</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">uids</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">],</span> <span class="nb">list</span><span class="p">],</span>
        <span class="n">weights</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">],</span> <span class="nb">list</span><span class="p">],</span>
        <span class="n">version_key</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">version_as_int</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_retries</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Commits a hash of the neuron&#39;s weights to the Bittensor blockchain using the provided wallet.</span>
<span class="sd">        This action serves as a commitment or snapshot of the neuron&#39;s current weight distribution.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): The wallet associated with the neuron committing the weights.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            salt (list[int]): list of randomly generated integers as salt to generated weighted hash.</span>
<span class="sd">            uids (np.ndarray): NumPy array of neuron UIDs for which weights are being committed.</span>
<span class="sd">            weights (np.ndarray): NumPy array of weight values corresponding to each UID.</span>
<span class="sd">            version_key (int): Version key for compatibility with the network. Default is ``int representation of Bittensor version.``.</span>
<span class="sd">            wait_for_inclusion (bool): Waits for the transaction to be included in a block. Default is ``False``.</span>
<span class="sd">            wait_for_finalization (bool): Waits for the transaction to be finalized on the blockchain. Default is ``False``.</span>
<span class="sd">            max_retries (int): The number of maximum attempts to commit weights. Default is ``5``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[bool, str]: ``True`` if the weight commitment is successful, False otherwise. And `msg`, a string value describing the success or potential error.</span>

<span class="sd">        This function allows neurons to create a tamper-proof record of their weight distribution at a specific point in time, enhancing transparency and accountability within the Bittensor network.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;No attempt made. Perhaps it is too soon to commit weights!&quot;</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Committing weights with params: netuid=</span><span class="si">{</span><span class="n">netuid</span><span class="si">}</span><span class="s2">, uids=</span><span class="si">{</span><span class="n">uids</span><span class="si">}</span><span class="s2">, weights=</span><span class="si">{</span><span class="n">weights</span><span class="si">}</span><span class="s2">, version_key=</span><span class="si">{</span><span class="n">version_key</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Generate the hash of the weights</span>
        <span class="n">commit_hash</span> <span class="o">=</span> <span class="n">generate_weight_hash</span><span class="p">(</span>
            <span class="n">address</span><span class="o">=</span><span class="n">wallet</span><span class="o">.</span><span class="n">hotkey</span><span class="o">.</span><span class="n">ss58_address</span><span class="p">,</span>
            <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
            <span class="n">uids</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">uids</span><span class="p">),</span>
            <span class="n">values</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">weights</span><span class="p">),</span>
            <span class="n">salt</span><span class="o">=</span><span class="n">salt</span><span class="p">,</span>
            <span class="n">version_key</span><span class="o">=</span><span class="n">version_key</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">while</span> <span class="n">retries</span> <span class="o">&lt;</span> <span class="n">max_retries</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">success</span><span class="p">,</span> <span class="n">message</span> <span class="o">=</span> <span class="k">await</span> <span class="n">commit_weights_extrinsic</span><span class="p">(</span>
                    <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
                    <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
                    <span class="n">commit_hash</span><span class="o">=</span><span class="n">commit_hash</span><span class="p">,</span>
                    <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                    <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">success</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error committing weights: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="n">retries</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">success</span><span class="p">,</span> <span class="n">message</span></div>
</div>

</pre></div>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Opentensor Foundation
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2024, Opentensor Foundation.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>