
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>bittensor.subtensor &#8212; BTCLI Docs 1.0 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=a3416100" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=fd3f3429" />
    <link rel="stylesheet" type="text/css" href="../../_static/bittensor-custom.css?v=c1dfe055" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../_static/documentation_options.js?v=a681ed88"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/bittensor/subtensor';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/logo.svg" class="logo__image only-light" alt="BTCLI Docs 1.0 documentation - Home"/>
    <script>document.write(`<img src="../../_static/logo-dark-mode.svg" class="logo__image only-dark" alt="BTCLI Docs 1.0 documentation - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../../autoapi/index.html">API Reference</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../autoapi/bittensor/index.html">bittensor</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../autoapi/bittensor/btlogging/index.html">bittensor.btlogging</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/btlogging/defines/index.html">bittensor.btlogging.defines</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/btlogging/format/index.html">bittensor.btlogging.format</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/btlogging/helpers/index.html">bittensor.btlogging.helpers</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/btlogging/loggingmachine/index.html">bittensor.btlogging.loggingmachine</a></li>
</ul>
</details></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../autoapi/bittensor/commands/index.html">bittensor.commands</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/commands/check_coldkey_swap/index.html">bittensor.commands.check_coldkey_swap</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/commands/delegates/index.html">bittensor.commands.delegates</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/commands/identity/index.html">bittensor.commands.identity</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/commands/inspect/index.html">bittensor.commands.inspect</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/commands/list/index.html">bittensor.commands.list</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/commands/metagraph/index.html">bittensor.commands.metagraph</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/commands/misc/index.html">bittensor.commands.misc</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/commands/network/index.html">bittensor.commands.network</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/commands/overview/index.html">bittensor.commands.overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/commands/register/index.html">bittensor.commands.register</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/commands/root/index.html">bittensor.commands.root</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/commands/senate/index.html">bittensor.commands.senate</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/commands/stake/index.html">bittensor.commands.stake</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/commands/transfer/index.html">bittensor.commands.transfer</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/commands/unstake/index.html">bittensor.commands.unstake</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/commands/utils/index.html">bittensor.commands.utils</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/commands/wallets/index.html">bittensor.commands.wallets</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/commands/weights/index.html">bittensor.commands.weights</a></li>
</ul>
</details></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../autoapi/bittensor/extrinsics/index.html">bittensor.extrinsics</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/extrinsics/commit_weights/index.html">bittensor.extrinsics.commit_weights</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/extrinsics/delegation/index.html">bittensor.extrinsics.delegation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/extrinsics/network/index.html">bittensor.extrinsics.network</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/extrinsics/prometheus/index.html">bittensor.extrinsics.prometheus</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/extrinsics/registration/index.html">bittensor.extrinsics.registration</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/extrinsics/root/index.html">bittensor.extrinsics.root</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/extrinsics/senate/index.html">bittensor.extrinsics.senate</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/extrinsics/serving/index.html">bittensor.extrinsics.serving</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/extrinsics/set_weights/index.html">bittensor.extrinsics.set_weights</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/extrinsics/staking/index.html">bittensor.extrinsics.staking</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/extrinsics/transfer/index.html">bittensor.extrinsics.transfer</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/extrinsics/unstaking/index.html">bittensor.extrinsics.unstaking</a></li>
</ul>
</details></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../autoapi/bittensor/mock/index.html">bittensor.mock</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/mock/keyfile_mock/index.html">bittensor.mock.keyfile_mock</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/mock/subtensor_mock/index.html">bittensor.mock.subtensor_mock</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/mock/wallet_mock/index.html">bittensor.mock.wallet_mock</a></li>
</ul>
</details></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../autoapi/bittensor/utils/index.html">bittensor.utils</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/utils/_register_cuda/index.html">bittensor.utils._register_cuda</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/utils/axon_utils/index.html">bittensor.utils.axon_utils</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/utils/balance/index.html">bittensor.utils.balance</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/utils/formatting/index.html">bittensor.utils.formatting</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/utils/networking/index.html">bittensor.utils.networking</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/utils/registration/index.html">bittensor.utils.registration</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/utils/subtensor/index.html">bittensor.utils.subtensor</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/utils/test_utils/index.html">bittensor.utils.test_utils</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/utils/version/index.html">bittensor.utils.version</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/utils/wallet_utils/index.html">bittensor.utils.wallet_utils</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/bittensor/utils/weight_utils/index.html">bittensor.utils.weight_utils</a></li>
</ul>
</details></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/bittensor/axon/index.html">bittensor.axon</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/bittensor/chain_data/index.html">bittensor.chain_data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/bittensor/cli/index.html">bittensor.cli</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/bittensor/config/index.html">bittensor.config</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/bittensor/constants/index.html">bittensor.constants</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/bittensor/dendrite/index.html">bittensor.dendrite</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/bittensor/errors/index.html">bittensor.errors</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/bittensor/keyfile/index.html">bittensor.keyfile</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/bittensor/metagraph/index.html">bittensor.metagraph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/bittensor/stream/index.html">bittensor.stream</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/bittensor/subnets/index.html">bittensor.subnets</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/bittensor/subtensor/index.html">bittensor.subtensor</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/bittensor/synapse/index.html">bittensor.synapse</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/bittensor/tensor/index.html">bittensor.tensor</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/bittensor/threadpool/index.html">bittensor.threadpool</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/bittensor/types/index.html">bittensor.types</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/bittensor/wallet/index.html">bittensor.wallet</a></li>
</ul>
</details></li>
</ul>
</details></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/opentensor/btcli" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/opentensor/btcli/issues/new?title=Issue%20on%20page%20%2F_modules/bittensor/subtensor.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1></h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for bittensor.subtensor</h1><div class="highlight"><pre>
<span></span><span class="c1"># The MIT License (MIT)</span>
<span class="c1"># Copyright © 2021 Yuma Rao</span>
<span class="c1"># Copyright © 2023 Opentensor Foundation</span>

<span class="c1"># Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated</span>
<span class="c1"># documentation files (the “Software”), to deal in the Software without restriction, including without limitation</span>
<span class="c1"># the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,</span>
<span class="c1"># and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</span>

<span class="c1"># The above copyright notice and this permission notice shall be included in all copies or substantial portions of</span>
<span class="c1"># the Software.</span>

<span class="c1"># THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO</span>
<span class="c1"># THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL</span>
<span class="c1"># THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION</span>
<span class="c1"># OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER</span>
<span class="c1"># DEALINGS IN THE SOFTWARE.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The ``bittensor.subtensor`` module in Bittensor serves as a crucial interface for interacting with the Bittensor</span>
<span class="sd">blockchain, facilitating a range of operations essential for the decentralized machine learning network.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">argparse</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">TypedDict</span><span class="p">,</span> <span class="n">Any</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scalecodec</span>
<span class="kn">from</span> <span class="nn">numpy.typing</span> <span class="kn">import</span> <span class="n">NDArray</span>
<span class="kn">from</span> <span class="nn">retry</span> <span class="kn">import</span> <span class="n">retry</span>
<span class="kn">from</span> <span class="nn">scalecodec.base</span> <span class="kn">import</span> <span class="n">RuntimeConfiguration</span>
<span class="kn">from</span> <span class="nn">scalecodec.exceptions</span> <span class="kn">import</span> <span class="n">RemainingScaleBytesNotEmptyException</span>
<span class="kn">from</span> <span class="nn">scalecodec.type_registry</span> <span class="kn">import</span> <span class="n">load_type_registry_preset</span>
<span class="kn">from</span> <span class="nn">scalecodec.types</span> <span class="kn">import</span> <span class="n">GenericCall</span><span class="p">,</span> <span class="n">ScaleType</span>
<span class="kn">from</span> <span class="nn">substrateinterface.base</span> <span class="kn">import</span> <span class="n">QueryMapResult</span><span class="p">,</span> <span class="n">SubstrateInterface</span><span class="p">,</span> <span class="n">ExtrinsicReceipt</span>
<span class="kn">from</span> <span class="nn">substrateinterface.exceptions</span> <span class="kn">import</span> <span class="n">SubstrateRequestException</span>

<span class="kn">import</span> <span class="nn">bittensor</span>
<span class="kn">from</span> <span class="nn">bittensor.btlogging</span> <span class="kn">import</span> <span class="n">logging</span> <span class="k">as</span> <span class="n">_logger</span>
<span class="kn">from</span> <span class="nn">bittensor.utils</span> <span class="kn">import</span> <span class="n">torch</span><span class="p">,</span> <span class="n">weight_utils</span><span class="p">,</span> <span class="n">format_error_message</span>
<span class="kn">from</span> <span class="nn">.chain_data</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">DelegateInfoLite</span><span class="p">,</span>
    <span class="n">NeuronInfo</span><span class="p">,</span>
    <span class="n">DelegateInfo</span><span class="p">,</span>
    <span class="n">PrometheusInfo</span><span class="p">,</span>
    <span class="n">SubnetInfo</span><span class="p">,</span>
    <span class="n">SubnetHyperparameters</span><span class="p">,</span>
    <span class="n">StakeInfo</span><span class="p">,</span>
    <span class="n">NeuronInfoLite</span><span class="p">,</span>
    <span class="n">AxonInfo</span><span class="p">,</span>
    <span class="n">ProposalVoteData</span><span class="p">,</span>
    <span class="n">IPInfo</span><span class="p">,</span>
    <span class="n">custom_rpc_type_registry</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.errors</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">IdentityError</span><span class="p">,</span>
    <span class="n">NominationError</span><span class="p">,</span>
    <span class="n">StakeError</span><span class="p">,</span>
    <span class="n">TakeError</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.extrinsics.commit_weights</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">commit_weights_extrinsic</span><span class="p">,</span>
    <span class="n">reveal_weights_extrinsic</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.extrinsics.delegation</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">delegate_extrinsic</span><span class="p">,</span>
    <span class="n">nominate_extrinsic</span><span class="p">,</span>
    <span class="n">undelegate_extrinsic</span><span class="p">,</span>
    <span class="n">increase_take_extrinsic</span><span class="p">,</span>
    <span class="n">decrease_take_extrinsic</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.extrinsics.network</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">register_subnetwork_extrinsic</span><span class="p">,</span>
    <span class="n">set_hyperparameter_extrinsic</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.extrinsics.prometheus</span> <span class="kn">import</span> <span class="n">prometheus_extrinsic</span>
<span class="kn">from</span> <span class="nn">.extrinsics.registration</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">register_extrinsic</span><span class="p">,</span>
    <span class="n">burned_register_extrinsic</span><span class="p">,</span>
    <span class="n">run_faucet_extrinsic</span><span class="p">,</span>
    <span class="n">swap_hotkey_extrinsic</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.extrinsics.root</span> <span class="kn">import</span> <span class="n">root_register_extrinsic</span><span class="p">,</span> <span class="n">set_root_weights_extrinsic</span>
<span class="kn">from</span> <span class="nn">.extrinsics.senate</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">register_senate_extrinsic</span><span class="p">,</span>
    <span class="n">leave_senate_extrinsic</span><span class="p">,</span>
    <span class="n">vote_senate_extrinsic</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.extrinsics.serving</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">serve_extrinsic</span><span class="p">,</span>
    <span class="n">serve_axon_extrinsic</span><span class="p">,</span>
    <span class="n">publish_metadata</span><span class="p">,</span>
    <span class="n">get_metadata</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.extrinsics.set_weights</span> <span class="kn">import</span> <span class="n">set_weights_extrinsic</span>
<span class="kn">from</span> <span class="nn">.extrinsics.staking</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">add_stake_extrinsic</span><span class="p">,</span>
    <span class="n">add_stake_multiple_extrinsic</span><span class="p">,</span>
    <span class="n">set_children_extrinsic</span><span class="p">,</span>
    <span class="n">set_childkey_take_extrinsic</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.extrinsics.transfer</span> <span class="kn">import</span> <span class="n">transfer_extrinsic</span>
<span class="kn">from</span> <span class="nn">.extrinsics.unstaking</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">unstake_extrinsic</span><span class="p">,</span>
    <span class="n">unstake_multiple_extrinsic</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.types</span> <span class="kn">import</span> <span class="n">AxonServeCallParams</span><span class="p">,</span> <span class="n">PrometheusServeCallParams</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">U16_NORMALIZED_FLOAT</span><span class="p">,</span>
    <span class="n">ss58_to_vec_u8</span><span class="p">,</span>
    <span class="n">U64_NORMALIZED_FLOAT</span><span class="p">,</span>
    <span class="n">networking</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.utils.balance</span> <span class="kn">import</span> <span class="n">Balance</span>
<span class="kn">from</span> <span class="nn">.utils.registration</span> <span class="kn">import</span> <span class="n">POWSolution</span>
<span class="kn">from</span> <span class="nn">.utils.registration</span> <span class="kn">import</span> <span class="n">legacy_torch_api_compat</span>
<span class="kn">from</span> <span class="nn">.utils.subtensor</span> <span class="kn">import</span> <span class="n">get_subtensor_errors</span><span class="p">,</span> <span class="n">format_parent</span><span class="p">,</span> <span class="n">format_children</span>

<span class="n">KEY_NONCE</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>


<div class="viewcode-block" id="ParamWithTypes">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.ParamWithTypes">[docs]</a>
<span class="k">class</span> <span class="nc">ParamWithTypes</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>  <span class="c1"># Name of the parameter.</span>
    <span class="nb">type</span><span class="p">:</span> <span class="nb">str</span>  <span class="c1"># ScaleType string of the parameter.</span></div>



<div class="viewcode-block" id="Subtensor">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor">[docs]</a>
<span class="k">class</span> <span class="nc">Subtensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The Subtensor class in Bittensor serves as a crucial interface for interacting with the Bittensor blockchain,</span>
<span class="sd">    facilitating a range of operations essential for the decentralized machine learning network.</span>

<span class="sd">    This class enables neurons (network participants) to engage in activities such as registering on the network,</span>
<span class="sd">    managing staked weights, setting inter-neuronal weights, and participating in consensus mechanisms.</span>

<span class="sd">    The Bittensor network operates on a digital ledger where each neuron holds stakes (S) and learns a set</span>
<span class="sd">    of inter-peer weights (W). These weights, set by the neurons themselves, play a critical role in determining</span>
<span class="sd">    the ranking and incentive mechanisms within the network. Higher-ranked neurons, as determined by their</span>
<span class="sd">    contributions and trust within the network, receive more incentives.</span>

<span class="sd">    The Subtensor class connects to various Bittensor networks like the main ``finney`` network or local test</span>
<span class="sd">    networks, providing a gateway to the blockchain layer of Bittensor. It leverages a staked weighted trust</span>
<span class="sd">    system and consensus to ensure fair and distributed incentive mechanisms, where incentives (I) are</span>
<span class="sd">    primarily allocated to neurons that are trusted by the majority of the network.</span>

<span class="sd">    Additionally, Bittensor introduces a speculation-based reward mechanism in the form of bonds (B), allowing</span>
<span class="sd">    neurons to accumulate bonds in other neurons, speculating on their future value. This mechanism aligns</span>
<span class="sd">    with market-based speculation, incentivizing neurons to make judicious decisions in their inter-neuronal</span>
<span class="sd">    investments.</span>

<span class="sd">    Example Usage::</span>

<span class="sd">        # Connect to the main Bittensor network (Finney).</span>
<span class="sd">        finney_subtensor = subtensor(network=&#39;finney&#39;)</span>

<span class="sd">        # Close websocket connection with the Bittensor network.</span>
<span class="sd">        finney_subtensor.close()</span>

<span class="sd">        # (Re)creates the websocket connection with the Bittensor network.</span>
<span class="sd">        finney_subtensor.connect_websocket()</span>

<span class="sd">        # Register a new neuron on the network.</span>
<span class="sd">        wallet = bittensor.wallet(...)  # Assuming a wallet instance is created.</span>
<span class="sd">        success = finney_subtensor.register(wallet=wallet, netuid=netuid)</span>

<span class="sd">        # Set inter-neuronal weights for collaborative learning.</span>
<span class="sd">        success = finney_subtensor.set_weights(wallet=wallet, netuid=netuid, uids=[...], weights=[...])</span>

<span class="sd">        # Speculate by accumulating bonds in other promising neurons.</span>
<span class="sd">        success = finney_subtensor.delegate(wallet=wallet, delegate_ss58=other_neuron_ss58, amount=bond_amount)</span>

<span class="sd">        # Get the metagraph for a specific subnet using given subtensor connection</span>
<span class="sd">        metagraph = subtensor.metagraph(netuid=netuid)</span>

<span class="sd">    By facilitating these operations, the Subtensor class is instrumental in maintaining the decentralized</span>
<span class="sd">    intelligence and dynamic learning environment of the Bittensor network, as envisioned in its foundational</span>
<span class="sd">    principles and mechanisms described in the `NeurIPS paper</span>
<span class="sd">    &lt;https://bittensor.com/pdfs/academia/NeurIPS_DAO_Workshop_2022_3_3.pdf&gt;`_. paper.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">network</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">config</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">bittensor</span><span class="o">.</span><span class="n">config</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">_mock</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">log_verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">connection_timeout</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">600</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes a Subtensor interface for interacting with the Bittensor blockchain.</span>

<span class="sd">        NOTE:</span>
<span class="sd">            Currently subtensor defaults to the ``finney`` network. This will change in a future release.</span>

<span class="sd">        We strongly encourage users to run their own local subtensor node whenever possible. This increases</span>
<span class="sd">        decentralization and resilience of the network. In a future release, local subtensor will become the</span>
<span class="sd">        default and the fallback to ``finney`` removed. Please plan ahead for this change. We will provide detailed</span>
<span class="sd">        instructions on how to run a local subtensor node in the documentation in a subsequent release.</span>

<span class="sd">        Args:</span>
<span class="sd">            network (str, optional): The network name to connect to (e.g., ``finney``, ``local``). This can also be the</span>
<span class="sd">                chain endpoint (e.g., ``wss://entrypoint-finney.opentensor.ai:443``) and will be correctly parsed into</span>
<span class="sd">                the network and chain endpoint. If not specified, defaults to the main Bittensor network.</span>
<span class="sd">            config (bittensor.config, optional): Configuration object for the subtensor. If not provided, a default</span>
<span class="sd">                configuration is used.</span>
<span class="sd">            _mock (bool, optional): If set to ``True``, uses a mocked connection for testing purposes.</span>

<span class="sd">        This initialization sets up the connection to the specified Bittensor network, allowing for various</span>
<span class="sd">        blockchain operations such as neuron registration, stake management, and setting weights.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Determine config.subtensor.chain_endpoint and config.subtensor.network config.</span>
        <span class="c1"># If chain_endpoint is set, we override the network flag, otherwise, the chain_endpoint is assigned by the</span>
        <span class="c1"># network.</span>
        <span class="c1"># Argument importance: network &gt; chain_endpoint &gt; config.subtensor.chain_endpoint &gt; config.subtensor.network</span>

        <span class="c1"># Check if network is a config object. (Single argument passed as first positional)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">network</span><span class="p">,</span> <span class="n">bittensor</span><span class="o">.</span><span class="n">config</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">network</span><span class="o">.</span><span class="n">subtensor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;If passing a bittensor config object, it must not be empty. Using default subtensor config.&quot;</span>
                <span class="p">)</span>
                <span class="n">config</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">config</span> <span class="o">=</span> <span class="n">network</span>
            <span class="n">network</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">config</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">config</span> <span class="o">=</span> <span class="n">Subtensor</span><span class="o">.</span><span class="n">config</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

        <span class="c1"># Setup config.subtensor.network and config.subtensor.chain_endpoint</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chain_endpoint</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span> <span class="o">=</span> <span class="n">Subtensor</span><span class="o">.</span><span class="n">setup_config</span><span class="p">(</span><span class="n">network</span><span class="p">,</span> <span class="n">config</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">network</span> <span class="o">==</span> <span class="s2">&quot;finney&quot;</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">chain_endpoint</span> <span class="o">==</span> <span class="n">bittensor</span><span class="o">.</span><span class="n">__finney_entrypoint__</span>
        <span class="p">)</span> <span class="ow">and</span> <span class="n">log_verbose</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;You are connecting to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="si">}</span><span class="s2"> network with endpoint </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_endpoint</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;We strongly encourage running a local subtensor node whenever possible. &quot;</span>
                <span class="s2">&quot;This increases decentralization and resilience of the network.&quot;</span>
            <span class="p">)</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;In a future release, local subtensor will become the default endpoint. &quot;</span>
                <span class="s2">&quot;To get ahead of this change, please run a local subtensor node and point to it.&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log_verbose</span> <span class="o">=</span> <span class="n">log_verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_connection_timeout</span> <span class="o">=</span> <span class="n">connection_timeout</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_get_substrate</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_subtensor_errors</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>

<div class="viewcode-block" id="Subtensor.__str__">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.__str__">[docs]</a>
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">chain_endpoint</span><span class="p">:</span>
            <span class="c1"># Connecting to chain endpoint without network known.</span>
            <span class="k">return</span> <span class="s2">&quot;subtensor(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_endpoint</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Connecting to network with endpoint known.</span>
            <span class="k">return</span> <span class="s2">&quot;subtensor(</span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chain_endpoint</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.__repr__">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.__repr__">[docs]</a>
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span></div>


<div class="viewcode-block" id="Subtensor._get_substrate">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor._get_substrate">[docs]</a>
    <span class="k">def</span> <span class="nf">_get_substrate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Establishes a connection to the Substrate node using configured parameters.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Set up params.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span> <span class="o">=</span> <span class="n">SubstrateInterface</span><span class="p">(</span>
                <span class="n">ss58_format</span><span class="o">=</span><span class="n">bittensor</span><span class="o">.</span><span class="n">__ss58_format__</span><span class="p">,</span>
                <span class="n">use_remote_preset</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">url</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_endpoint</span><span class="p">,</span>
                <span class="n">type_registry</span><span class="o">=</span><span class="n">bittensor</span><span class="o">.</span><span class="n">__type_registry__</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_verbose</span><span class="p">:</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Connected to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="si">}</span><span class="s2"> network and </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_endpoint</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>

        <span class="k">except</span> <span class="ne">ConnectionRefusedError</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Could not connect to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="si">}</span><span class="s2"> network with </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_endpoint</span><span class="si">}</span><span class="s2"> chain endpoint. Exiting...&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;You can check if you have connectivity by running this command: nc -vz localhost &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_endpoint</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">websocket</span><span class="o">.</span><span class="n">settimeout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_connection_timeout</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;AttributeError: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;TypeError: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="ne">OSError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Socket error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.config">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.config">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">config</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="s2">&quot;bittensor.config&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates and returns a Bittensor configuration object.</span>

<span class="sd">        Returns:</span>
<span class="sd">            config (bittensor.config): A Bittensor configuration object configured with arguments added by the</span>
<span class="sd">                `subtensor.add_args` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
        <span class="n">Subtensor</span><span class="o">.</span><span class="n">add_args</span><span class="p">(</span><span class="n">parser</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bittensor</span><span class="o">.</span><span class="n">config</span><span class="p">(</span><span class="n">parser</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">[])</span></div>


<div class="viewcode-block" id="Subtensor.help">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.help">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">help</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Print help to stdout.&quot;&quot;&quot;</span>
        <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">add_args</span><span class="p">(</span><span class="n">parser</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="fm">__new__</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
        <span class="n">parser</span><span class="o">.</span><span class="n">print_help</span><span class="p">()</span></div>


<div class="viewcode-block" id="Subtensor.add_args">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.add_args">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">add_args</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">parser</span><span class="p">:</span> <span class="s2">&quot;argparse.ArgumentParser&quot;</span><span class="p">,</span> <span class="n">prefix</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds command-line arguments to the provided ArgumentParser for configuring the Subtensor settings.</span>

<span class="sd">        Args:</span>
<span class="sd">            parser (argparse.ArgumentParser): The ArgumentParser object to which the Subtensor arguments will be added.</span>
<span class="sd">            prefix (Optional[str]): An optional prefix for the argument names. If provided, the prefix is prepended to</span>
<span class="sd">                each argument name.</span>

<span class="sd">        Arguments added:</span>
<span class="sd">            --subtensor.network: The Subtensor network flag. Possible values are &#39;finney&#39;, &#39;test&#39;, &#39;archive&#39;, and</span>
<span class="sd">                &#39;local&#39;. Overrides the chain endpoint if set.</span>
<span class="sd">            --subtensor.chain_endpoint: The Subtensor chain endpoint flag. If set, it overrides the network flag.</span>
<span class="sd">            --subtensor._mock: If true, uses a mocked connection to the chain.</span>

<span class="sd">        Example:</span>
<span class="sd">            parser = argparse.ArgumentParser()</span>
<span class="sd">            Subtensor.add_args(parser)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">prefix_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="n">prefix</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">default_network</span> <span class="o">=</span> <span class="n">bittensor</span><span class="o">.</span><span class="n">__networks__</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">default_chain_endpoint</span> <span class="o">=</span> <span class="n">bittensor</span><span class="o">.</span><span class="n">__finney_entrypoint__</span>

            <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;--</span><span class="si">{</span><span class="n">prefix_str</span><span class="si">}</span><span class="s2">subtensor.network&quot;</span><span class="p">,</span>
                <span class="n">default</span><span class="o">=</span><span class="n">default_network</span><span class="p">,</span>
                <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
                <span class="n">help</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;The subtensor network flag. The likely choices are:</span>
<span class="s2">                                        -- finney (main network)</span>
<span class="s2">                                        -- test (test network)</span>
<span class="s2">                                        -- archive (archive network +300 blocks)</span>
<span class="s2">                                        -- local (local running network)</span>
<span class="s2">                                    If this option is set it overloads subtensor.chain_endpoint with</span>
<span class="s2">                                    an entry point node from that network.</span>
<span class="s2">                                    &quot;&quot;&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;--</span><span class="si">{</span><span class="n">prefix_str</span><span class="si">}</span><span class="s2">subtensor.chain_endpoint&quot;</span><span class="p">,</span>
                <span class="n">default</span><span class="o">=</span><span class="n">default_chain_endpoint</span><span class="p">,</span>
                <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
                <span class="n">help</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;The subtensor endpoint flag. If set, overrides the --network flag.&quot;&quot;&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;--</span><span class="si">{</span><span class="n">prefix_str</span><span class="si">}</span><span class="s2">subtensor._mock&quot;</span><span class="p">,</span>
                <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="nb">type</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span>
                <span class="n">help</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;If true, uses a mocked connection to the chain.&quot;&quot;&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">except</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">:</span>
            <span class="c1"># re-parsing arguments.</span>
            <span class="k">pass</span></div>


<div class="viewcode-block" id="Subtensor.determine_chain_endpoint_and_network">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.determine_chain_endpoint_and_network">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">determine_chain_endpoint_and_network</span><span class="p">(</span><span class="n">network</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Determines the chain endpoint and network from the passed network or chain_endpoint.</span>

<span class="sd">        Args:</span>
<span class="sd">            network (str): The network flag. The choices are: ``-- finney`` (main network), ``-- archive``</span>
<span class="sd">                (archive network +300 blocks), ``-- local`` (local running network), ``-- test`` (test network).</span>
<span class="sd">        Returns:</span>
<span class="sd">            network (str): The network flag.</span>
<span class="sd">            chain_endpoint (str): The chain endpoint flag. If set, overrides the ``network`` argument.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">network</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">network</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;finney&quot;</span><span class="p">,</span> <span class="s2">&quot;local&quot;</span><span class="p">,</span> <span class="s2">&quot;test&quot;</span><span class="p">,</span> <span class="s2">&quot;archive&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">network</span> <span class="o">==</span> <span class="s2">&quot;finney&quot;</span><span class="p">:</span>
                <span class="c1"># Kiru Finney staging network.</span>
                <span class="k">return</span> <span class="n">network</span><span class="p">,</span> <span class="n">bittensor</span><span class="o">.</span><span class="n">__finney_entrypoint__</span>
            <span class="k">elif</span> <span class="n">network</span> <span class="o">==</span> <span class="s2">&quot;local&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">network</span><span class="p">,</span> <span class="n">bittensor</span><span class="o">.</span><span class="n">__local_entrypoint__</span>
            <span class="k">elif</span> <span class="n">network</span> <span class="o">==</span> <span class="s2">&quot;test&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">network</span><span class="p">,</span> <span class="n">bittensor</span><span class="o">.</span><span class="n">__finney_test_entrypoint__</span>
            <span class="k">elif</span> <span class="n">network</span> <span class="o">==</span> <span class="s2">&quot;archive&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">network</span><span class="p">,</span> <span class="n">bittensor</span><span class="o">.</span><span class="n">__archive_entrypoint__</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">network</span> <span class="o">==</span> <span class="n">bittensor</span><span class="o">.</span><span class="n">__finney_entrypoint__</span>
                <span class="ow">or</span> <span class="s2">&quot;entrypoint-finney.opentensor.ai&quot;</span> <span class="ow">in</span> <span class="n">network</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="s2">&quot;finney&quot;</span><span class="p">,</span> <span class="n">bittensor</span><span class="o">.</span><span class="n">__finney_entrypoint__</span>
            <span class="k">elif</span> <span class="p">(</span>
                <span class="n">network</span> <span class="o">==</span> <span class="n">bittensor</span><span class="o">.</span><span class="n">__finney_test_entrypoint__</span>
                <span class="ow">or</span> <span class="s2">&quot;test.finney.opentensor.ai&quot;</span> <span class="ow">in</span> <span class="n">network</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="s2">&quot;test&quot;</span><span class="p">,</span> <span class="n">bittensor</span><span class="o">.</span><span class="n">__finney_test_entrypoint__</span>
            <span class="k">elif</span> <span class="p">(</span>
                <span class="n">network</span> <span class="o">==</span> <span class="n">bittensor</span><span class="o">.</span><span class="n">__archive_entrypoint__</span>
                <span class="ow">or</span> <span class="s2">&quot;archive.chain.opentensor.ai&quot;</span> <span class="ow">in</span> <span class="n">network</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="s2">&quot;archive&quot;</span><span class="p">,</span> <span class="n">bittensor</span><span class="o">.</span><span class="n">__archive_entrypoint__</span>
            <span class="k">elif</span> <span class="s2">&quot;127.0.0.1&quot;</span> <span class="ow">in</span> <span class="n">network</span> <span class="ow">or</span> <span class="s2">&quot;localhost&quot;</span> <span class="ow">in</span> <span class="n">network</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;local&quot;</span><span class="p">,</span> <span class="n">network</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;unknown network&quot;</span><span class="p">,</span> <span class="n">network</span></div>


<div class="viewcode-block" id="Subtensor.setup_config">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.setup_config">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">setup_config</span><span class="p">(</span><span class="n">network</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">config</span><span class="p">:</span> <span class="s2">&quot;bittensor.config&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets up and returns the configuration for the Subtensor network and endpoint.</span>

<span class="sd">        This method determines the appropriate network and chain endpoint based on the provided network string or</span>
<span class="sd">        configuration object. It evaluates the network and endpoint in the following order of precedence:</span>
<span class="sd">        1. Provided network string.</span>
<span class="sd">        2. Configured chain endpoint in the `config` object.</span>
<span class="sd">        3. Configured network in the `config` object.</span>
<span class="sd">        4. Default chain endpoint.</span>
<span class="sd">        5. Default network.</span>

<span class="sd">        Args:</span>
<span class="sd">            network (str): The name of the Subtensor network. If None, the network and endpoint will be determined from</span>
<span class="sd">                the `config` object.</span>
<span class="sd">            config (bittensor.config): The configuration object containing the network and chain endpoint settings.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple: A tuple containing the formatted WebSocket endpoint URL and the evaluated network name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">network</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="p">(</span>
                <span class="n">evaluated_network</span><span class="p">,</span>
                <span class="n">evaluated_endpoint</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">=</span> <span class="n">Subtensor</span><span class="o">.</span><span class="n">determine_chain_endpoint_and_network</span><span class="p">(</span><span class="n">network</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;__is_set&quot;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;subtensor.chain_endpoint&quot;</span><span class="p">):</span>
                <span class="p">(</span>
                    <span class="n">evaluated_network</span><span class="p">,</span>
                    <span class="n">evaluated_endpoint</span><span class="p">,</span>
                <span class="p">)</span> <span class="o">=</span> <span class="n">Subtensor</span><span class="o">.</span><span class="n">determine_chain_endpoint_and_network</span><span class="p">(</span>
                    <span class="n">config</span><span class="o">.</span><span class="n">subtensor</span><span class="o">.</span><span class="n">chain_endpoint</span>
                <span class="p">)</span>

            <span class="k">elif</span> <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;__is_set&quot;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;subtensor.network&quot;</span><span class="p">):</span>
                <span class="p">(</span>
                    <span class="n">evaluated_network</span><span class="p">,</span>
                    <span class="n">evaluated_endpoint</span><span class="p">,</span>
                <span class="p">)</span> <span class="o">=</span> <span class="n">Subtensor</span><span class="o">.</span><span class="n">determine_chain_endpoint_and_network</span><span class="p">(</span>
                    <span class="n">config</span><span class="o">.</span><span class="n">subtensor</span><span class="o">.</span><span class="n">network</span>
                <span class="p">)</span>

            <span class="k">elif</span> <span class="n">config</span><span class="o">.</span><span class="n">subtensor</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;chain_endpoint&quot;</span><span class="p">):</span>
                <span class="p">(</span>
                    <span class="n">evaluated_network</span><span class="p">,</span>
                    <span class="n">evaluated_endpoint</span><span class="p">,</span>
                <span class="p">)</span> <span class="o">=</span> <span class="n">Subtensor</span><span class="o">.</span><span class="n">determine_chain_endpoint_and_network</span><span class="p">(</span>
                    <span class="n">config</span><span class="o">.</span><span class="n">subtensor</span><span class="o">.</span><span class="n">chain_endpoint</span>
                <span class="p">)</span>

            <span class="k">elif</span> <span class="n">config</span><span class="o">.</span><span class="n">subtensor</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;network&quot;</span><span class="p">):</span>
                <span class="p">(</span>
                    <span class="n">evaluated_network</span><span class="p">,</span>
                    <span class="n">evaluated_endpoint</span><span class="p">,</span>
                <span class="p">)</span> <span class="o">=</span> <span class="n">Subtensor</span><span class="o">.</span><span class="n">determine_chain_endpoint_and_network</span><span class="p">(</span>
                    <span class="n">config</span><span class="o">.</span><span class="n">subtensor</span><span class="o">.</span><span class="n">network</span>
                <span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="p">(</span>
                    <span class="n">evaluated_network</span><span class="p">,</span>
                    <span class="n">evaluated_endpoint</span><span class="p">,</span>
                <span class="p">)</span> <span class="o">=</span> <span class="n">Subtensor</span><span class="o">.</span><span class="n">determine_chain_endpoint_and_network</span><span class="p">(</span>
                    <span class="n">bittensor</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">subtensor</span><span class="o">.</span><span class="n">network</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">networking</span><span class="o">.</span><span class="n">get_formatted_ws_endpoint_url</span><span class="p">(</span><span class="n">evaluated_endpoint</span><span class="p">),</span>
            <span class="n">evaluated_network</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.close">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.close">[docs]</a>
    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Cleans up resources for this subtensor instance like active websocket connection and active extensions.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>


    <span class="c1">##############</span>
    <span class="c1"># Delegation #</span>
    <span class="c1">##############</span>
<div class="viewcode-block" id="Subtensor.nominate">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.nominate">[docs]</a>
    <span class="k">def</span> <span class="nf">nominate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Becomes a delegate for the hotkey associated with the given wallet. This method is used to nominate</span>
<span class="sd">        a neuron (identified by the hotkey in the wallet) as a delegate on the Bittensor network, allowing it</span>
<span class="sd">        to participate in consensus and validation processes.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet containing the hotkey to be nominated.</span>
<span class="sd">            wait_for_finalization (bool, optional): If ``True``, waits until the transaction is finalized on the</span>
<span class="sd">                blockchain.</span>
<span class="sd">            wait_for_inclusion (bool, optional): If ``True``, waits until the transaction is included in a block.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the nomination process is successful, ``False`` otherwise.</span>

<span class="sd">        This function is a key part of the decentralized governance mechanism of Bittensor, allowing for the</span>
<span class="sd">        dynamic selection and participation of validators in the network&#39;s consensus process.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">nominate_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.delegate">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.delegate">[docs]</a>
    <span class="k">def</span> <span class="nf">delegate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">delegate_ss58</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">amount</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Balance</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">prompt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Becomes a delegate for the hotkey associated with the given wallet. This method is used to nominate</span>
<span class="sd">        a neuron (identified by the hotkey in the wallet) as a delegate on the Bittensor network, allowing it</span>
<span class="sd">        to participate in consensus and validation processes.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet containing the hotkey to be nominated.</span>
<span class="sd">            delegate_ss58 (Optional[str]): The ``SS58`` address of the delegate neuron.</span>
<span class="sd">            amount (Union[Balance, float]): The amount of TAO to undelegate.</span>
<span class="sd">            wait_for_finalization (bool, optional): If ``True``, waits until the transaction is finalized on the</span>
<span class="sd">                blockchain.</span>
<span class="sd">            wait_for_inclusion (bool, optional): If ``True``, waits until the transaction is included in a block.</span>
<span class="sd">            prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the nomination process is successful, False otherwise.</span>

<span class="sd">        This function is a key part of the decentralized governance mechanism of Bittensor, allowing for the</span>
<span class="sd">        dynamic selection and participation of validators in the network&#39;s consensus process.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">delegate_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">delegate_ss58</span><span class="o">=</span><span class="n">delegate_ss58</span><span class="p">,</span>
            <span class="n">amount</span><span class="o">=</span><span class="n">amount</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">prompt</span><span class="o">=</span><span class="n">prompt</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.undelegate">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.undelegate">[docs]</a>
    <span class="k">def</span> <span class="nf">undelegate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">delegate_ss58</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">amount</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Balance</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">prompt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes a specified amount of stake from a delegate neuron using the provided wallet. This action</span>
<span class="sd">        reduces the staked amount on another neuron, effectively withdrawing support or speculation.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet used for the undelegation process.</span>
<span class="sd">            delegate_ss58 (Optional[str]): The ``SS58`` address of the delegate neuron.</span>
<span class="sd">            amount (Union[Balance, float]): The amount of TAO to undelegate.</span>
<span class="sd">            wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.</span>
<span class="sd">            wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.</span>
<span class="sd">            prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the undelegation is successful, False otherwise.</span>

<span class="sd">        This function reflects the dynamic and speculative nature of the Bittensor network, allowing neurons</span>
<span class="sd">        to adjust their stakes and investments based on changing perceptions and performances within the network.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">undelegate_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">delegate_ss58</span><span class="o">=</span><span class="n">delegate_ss58</span><span class="p">,</span>
            <span class="n">amount</span><span class="o">=</span><span class="n">amount</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">prompt</span><span class="o">=</span><span class="n">prompt</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.set_take">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.set_take">[docs]</a>
    <span class="k">def</span> <span class="nf">set_take</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">delegate_ss58</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">take</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set delegate hotkey take</span>
<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet containing the hotkey to be nominated.</span>
<span class="sd">            delegate_ss58 (str, optional): Hotkey</span>
<span class="sd">            take (float): Delegate take on subnet ID</span>
<span class="sd">            wait_for_finalization (bool, optional): If ``True``, waits until the transaction is finalized on the</span>
<span class="sd">                blockchain.</span>
<span class="sd">            wait_for_inclusion (bool, optional): If ``True``, waits until the transaction is included in a block.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the process is successful, False otherwise.</span>

<span class="sd">        This function is a key part of the decentralized governance mechanism of Bittensor, allowing for the</span>
<span class="sd">        dynamic selection and participation of validators in the network&#39;s consensus process.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ensure delegate_ss58 is not None</span>
        <span class="k">if</span> <span class="n">delegate_ss58</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;delegate_ss58 cannot be None&quot;</span><span class="p">)</span>

        <span class="c1"># Calculate u16 representation of the take</span>
        <span class="n">takeu16</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">take</span> <span class="o">*</span> <span class="mh">0xFFFF</span><span class="p">)</span>

        <span class="c1"># Check if the new take is greater or lower than existing take or if existing is set</span>
        <span class="n">delegate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_delegate_by_hotkey</span><span class="p">(</span><span class="n">delegate_ss58</span><span class="p">)</span>
        <span class="n">current_take</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">delegate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">current_take</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">delegate</span><span class="o">.</span><span class="n">take</span><span class="p">)</span> <span class="o">*</span> <span class="mf">65535.0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">takeu16</span> <span class="o">==</span> <span class="n">current_take</span><span class="p">:</span>
            <span class="n">bittensor</span><span class="o">.</span><span class="n">__console__</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s2">&quot;Nothing to do, take hasn&#39;t changed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">current_take</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">current_take</span> <span class="o">&lt;</span> <span class="n">takeu16</span><span class="p">:</span>
            <span class="n">bittensor</span><span class="o">.</span><span class="n">__console__</span><span class="o">.</span><span class="n">print</span><span class="p">(</span>
                <span class="s2">&quot;Current take is either not set or is lower than the new one. Will use increase_take&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">increase_take_extrinsic</span><span class="p">(</span>
                <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
                <span class="n">hotkey_ss58</span><span class="o">=</span><span class="n">delegate_ss58</span><span class="p">,</span>
                <span class="n">take</span><span class="o">=</span><span class="n">takeu16</span><span class="p">,</span>
                <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bittensor</span><span class="o">.</span><span class="n">__console__</span><span class="o">.</span><span class="n">print</span><span class="p">(</span>
                <span class="s2">&quot;Current take is higher than the new one. Will use decrease_take&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">decrease_take_extrinsic</span><span class="p">(</span>
                <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
                <span class="n">hotkey_ss58</span><span class="o">=</span><span class="n">delegate_ss58</span><span class="p">,</span>
                <span class="n">take</span><span class="o">=</span><span class="n">takeu16</span><span class="p">,</span>
                <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.send_extrinsic">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.send_extrinsic">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">send_extrinsic</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">module</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">function</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
        <span class="n">period</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_retries</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
        <span class="n">wait_time</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
        <span class="n">max_wait</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ExtrinsicReceipt</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sends an extrinsic to the Bittensor blockchain using the provided wallet and parameters. This method</span>
<span class="sd">        constructs and submits the extrinsic, handling retries and blockchain communication.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet associated with the extrinsic.</span>
<span class="sd">            module (str): The module name for the extrinsic.</span>
<span class="sd">            function (str): The function name for the extrinsic.</span>
<span class="sd">            params (dict): The parameters for the extrinsic.</span>
<span class="sd">            period (int, optional): The number of blocks for the extrinsic to live in the mempool. Defaults to 5.</span>
<span class="sd">            wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.</span>
<span class="sd">            wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.</span>
<span class="sd">            max_retries (int, optional): The maximum number of retries for the extrinsic. Defaults to 3.</span>
<span class="sd">            wait_time (int, optional): The wait time between retries. Defaults to 3.</span>
<span class="sd">            max_wait (int, optional): The maximum wait time for the extrinsic. Defaults to 20.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[ExtrinsicReceipt]: The receipt of the extrinsic if successful, None otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">compose_call</span><span class="p">(</span>
            <span class="n">call_module</span><span class="o">=</span><span class="n">module</span><span class="p">,</span>
            <span class="n">call_function</span><span class="o">=</span><span class="n">function</span><span class="p">,</span>
            <span class="n">call_params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">hotkey</span> <span class="o">=</span> <span class="n">wallet</span><span class="o">.</span><span class="n">get_hotkey</span><span class="p">()</span><span class="o">.</span><span class="n">ss58_address</span>
        <span class="c1"># Periodically update the nonce cache</span>
        <span class="k">if</span> <span class="n">hotkey</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">KEY_NONCE</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_current_block</span><span class="p">()</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">KEY_NONCE</span><span class="p">[</span><span class="n">hotkey</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_account_nonce</span><span class="p">(</span><span class="n">hotkey</span><span class="p">)</span>

        <span class="n">nonce</span> <span class="o">=</span> <span class="n">KEY_NONCE</span><span class="p">[</span><span class="n">hotkey</span><span class="p">]</span>

        <span class="c1"># &lt;3 parity tech</span>
        <span class="n">old_init_runtime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">init_runtime</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">init_runtime</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">init_runtime</span> <span class="o">=</span> <span class="n">old_init_runtime</span>
        <span class="n">response</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">attempt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_retries</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Create the extrinsic with new nonce</span>
                <span class="n">extrinsic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">create_signed_extrinsic</span><span class="p">(</span>
                    <span class="n">call</span><span class="o">=</span><span class="n">call</span><span class="p">,</span>
                    <span class="n">keypair</span><span class="o">=</span><span class="n">wallet</span><span class="o">.</span><span class="n">hotkey</span><span class="p">,</span>
                    <span class="n">era</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;period&quot;</span><span class="p">:</span> <span class="n">period</span><span class="p">},</span>
                    <span class="n">nonce</span><span class="o">=</span><span class="n">nonce</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="c1"># Submit the extrinsic</span>
                <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">submit_extrinsic</span><span class="p">(</span>
                    <span class="n">extrinsic</span><span class="p">,</span>
                    <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                    <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="c1"># Return immediately if we don&#39;t wait</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">wait_for_inclusion</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">wait_for_finalization</span><span class="p">:</span>
                    <span class="n">KEY_NONCE</span><span class="p">[</span><span class="n">hotkey</span><span class="p">]</span> <span class="o">=</span> <span class="n">nonce</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># update the nonce cache</span>
                    <span class="k">return</span> <span class="n">response</span>

                <span class="c1"># If we wait for finalization or inclusion, check if it is successful</span>
                <span class="k">if</span> <span class="n">response</span><span class="o">.</span><span class="n">is_success</span><span class="p">:</span>
                    <span class="n">KEY_NONCE</span><span class="p">[</span><span class="n">hotkey</span><span class="p">]</span> <span class="o">=</span> <span class="n">nonce</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># update the nonce cache</span>
                    <span class="k">return</span> <span class="n">response</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Wait for a while</span>
                    <span class="n">wait</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">wait_time</span> <span class="o">*</span> <span class="n">attempt</span><span class="p">,</span> <span class="n">max_wait</span><span class="p">)</span>
                    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">wait</span><span class="p">)</span>
                    <span class="c1"># Incr the nonce and try again</span>
                    <span class="n">nonce</span> <span class="o">=</span> <span class="n">nonce</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">continue</span>

            <span class="c1"># This dies because user is spamming... incr and try again</span>
            <span class="k">except</span> <span class="n">SubstrateRequestException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;Priority is too low&quot;</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;message&quot;</span><span class="p">]:</span>
                    <span class="n">wait</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">wait_time</span> <span class="o">*</span> <span class="n">attempt</span><span class="p">,</span> <span class="n">max_wait</span><span class="p">)</span>
                    <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Priority is too low, retrying with new nonce: </span><span class="si">{</span><span class="n">nonce</span><span class="si">}</span><span class="s2"> in </span><span class="si">{</span><span class="n">wait</span><span class="si">}</span><span class="s2"> seconds.&quot;</span>
                    <span class="p">)</span>
                    <span class="n">nonce</span> <span class="o">=</span> <span class="n">nonce</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">wait</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error sending extrinsic: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">response</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">response</span></div>


    <span class="c1">###############</span>
    <span class="c1"># Set Weights #</span>
    <span class="c1">###############</span>
    <span class="c1"># TODO: still needed? Can&#39;t find any usage of this method.</span>
<div class="viewcode-block" id="Subtensor.set_weights">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.set_weights">[docs]</a>
    <span class="k">def</span> <span class="nf">set_weights</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">uids</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">],</span> <span class="s2">&quot;torch.LongTensor&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">],</span>
        <span class="n">weights</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">],</span> <span class="s2">&quot;torch.FloatTensor&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">],</span>
        <span class="n">version_key</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">bittensor</span><span class="o">.</span><span class="n">__version_as_int__</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">prompt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_retries</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the inter-neuronal weights for the specified neuron. This process involves specifying the</span>
<span class="sd">        influence or trust a neuron places on other neurons in the network, which is a fundamental aspect</span>
<span class="sd">        of Bittensor&#39;s decentralized learning architecture.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet associated with the neuron setting the weights.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            uids (Union[NDArray[np.int64], torch.LongTensor, list]): The list of neuron UIDs that the weights are being</span>
<span class="sd">                set for.</span>
<span class="sd">            weights (Union[NDArray[np.float32], torch.FloatTensor, list]): The corresponding weights to be set for each</span>
<span class="sd">                UID.</span>
<span class="sd">            version_key (int, optional): Version key for compatibility with the network.</span>
<span class="sd">            wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.</span>
<span class="sd">            wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.</span>
<span class="sd">            prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding.</span>
<span class="sd">            max_retries (int, optional): The number of maximum attempts to set weights. (Default: 5)</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[bool, str]: ``True`` if the setting of weights is successful, False otherwise. And `msg`, a string</span>
<span class="sd">            value describing the success or potential error.</span>

<span class="sd">        This function is crucial in shaping the network&#39;s collective intelligence, where each neuron&#39;s</span>
<span class="sd">        learning and contribution are influenced by the weights it sets towards others【81†source】.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">uid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_uid_for_hotkey_on_subnet</span><span class="p">(</span><span class="n">wallet</span><span class="o">.</span><span class="n">hotkey</span><span class="o">.</span><span class="n">ss58_address</span><span class="p">,</span> <span class="n">netuid</span><span class="p">)</span>
        <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;No attempt made. Perhaps it is too soon to set weights!&quot;</span>
        <span class="k">while</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">blocks_since_last_update</span><span class="p">(</span><span class="n">netuid</span><span class="p">,</span> <span class="n">uid</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights_rate_limit</span><span class="p">(</span><span class="n">netuid</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
            <span class="ow">and</span> <span class="n">retries</span> <span class="o">&lt;</span> <span class="n">max_retries</span>
        <span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">success</span><span class="p">,</span> <span class="n">message</span> <span class="o">=</span> <span class="n">set_weights_extrinsic</span><span class="p">(</span>
                    <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
                    <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
                    <span class="n">uids</span><span class="o">=</span><span class="n">uids</span><span class="p">,</span>
                    <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span>
                    <span class="n">version_key</span><span class="o">=</span><span class="n">version_key</span><span class="p">,</span>
                    <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                    <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
                    <span class="n">prompt</span><span class="o">=</span><span class="n">prompt</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error setting weights: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="n">retries</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">success</span><span class="p">,</span> <span class="n">message</span></div>


<div class="viewcode-block" id="Subtensor._do_set_weights">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor._do_set_weights">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">_do_set_weights</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">uids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">vals</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">version_key</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">bittensor</span><span class="o">.</span><span class="n">__version_as_int__</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>  <span class="c1"># (success, error_message)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal method to send a transaction to the Bittensor blockchain, setting weights</span>
<span class="sd">        for specified neurons. This method constructs and submits the transaction, handling</span>
<span class="sd">        retries and blockchain communication.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet associated with the neuron setting the weights.</span>
<span class="sd">            uids (List[int]): List of neuron UIDs for which weights are being set.</span>
<span class="sd">            vals (List[int]): List of weight values corresponding to each UID.</span>
<span class="sd">            netuid (int): Unique identifier for the network.</span>
<span class="sd">            version_key (int, optional): Version key for compatibility with the network.</span>
<span class="sd">            wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.</span>
<span class="sd">            wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[bool, Optional[str]]: A tuple containing a success flag and an optional error message.</span>

<span class="sd">        This method is vital for the dynamic weighting mechanism in Bittensor, where neurons adjust their</span>
<span class="sd">        trust in other neurons based on observed performance and contributions.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">_logger</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">():</span>
            <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">compose_call</span><span class="p">(</span>
                <span class="n">call_module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
                <span class="n">call_function</span><span class="o">=</span><span class="s2">&quot;set_weights&quot;</span><span class="p">,</span>
                <span class="n">call_params</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;dests&quot;</span><span class="p">:</span> <span class="n">uids</span><span class="p">,</span>
                    <span class="s2">&quot;weights&quot;</span><span class="p">:</span> <span class="n">vals</span><span class="p">,</span>
                    <span class="s2">&quot;netuid&quot;</span><span class="p">:</span> <span class="n">netuid</span><span class="p">,</span>
                    <span class="s2">&quot;version_key&quot;</span><span class="p">:</span> <span class="n">version_key</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>
            <span class="c1"># Period dictates how long the extrinsic will stay as part of waiting pool</span>
            <span class="n">extrinsic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">create_signed_extrinsic</span><span class="p">(</span>
                <span class="n">call</span><span class="o">=</span><span class="n">call</span><span class="p">,</span>
                <span class="n">keypair</span><span class="o">=</span><span class="n">wallet</span><span class="o">.</span><span class="n">hotkey</span><span class="p">,</span>
                <span class="n">era</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;period&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span>
            <span class="p">)</span>
            <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">submit_extrinsic</span><span class="p">(</span>
                <span class="n">extrinsic</span><span class="p">,</span>
                <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># We only wait here if we expect finalization.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">wait_for_finalization</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">wait_for_inclusion</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;Not waiting for finalization or inclusion.&quot;</span>

            <span class="n">response</span><span class="o">.</span><span class="n">process_events</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">response</span><span class="o">.</span><span class="n">is_success</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;Successfully set weights.&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">format_error_message</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">error_message</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span></div>


    <span class="c1">##################</span>
    <span class="c1"># Commit Weights #</span>
    <span class="c1">##################</span>
<div class="viewcode-block" id="Subtensor.commit_weights">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.commit_weights">[docs]</a>
    <span class="k">def</span> <span class="nf">commit_weights</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">salt</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">uids</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">],</span> <span class="nb">list</span><span class="p">],</span>
        <span class="n">weights</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">],</span> <span class="nb">list</span><span class="p">],</span>
        <span class="n">version_key</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">bittensor</span><span class="o">.</span><span class="n">__version_as_int__</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">prompt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_retries</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Commits a hash of the neuron&#39;s weights to the Bittensor blockchain using the provided wallet.</span>
<span class="sd">        This action serves as a commitment or snapshot of the neuron&#39;s current weight distribution.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet associated with the neuron committing the weights.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            salt (List[int]): list of randomly generated integers as salt to generated weighted hash.</span>
<span class="sd">            uids (np.ndarray): NumPy array of neuron UIDs for which weights are being committed.</span>
<span class="sd">            weights (np.ndarray): NumPy array of weight values corresponding to each UID.</span>
<span class="sd">            version_key (int, optional): Version key for compatibility with the network.</span>
<span class="sd">            wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.</span>
<span class="sd">            wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.</span>
<span class="sd">            prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding.</span>
<span class="sd">            max_retries (int, optional): The number of maximum attempts to commit weights. (Default: 5)</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[bool, str]: ``True`` if the weight commitment is successful, False otherwise. And `msg`, a string</span>
<span class="sd">            value describing the success or potential error.</span>

<span class="sd">        This function allows neurons to create a tamper-proof record of their weight distribution at a specific point in time,</span>
<span class="sd">        enhancing transparency and accountability within the Bittensor network.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;No attempt made. Perhaps it is too soon to commit weights!&quot;</span>

        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Committing weights with params: netuid=</span><span class="si">{}</span><span class="s2">, uids=</span><span class="si">{}</span><span class="s2">, weights=</span><span class="si">{}</span><span class="s2">, version_key=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">netuid</span><span class="p">,</span> <span class="n">uids</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">version_key</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Generate the hash of the weights</span>
        <span class="n">commit_hash</span> <span class="o">=</span> <span class="n">weight_utils</span><span class="o">.</span><span class="n">generate_weight_hash</span><span class="p">(</span>
            <span class="n">address</span><span class="o">=</span><span class="n">wallet</span><span class="o">.</span><span class="n">hotkey</span><span class="o">.</span><span class="n">ss58_address</span><span class="p">,</span>
            <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
            <span class="n">uids</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">uids</span><span class="p">),</span>
            <span class="n">values</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">weights</span><span class="p">),</span>
            <span class="n">salt</span><span class="o">=</span><span class="n">salt</span><span class="p">,</span>
            <span class="n">version_key</span><span class="o">=</span><span class="n">version_key</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Commit Hash: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">commit_hash</span><span class="p">))</span>

        <span class="k">while</span> <span class="n">retries</span> <span class="o">&lt;</span> <span class="n">max_retries</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">success</span><span class="p">,</span> <span class="n">message</span> <span class="o">=</span> <span class="n">commit_weights_extrinsic</span><span class="p">(</span>
                    <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
                    <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
                    <span class="n">commit_hash</span><span class="o">=</span><span class="n">commit_hash</span><span class="p">,</span>
                    <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                    <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
                    <span class="n">prompt</span><span class="o">=</span><span class="n">prompt</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">success</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">bittensor</span><span class="o">.</span><span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error committing weights: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="n">retries</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">success</span><span class="p">,</span> <span class="n">message</span></div>


<div class="viewcode-block" id="Subtensor._do_commit_weights">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor._do_commit_weights">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">_do_commit_weights</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">commit_hash</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal method to send a transaction to the Bittensor blockchain, committing the hash of a neuron&#39;s weights.</span>
<span class="sd">        This method constructs and submits the transaction, handling retries and blockchain communication.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet associated with the neuron committing the weights.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            commit_hash (str): The hash of the neuron&#39;s weights to be committed.</span>
<span class="sd">            wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.</span>
<span class="sd">            wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[bool, Optional[str]]: A tuple containing a success flag and an optional error message.</span>

<span class="sd">        This method ensures that the weight commitment is securely recorded on the Bittensor blockchain, providing a</span>
<span class="sd">        verifiable record of the neuron&#39;s weight distribution at a specific point in time.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">_logger</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">():</span>
            <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">compose_call</span><span class="p">(</span>
                <span class="n">call_module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
                <span class="n">call_function</span><span class="o">=</span><span class="s2">&quot;commit_weights&quot;</span><span class="p">,</span>
                <span class="n">call_params</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;netuid&quot;</span><span class="p">:</span> <span class="n">netuid</span><span class="p">,</span>
                    <span class="s2">&quot;commit_hash&quot;</span><span class="p">:</span> <span class="n">commit_hash</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>
            <span class="n">extrinsic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">create_signed_extrinsic</span><span class="p">(</span>
                <span class="n">call</span><span class="o">=</span><span class="n">call</span><span class="p">,</span>
                <span class="n">keypair</span><span class="o">=</span><span class="n">wallet</span><span class="o">.</span><span class="n">hotkey</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">submit_extrinsic</span><span class="p">(</span>
                <span class="n">extrinsic</span><span class="p">,</span>
                <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">wait_for_finalization</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">wait_for_inclusion</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">None</span>

            <span class="n">response</span><span class="o">.</span><span class="n">process_events</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">response</span><span class="o">.</span><span class="n">is_success</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">response</span><span class="o">.</span><span class="n">error_message</span>

        <span class="k">return</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span></div>


    <span class="c1">##################</span>
    <span class="c1"># Reveal Weights #</span>
    <span class="c1">##################</span>
<div class="viewcode-block" id="Subtensor.reveal_weights">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.reveal_weights">[docs]</a>
    <span class="k">def</span> <span class="nf">reveal_weights</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">uids</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">],</span> <span class="nb">list</span><span class="p">],</span>
        <span class="n">weights</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">],</span> <span class="nb">list</span><span class="p">],</span>
        <span class="n">salt</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">],</span> <span class="nb">list</span><span class="p">],</span>
        <span class="n">version_key</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">bittensor</span><span class="o">.</span><span class="n">__version_as_int__</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">prompt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_retries</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reveals the weights for a specific subnet on the Bittensor blockchain using the provided wallet.</span>
<span class="sd">        This action serves as a revelation of the neuron&#39;s previously committed weight distribution.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet associated with the neuron revealing the weights.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            uids (np.ndarray): NumPy array of neuron UIDs for which weights are being revealed.</span>
<span class="sd">            weights (np.ndarray): NumPy array of weight values corresponding to each UID.</span>
<span class="sd">            salt (np.ndarray): NumPy array of salt values corresponding to the hash function.</span>
<span class="sd">            version_key (int, optional): Version key for compatibility with the network.</span>
<span class="sd">            wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.</span>
<span class="sd">            wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.</span>
<span class="sd">            prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding.</span>
<span class="sd">            max_retries (int, optional): The number of maximum attempts to reveal weights. (Default: 5)</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[bool, str]: ``True`` if the weight revelation is successful, False otherwise. And `msg`, a string</span>
<span class="sd">            value describing the success or potential error.</span>

<span class="sd">        This function allows neurons to reveal their previously committed weight distribution, ensuring transparency</span>
<span class="sd">        and accountability within the Bittensor network.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;No attempt made. Perhaps it is too soon to reveal weights!&quot;</span>

        <span class="k">while</span> <span class="n">retries</span> <span class="o">&lt;</span> <span class="n">max_retries</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">success</span><span class="p">,</span> <span class="n">message</span> <span class="o">=</span> <span class="n">reveal_weights_extrinsic</span><span class="p">(</span>
                    <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
                    <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
                    <span class="n">uids</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">uids</span><span class="p">),</span>
                    <span class="n">weights</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">weights</span><span class="p">),</span>
                    <span class="n">salt</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">salt</span><span class="p">),</span>
                    <span class="n">version_key</span><span class="o">=</span><span class="n">version_key</span><span class="p">,</span>
                    <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                    <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
                    <span class="n">prompt</span><span class="o">=</span><span class="n">prompt</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">success</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">bittensor</span><span class="o">.</span><span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error revealing weights: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="n">retries</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">success</span><span class="p">,</span> <span class="n">message</span></div>


<div class="viewcode-block" id="Subtensor._do_reveal_weights">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor._do_reveal_weights">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">_do_reveal_weights</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">uids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">values</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">salt</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">version_key</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal method to send a transaction to the Bittensor blockchain, revealing the weights for a specific subnet.</span>
<span class="sd">        This method constructs and submits the transaction, handling retries and blockchain communication.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet associated with the neuron revealing the weights.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            uids (List[int]): List of neuron UIDs for which weights are being revealed.</span>
<span class="sd">            values (List[int]): List of weight values corresponding to each UID.</span>
<span class="sd">            salt (List[int]): List of salt values corresponding to the hash function.</span>
<span class="sd">            version_key (int): Version key for compatibility with the network.</span>
<span class="sd">            wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.</span>
<span class="sd">            wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[bool, Optional[str]]: A tuple containing a success flag and an optional error message.</span>

<span class="sd">        This method ensures that the weight revelation is securely recorded on the Bittensor blockchain, providing transparency</span>
<span class="sd">        and accountability for the neuron&#39;s weight distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">_logger</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">():</span>
            <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">compose_call</span><span class="p">(</span>
                <span class="n">call_module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
                <span class="n">call_function</span><span class="o">=</span><span class="s2">&quot;reveal_weights&quot;</span><span class="p">,</span>
                <span class="n">call_params</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;netuid&quot;</span><span class="p">:</span> <span class="n">netuid</span><span class="p">,</span>
                    <span class="s2">&quot;uids&quot;</span><span class="p">:</span> <span class="n">uids</span><span class="p">,</span>
                    <span class="s2">&quot;values&quot;</span><span class="p">:</span> <span class="n">values</span><span class="p">,</span>
                    <span class="s2">&quot;salt&quot;</span><span class="p">:</span> <span class="n">salt</span><span class="p">,</span>
                    <span class="s2">&quot;version_key&quot;</span><span class="p">:</span> <span class="n">version_key</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>
            <span class="n">extrinsic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">create_signed_extrinsic</span><span class="p">(</span>
                <span class="n">call</span><span class="o">=</span><span class="n">call</span><span class="p">,</span>
                <span class="n">keypair</span><span class="o">=</span><span class="n">wallet</span><span class="o">.</span><span class="n">hotkey</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">submit_extrinsic</span><span class="p">(</span>
                <span class="n">extrinsic</span><span class="p">,</span>
                <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">wait_for_finalization</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">wait_for_inclusion</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">None</span>

            <span class="n">response</span><span class="o">.</span><span class="n">process_events</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">response</span><span class="o">.</span><span class="n">is_success</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">format_error_message</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">error_message</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span></div>


    <span class="c1">################</span>
    <span class="c1"># Registration #</span>
    <span class="c1">################</span>
<div class="viewcode-block" id="Subtensor.register">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.register">[docs]</a>
    <span class="k">def</span> <span class="nf">register</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">prompt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_allowed_attempts</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
        <span class="n">output_in_place</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">cuda</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">dev_id</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">tpb</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">256</span><span class="p">,</span>
        <span class="n">num_processes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">update_interval</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">log_verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Registers a neuron on the Bittensor network using the provided wallet. Registration</span>
<span class="sd">        is a critical step for a neuron to become an active participant in the network, enabling</span>
<span class="sd">        it to stake, set weights, and receive incentives.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet associated with the neuron to be registered.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.</span>
<span class="sd">                Defaults to `False`.</span>
<span class="sd">            wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.</span>
<span class="sd">                 Defaults to `True`.</span>
<span class="sd">            prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding.</span>
<span class="sd">            max_allowed_attempts (int): Maximum number of attempts to register the wallet.</span>
<span class="sd">            output_in_place (bool): If true, prints the progress of the proof of work to the console in-place. Meaning</span>
<span class="sd">                the progress is printed on the same lines. Defaults to `True`.</span>
<span class="sd">            cuda (bool): If ``true``, the wallet should be registered using CUDA device(s). Defaults to `False`.</span>
<span class="sd">            dev_id (Union[List[int], int]): The CUDA device id to use, or a list of device ids. Defaults to `0` (zero).</span>
<span class="sd">            tpb (int): The number of threads per block (CUDA). Default to `256`.</span>
<span class="sd">            num_processes (Optional[int]): The number of processes to use to register. Default to `None`.</span>
<span class="sd">            update_interval (Optional[int]): The number of nonces to solve between updates.  Default to `None`.</span>
<span class="sd">            log_verbose (bool): If ``true``, the registration process will log more information.  Default to `False`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the registration is successful, False otherwise.</span>

<span class="sd">        This function facilitates the entry of new neurons into the network, supporting the decentralized</span>
<span class="sd">        growth and scalability of the Bittensor ecosystem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">register_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">prompt</span><span class="o">=</span><span class="n">prompt</span><span class="p">,</span>
            <span class="n">max_allowed_attempts</span><span class="o">=</span><span class="n">max_allowed_attempts</span><span class="p">,</span>
            <span class="n">output_in_place</span><span class="o">=</span><span class="n">output_in_place</span><span class="p">,</span>
            <span class="n">cuda</span><span class="o">=</span><span class="n">cuda</span><span class="p">,</span>
            <span class="n">dev_id</span><span class="o">=</span><span class="n">dev_id</span><span class="p">,</span>
            <span class="n">tpb</span><span class="o">=</span><span class="n">tpb</span><span class="p">,</span>
            <span class="n">num_processes</span><span class="o">=</span><span class="n">num_processes</span><span class="p">,</span>
            <span class="n">update_interval</span><span class="o">=</span><span class="n">update_interval</span><span class="p">,</span>
            <span class="n">log_verbose</span><span class="o">=</span><span class="n">log_verbose</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.swap_hotkey">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.swap_hotkey">[docs]</a>
    <span class="k">def</span> <span class="nf">swap_hotkey</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">new_wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">prompt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Swaps an old hotkey with a new hotkey for the specified wallet.</span>

<span class="sd">        This method initiates an extrinsic to change the hotkey associated with a wallet to a new hotkey. It provides</span>
<span class="sd">        options to wait for inclusion and finalization of the transaction, and to prompt the user for confirmation.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet whose hotkey is to be swapped.</span>
<span class="sd">            new_wallet (bittensor.wallet): The new wallet with the hotkey to be set.</span>
<span class="sd">            wait_for_inclusion (bool): Whether to wait for the transaction to be included in a block.</span>
<span class="sd">                Default is `False`.</span>
<span class="sd">            wait_for_finalization (bool): Whether to wait for the transaction to be finalized. Default is `True`.</span>
<span class="sd">            prompt (bool): Whether to prompt the user for confirmation before proceeding. Default is `False`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if the hotkey swap was successful, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">swap_hotkey_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">new_wallet</span><span class="o">=</span><span class="n">new_wallet</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">prompt</span><span class="o">=</span><span class="n">prompt</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.run_faucet">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.run_faucet">[docs]</a>
    <span class="k">def</span> <span class="nf">run_faucet</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">prompt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_allowed_attempts</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
        <span class="n">output_in_place</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">cuda</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">dev_id</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">tpb</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">256</span><span class="p">,</span>
        <span class="n">num_processes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">update_interval</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">log_verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Facilitates a faucet transaction, allowing new neurons to receive an initial amount of TAO</span>
<span class="sd">        for participating in the network. This function is particularly useful for newcomers to the</span>
<span class="sd">        Bittensor network, enabling them to start with a small stake on testnet only.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet for which the faucet transaction is to be run.</span>
<span class="sd">            wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.</span>
<span class="sd">                Defaults to `False`.</span>
<span class="sd">            wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.</span>
<span class="sd">                 Defaults to `True`.</span>
<span class="sd">            prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding.</span>
<span class="sd">            max_allowed_attempts (int): Maximum number of attempts to register the wallet.</span>
<span class="sd">            output_in_place (bool): If true, prints the progress of the proof of work to the console in-place. Meaning</span>
<span class="sd">                the progress is printed on the same lines. Defaults to `True`.</span>
<span class="sd">            cuda (bool): If ``true``, the wallet should be registered using CUDA device(s). Defaults to `False`.</span>
<span class="sd">            dev_id (Union[List[int], int]): The CUDA device id to use, or a list of device ids. Defaults to `0` (zero).</span>
<span class="sd">            tpb (int): The number of threads per block (CUDA). Default to `256`.</span>
<span class="sd">            num_processes (Optional[int]): The number of processes to use to register. Default to `None`.</span>
<span class="sd">            update_interval (Optional[int]): The number of nonces to solve between updates.  Default to `None`.</span>
<span class="sd">            log_verbose (bool): If ``true``, the registration process will log more information.  Default to `False`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the faucet transaction is successful, False otherwise.</span>

<span class="sd">        This function is part of Bittensor&#39;s onboarding process, ensuring that new neurons have</span>
<span class="sd">        the necessary resources to begin their journey in the decentralized AI network.</span>

<span class="sd">        Note:</span>
<span class="sd">            This is for testnet ONLY and is disabled currently. You must build your own staging subtensor chain with the</span>
<span class="sd">            ``--features pow-faucet`` argument to enable this.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">run_faucet_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">prompt</span><span class="o">=</span><span class="n">prompt</span><span class="p">,</span>
            <span class="n">max_allowed_attempts</span><span class="o">=</span><span class="n">max_allowed_attempts</span><span class="p">,</span>
            <span class="n">output_in_place</span><span class="o">=</span><span class="n">output_in_place</span><span class="p">,</span>
            <span class="n">cuda</span><span class="o">=</span><span class="n">cuda</span><span class="p">,</span>
            <span class="n">dev_id</span><span class="o">=</span><span class="n">dev_id</span><span class="p">,</span>
            <span class="n">tpb</span><span class="o">=</span><span class="n">tpb</span><span class="p">,</span>
            <span class="n">num_processes</span><span class="o">=</span><span class="n">num_processes</span><span class="p">,</span>
            <span class="n">update_interval</span><span class="o">=</span><span class="n">update_interval</span><span class="p">,</span>
            <span class="n">log_verbose</span><span class="o">=</span><span class="n">log_verbose</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="Subtensor.burned_register">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.burned_register">[docs]</a>
    <span class="k">def</span> <span class="nf">burned_register</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">prompt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Registers a neuron on the Bittensor network by recycling TAO. This method of registration</span>
<span class="sd">        involves recycling TAO tokens, allowing them to be re-mined by performing work on the network.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet associated with the neuron to be registered.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.</span>
<span class="sd">                Defaults to `False`.</span>
<span class="sd">            wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.</span>
<span class="sd">                Defaults to `True`.</span>
<span class="sd">            prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding. Defaults to `False`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the registration is successful, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">burned_register_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">prompt</span><span class="o">=</span><span class="n">prompt</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor._do_pow_register">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor._do_pow_register">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">_do_pow_register</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">pow_result</span><span class="p">:</span> <span class="n">POWSolution</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sends a (POW) register extrinsic to the chain.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The subnet to register on.</span>
<span class="sd">            wallet (bittensor.wallet): The wallet to register.</span>
<span class="sd">            pow_result (POWSolution): The PoW result to register.</span>
<span class="sd">            wait_for_inclusion (bool): If ``True``, waits for the extrinsic to be included in a block.</span>
<span class="sd">                Default to `False`.</span>
<span class="sd">            wait_for_finalization (bool): If ``True``, waits for the extrinsic to be finalized. Default to `True`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            success (bool): ``True`` if the extrinsic was included in a block.</span>
<span class="sd">            error (Optional[str]): ``None`` on success or not waiting for inclusion/finalization, otherwise the error</span>
<span class="sd">                message.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">_logger</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">():</span>
            <span class="c1"># create extrinsic call</span>
            <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">compose_call</span><span class="p">(</span>
                <span class="n">call_module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
                <span class="n">call_function</span><span class="o">=</span><span class="s2">&quot;register&quot;</span><span class="p">,</span>
                <span class="n">call_params</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;netuid&quot;</span><span class="p">:</span> <span class="n">netuid</span><span class="p">,</span>
                    <span class="s2">&quot;block_number&quot;</span><span class="p">:</span> <span class="n">pow_result</span><span class="o">.</span><span class="n">block_number</span><span class="p">,</span>
                    <span class="s2">&quot;nonce&quot;</span><span class="p">:</span> <span class="n">pow_result</span><span class="o">.</span><span class="n">nonce</span><span class="p">,</span>
                    <span class="s2">&quot;work&quot;</span><span class="p">:</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">byte_</span><span class="p">)</span> <span class="k">for</span> <span class="n">byte_</span> <span class="ow">in</span> <span class="n">pow_result</span><span class="o">.</span><span class="n">seal</span><span class="p">],</span>
                    <span class="s2">&quot;hotkey&quot;</span><span class="p">:</span> <span class="n">wallet</span><span class="o">.</span><span class="n">hotkey</span><span class="o">.</span><span class="n">ss58_address</span><span class="p">,</span>
                    <span class="s2">&quot;coldkey&quot;</span><span class="p">:</span> <span class="n">wallet</span><span class="o">.</span><span class="n">coldkeypub</span><span class="o">.</span><span class="n">ss58_address</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>
            <span class="n">extrinsic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">create_signed_extrinsic</span><span class="p">(</span>
                <span class="n">call</span><span class="o">=</span><span class="n">call</span><span class="p">,</span> <span class="n">keypair</span><span class="o">=</span><span class="n">wallet</span><span class="o">.</span><span class="n">hotkey</span>
            <span class="p">)</span>
            <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">submit_extrinsic</span><span class="p">(</span>
                <span class="n">extrinsic</span><span class="p">,</span>
                <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># We only wait here if we expect finalization.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">wait_for_finalization</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">wait_for_inclusion</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">None</span>

            <span class="c1"># process if registration successful, try again if pow is still valid</span>
            <span class="n">response</span><span class="o">.</span><span class="n">process_events</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">response</span><span class="o">.</span><span class="n">is_success</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">format_error_message</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">error_message</span><span class="p">)</span>
            <span class="c1"># Successful registration</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span></div>


<div class="viewcode-block" id="Subtensor._do_burned_register">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor._do_burned_register">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">_do_burned_register</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs a burned register extrinsic call to the Subtensor chain.</span>

<span class="sd">        This method sends a registration transaction to the Subtensor blockchain using the burned register mechanism. It</span>
<span class="sd">        retries the call up to three times with exponential backoff in case of failures.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The network unique identifier to register on.</span>
<span class="sd">            wallet (bittensor.wallet): The wallet to be registered.</span>
<span class="sd">            wait_for_inclusion (bool): Whether to wait for the transaction to be included in a block. Default is False.</span>
<span class="sd">            wait_for_finalization (bool): Whether to wait for the transaction to be finalized. Default is True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[bool, Optional[str]]: A tuple containing a boolean indicating success or failure, and an optional error message.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">_logger</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">():</span>
            <span class="c1"># create extrinsic call</span>
            <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">compose_call</span><span class="p">(</span>
                <span class="n">call_module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
                <span class="n">call_function</span><span class="o">=</span><span class="s2">&quot;burned_register&quot;</span><span class="p">,</span>
                <span class="n">call_params</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;netuid&quot;</span><span class="p">:</span> <span class="n">netuid</span><span class="p">,</span>
                    <span class="s2">&quot;hotkey&quot;</span><span class="p">:</span> <span class="n">wallet</span><span class="o">.</span><span class="n">hotkey</span><span class="o">.</span><span class="n">ss58_address</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>
            <span class="n">extrinsic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">create_signed_extrinsic</span><span class="p">(</span>
                <span class="n">call</span><span class="o">=</span><span class="n">call</span><span class="p">,</span> <span class="n">keypair</span><span class="o">=</span><span class="n">wallet</span><span class="o">.</span><span class="n">coldkey</span>
            <span class="p">)</span>
            <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">submit_extrinsic</span><span class="p">(</span>
                <span class="n">extrinsic</span><span class="p">,</span>
                <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># We only wait here if we expect finalization.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">wait_for_finalization</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">wait_for_inclusion</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">None</span>

            <span class="c1"># process if registration successful, try again if pow is still valid</span>
            <span class="n">response</span><span class="o">.</span><span class="n">process_events</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">response</span><span class="o">.</span><span class="n">is_success</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">format_error_message</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">error_message</span><span class="p">)</span>
            <span class="c1"># Successful registration</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span></div>


<div class="viewcode-block" id="Subtensor._do_swap_hotkey">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor._do_swap_hotkey">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">_do_swap_hotkey</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">new_wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs a hotkey swap extrinsic call to the Subtensor chain.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet whose hotkey is to be swapped.</span>
<span class="sd">            new_wallet (bittensor.wallet): The wallet with the new hotkey to be set.</span>
<span class="sd">            wait_for_inclusion (bool): Whether to wait for the transaction to be included in a block. Default is</span>
<span class="sd">            `False`.</span>
<span class="sd">            wait_for_finalization (bool): Whether to wait for the transaction to be finalized. Default is `True`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[bool, Optional[str]]: A tuple containing a boolean indicating success or failure, and an optional</span>
<span class="sd">                error message.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">_logger</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">():</span>
            <span class="c1"># create extrinsic call</span>
            <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">compose_call</span><span class="p">(</span>
                <span class="n">call_module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
                <span class="n">call_function</span><span class="o">=</span><span class="s2">&quot;swap_hotkey&quot;</span><span class="p">,</span>
                <span class="n">call_params</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;hotkey&quot;</span><span class="p">:</span> <span class="n">wallet</span><span class="o">.</span><span class="n">hotkey</span><span class="o">.</span><span class="n">ss58_address</span><span class="p">,</span>
                    <span class="s2">&quot;new_hotkey&quot;</span><span class="p">:</span> <span class="n">new_wallet</span><span class="o">.</span><span class="n">hotkey</span><span class="o">.</span><span class="n">ss58_address</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>
            <span class="n">extrinsic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">create_signed_extrinsic</span><span class="p">(</span>
                <span class="n">call</span><span class="o">=</span><span class="n">call</span><span class="p">,</span> <span class="n">keypair</span><span class="o">=</span><span class="n">wallet</span><span class="o">.</span><span class="n">coldkey</span>
            <span class="p">)</span>
            <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">submit_extrinsic</span><span class="p">(</span>
                <span class="n">extrinsic</span><span class="p">,</span>
                <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># We only wait here if we expect finalization.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">wait_for_finalization</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">wait_for_inclusion</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">None</span>

            <span class="c1"># process if registration successful, try again if pow is still valid</span>
            <span class="n">response</span><span class="o">.</span><span class="n">process_events</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">response</span><span class="o">.</span><span class="n">is_success</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">format_error_message</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">error_message</span><span class="p">)</span>
            <span class="c1"># Successful registration</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span></div>


    <span class="c1">############</span>
    <span class="c1"># Transfer #</span>
    <span class="c1">############</span>
<div class="viewcode-block" id="Subtensor.transfer">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.transfer">[docs]</a>
    <span class="k">def</span> <span class="nf">transfer</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">dest</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">amount</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Balance</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">prompt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Executes a transfer of funds from the provided wallet to the specified destination address.</span>
<span class="sd">        This function is used to move TAO tokens within the Bittensor network, facilitating transactions</span>
<span class="sd">        between neurons.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet from which funds are being transferred.</span>
<span class="sd">            dest (str): The destination public key address.</span>
<span class="sd">            amount (Union[Balance, float]): The amount of TAO to be transferred.</span>
<span class="sd">            wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.</span>
<span class="sd">            wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.</span>
<span class="sd">            prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding.</span>

<span class="sd">        Returns:</span>
<span class="sd">            transfer_extrinsic (bool): ``True`` if the transfer is successful, False otherwise.</span>

<span class="sd">        This function is essential for the fluid movement of tokens in the network, supporting</span>
<span class="sd">        various economic activities such as staking, delegation, and reward distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">transfer_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">dest</span><span class="o">=</span><span class="n">dest</span><span class="p">,</span>
            <span class="n">amount</span><span class="o">=</span><span class="n">amount</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">prompt</span><span class="o">=</span><span class="n">prompt</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_transfer_fee">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_transfer_fee">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">get_transfer_fee</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;Balance&quot;</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Balance&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the transaction fee for transferring tokens from a wallet to a specified destination address.</span>
<span class="sd">        This function simulates the transfer to estimate the associated cost, taking into account the current</span>
<span class="sd">        network conditions and transaction complexity.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet from which the transfer is initiated.</span>
<span class="sd">            dest (str): The ``SS58`` address of the destination account.</span>
<span class="sd">            value (Union[Balance, float, int]): The amount of tokens to be transferred, specified as a Balance object,</span>
<span class="sd">                or in Tao (float) or Rao (int) units.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Balance: The estimated transaction fee for the transfer, represented as a Balance object.</span>

<span class="sd">        Estimating the transfer fee is essential for planning and executing token transactions, ensuring that the</span>
<span class="sd">        wallet has sufficient funds to cover both the transfer amount and the associated costs. This function</span>
<span class="sd">        provides a crucial tool for managing financial operations within the Bittensor network.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_tao</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Balance</span><span class="p">):</span>
            <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">compose_call</span><span class="p">(</span>
                <span class="n">call_module</span><span class="o">=</span><span class="s2">&quot;Balances&quot;</span><span class="p">,</span>
                <span class="n">call_function</span><span class="o">=</span><span class="s2">&quot;transfer_allow_death&quot;</span><span class="p">,</span>
                <span class="n">call_params</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;dest&quot;</span><span class="p">:</span> <span class="n">dest</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">value</span><span class="o">.</span><span class="n">rao</span><span class="p">},</span>
            <span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">payment_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_payment_info</span><span class="p">(</span>
                    <span class="n">call</span><span class="o">=</span><span class="n">call</span><span class="p">,</span> <span class="n">keypair</span><span class="o">=</span><span class="n">wallet</span><span class="o">.</span><span class="n">coldkeypub</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">bittensor</span><span class="o">.</span><span class="n">__console__</span><span class="o">.</span><span class="n">print</span><span class="p">(</span>
                    <span class="s2">&quot;:cross_mark: [red]Failed to get payment info[/red]:[bold white]</span><span class="se">\n</span><span class="s2">  </span><span class="si">{}</span><span class="s2">[/bold white]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">e</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">payment_info</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;partialFee&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="mf">2e7</span><span class="p">)}</span>  <span class="c1"># assume  0.02 Tao</span>

            <span class="n">fee</span> <span class="o">=</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="n">payment_info</span><span class="p">[</span><span class="s2">&quot;partialFee&quot;</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">fee</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fee</span> <span class="o">=</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="mf">2e7</span><span class="p">))</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;To calculate the transaction fee, the value must be Balance, float, or int. Received type: </span><span class="si">%s</span><span class="s2">. Fee &quot;</span>
                <span class="s2">&quot;is </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">),</span>
                <span class="mf">2e7</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">fee</span></div>


<div class="viewcode-block" id="Subtensor._do_transfer">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor._do_transfer">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">_do_transfer</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">dest</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">transfer_balance</span><span class="p">:</span> <span class="s2">&quot;Balance&quot;</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sends a transfer extrinsic to the chain.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (:func:`bittensor.wallet`): Wallet object.</span>
<span class="sd">            dest (str): Destination public key address.</span>
<span class="sd">            transfer_balance (:func:`Balance`): Amount to transfer.</span>
<span class="sd">            wait_for_inclusion (bool): If ``true``, waits for inclusion.</span>
<span class="sd">            wait_for_finalization (bool): If ``true``, waits for finalization.</span>
<span class="sd">        Returns:</span>
<span class="sd">            success (bool): ``True`` if transfer was successful.</span>
<span class="sd">            block_hash (str): Block hash of the transfer. On success and if wait_for_ finalization/inclusion is</span>
<span class="sd">                ``True``.</span>
<span class="sd">            error (str): Error message if transfer failed.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">_logger</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">():</span>
            <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">compose_call</span><span class="p">(</span>
                <span class="n">call_module</span><span class="o">=</span><span class="s2">&quot;Balances&quot;</span><span class="p">,</span>
                <span class="n">call_function</span><span class="o">=</span><span class="s2">&quot;transfer_allow_death&quot;</span><span class="p">,</span>
                <span class="n">call_params</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;dest&quot;</span><span class="p">:</span> <span class="n">dest</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">transfer_balance</span><span class="o">.</span><span class="n">rao</span><span class="p">},</span>
            <span class="p">)</span>
            <span class="n">extrinsic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">create_signed_extrinsic</span><span class="p">(</span>
                <span class="n">call</span><span class="o">=</span><span class="n">call</span><span class="p">,</span> <span class="n">keypair</span><span class="o">=</span><span class="n">wallet</span><span class="o">.</span><span class="n">coldkey</span>
            <span class="p">)</span>
            <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">submit_extrinsic</span><span class="p">(</span>
                <span class="n">extrinsic</span><span class="p">,</span>
                <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># We only wait here if we expect finalization.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">wait_for_finalization</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">wait_for_inclusion</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

            <span class="c1"># Otherwise continue with finalization.</span>
            <span class="n">response</span><span class="o">.</span><span class="n">process_events</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">response</span><span class="o">.</span><span class="n">is_success</span><span class="p">:</span>
                <span class="n">block_hash</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">block_hash</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">block_hash</span><span class="p">,</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">format_error_message</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">error_message</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span></div>


<div class="viewcode-block" id="Subtensor.get_existential_deposit">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_existential_deposit">[docs]</a>
    <span class="k">def</span> <span class="nf">get_existential_deposit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;Balance&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the existential deposit amount for the Bittensor blockchain. The existential deposit</span>
<span class="sd">        is the minimum amount of TAO required for an account to exist on the blockchain. Accounts with</span>
<span class="sd">        balances below this threshold can be reaped to conserve network resources.</span>

<span class="sd">        Args:</span>
<span class="sd">            block (Optional[int]): Block number at which to query the deposit amount. If ``None``, the current block is</span>
<span class="sd">                used.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[Balance]: The existential deposit amount, or ``None`` if the query fails.</span>

<span class="sd">        The existential deposit is a fundamental economic parameter in the Bittensor network, ensuring</span>
<span class="sd">        efficient use of storage and preventing the proliferation of dust accounts.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_constant</span><span class="p">(</span>
            <span class="n">module_name</span><span class="o">=</span><span class="s2">&quot;Balances&quot;</span><span class="p">,</span> <span class="n">constant_name</span><span class="o">=</span><span class="s2">&quot;ExistentialDeposit&quot;</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">value</span><span class="p">)</span></div>


    <span class="c1">###########</span>
    <span class="c1"># Network #</span>
    <span class="c1">###########</span>
<div class="viewcode-block" id="Subtensor.register_subnetwork">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.register_subnetwork">[docs]</a>
    <span class="k">def</span> <span class="nf">register_subnetwork</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">prompt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Registers a new subnetwork on the Bittensor network using the provided wallet. This function</span>
<span class="sd">        is used for the creation and registration of subnetworks, which are specialized segments of the</span>
<span class="sd">        overall Bittensor network.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet to be used for registration.</span>
<span class="sd">            wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.</span>
<span class="sd">            wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.</span>
<span class="sd">            prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the subnetwork registration is successful, False otherwise.</span>

<span class="sd">        This function allows for the expansion and diversification of the Bittensor network, supporting</span>
<span class="sd">        its decentralized and adaptable architecture.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">register_subnetwork_extrinsic</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">prompt</span><span class="o">=</span><span class="n">prompt</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.set_hyperparameter">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.set_hyperparameter">[docs]</a>
    <span class="k">def</span> <span class="nf">set_hyperparameter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">parameter</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">value</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">prompt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets a specific hyperparameter for a given subnetwork on the Bittensor blockchain. This action</span>
<span class="sd">        involves adjusting network-level parameters, influencing the behavior and characteristics of the</span>
<span class="sd">        subnetwork.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet used for setting the hyperparameter.</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            parameter (str): The name of the hyperparameter to be set.</span>
<span class="sd">            value: The new value for the hyperparameter.</span>
<span class="sd">            wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.</span>
<span class="sd">            wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.</span>
<span class="sd">            prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the hyperparameter setting is successful, False otherwise.</span>

<span class="sd">        This function plays a critical role in the dynamic governance and adaptability of the Bittensor</span>
<span class="sd">        network, allowing for fine-tuning of network operations and characteristics.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">set_hyperparameter_extrinsic</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
            <span class="n">parameter</span><span class="o">=</span><span class="n">parameter</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">prompt</span><span class="o">=</span><span class="n">prompt</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="c1">###########</span>
    <span class="c1"># Serving #</span>
    <span class="c1">###########</span>
<div class="viewcode-block" id="Subtensor.serve">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.serve">[docs]</a>
    <span class="k">def</span> <span class="nf">serve</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">ip</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">port</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">protocol</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">placeholder1</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">placeholder2</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Registers a neuron&#39;s serving endpoint on the Bittensor network. This function announces the</span>
<span class="sd">        IP address and port where the neuron is available to serve requests, facilitating peer-to-peer</span>
<span class="sd">        communication within the network.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet associated with the neuron being served.</span>
<span class="sd">            ip (str): The IP address of the serving neuron.</span>
<span class="sd">            port (int): The port number on which the neuron is serving.</span>
<span class="sd">            protocol (int): The protocol type used by the neuron (e.g., GRPC, HTTP).</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            placeholder1 (int, optional): Placeholder parameter for future extensions. Default is ``0``.</span>
<span class="sd">            placeholder2 (int, optional): Placeholder parameter for future extensions. Default is ``0``.</span>
<span class="sd">            wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block. Default is</span>
<span class="sd">                ``False``.</span>
<span class="sd">            wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain. Default</span>
<span class="sd">                is ``True``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the serve registration is successful, False otherwise.</span>

<span class="sd">        This function is essential for establishing the neuron&#39;s presence in the network, enabling</span>
<span class="sd">        it to participate in the decentralized machine learning processes of Bittensor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">serve_extrinsic</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="p">,</span>
            <span class="n">ip</span><span class="p">,</span>
            <span class="n">port</span><span class="p">,</span>
            <span class="n">protocol</span><span class="p">,</span>
            <span class="n">netuid</span><span class="p">,</span>
            <span class="n">placeholder1</span><span class="p">,</span>
            <span class="n">placeholder2</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.serve_axon">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.serve_axon">[docs]</a>
    <span class="k">def</span> <span class="nf">serve_axon</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">axon</span><span class="p">:</span> <span class="s2">&quot;bittensor.axon&quot;</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Registers an Axon serving endpoint on the Bittensor network for a specific neuron. This function</span>
<span class="sd">        is used to set up the Axon, a key component of a neuron that handles incoming queries and data</span>
<span class="sd">        processing tasks.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            axon (bittensor.Axon): The Axon instance to be registered for serving.</span>
<span class="sd">            wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.</span>
<span class="sd">            wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the Axon serve registration is successful, False otherwise.</span>

<span class="sd">        By registering an Axon, the neuron becomes an active part of the network&#39;s distributed</span>
<span class="sd">        computing infrastructure, contributing to the collective intelligence of Bittensor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">serve_axon_extrinsic</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">,</span> <span class="n">axon</span><span class="p">,</span> <span class="n">wait_for_inclusion</span><span class="p">,</span> <span class="n">wait_for_finalization</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor._do_serve_axon">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor._do_serve_axon">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">_do_serve_axon</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">call_params</span><span class="p">:</span> <span class="n">AxonServeCallParams</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal method to submit a serve axon transaction to the Bittensor blockchain. This method</span>
<span class="sd">        creates and submits a transaction, enabling a neuron&#39;s Axon to serve requests on the network.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet associated with the neuron.</span>
<span class="sd">            call_params (AxonServeCallParams): Parameters required for the serve axon call.</span>
<span class="sd">            wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.</span>
<span class="sd">            wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[bool, Optional[str]]: A tuple containing a success flag and an optional error message.</span>

<span class="sd">        This function is crucial for initializing and announcing a neuron&#39;s Axon service on the network,</span>
<span class="sd">        enhancing the decentralized computation capabilities of Bittensor.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">_logger</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">():</span>
            <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">compose_call</span><span class="p">(</span>
                <span class="n">call_module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
                <span class="n">call_function</span><span class="o">=</span><span class="s2">&quot;serve_axon&quot;</span><span class="p">,</span>
                <span class="n">call_params</span><span class="o">=</span><span class="n">call_params</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">extrinsic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">create_signed_extrinsic</span><span class="p">(</span>
                <span class="n">call</span><span class="o">=</span><span class="n">call</span><span class="p">,</span> <span class="n">keypair</span><span class="o">=</span><span class="n">wallet</span><span class="o">.</span><span class="n">hotkey</span>
            <span class="p">)</span>
            <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">submit_extrinsic</span><span class="p">(</span>
                <span class="n">extrinsic</span><span class="p">,</span>
                <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">wait_for_inclusion</span> <span class="ow">or</span> <span class="n">wait_for_finalization</span><span class="p">:</span>
                <span class="n">response</span><span class="o">.</span><span class="n">process_events</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">response</span><span class="o">.</span><span class="n">is_success</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">format_error_message</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">error_message</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span></div>


<div class="viewcode-block" id="Subtensor.serve_prometheus">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.serve_prometheus">[docs]</a>
    <span class="k">def</span> <span class="nf">serve_prometheus</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">port</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">prometheus_extrinsic</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">port</span><span class="o">=</span><span class="n">port</span><span class="p">,</span>
            <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor._do_serve_prometheus">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor._do_serve_prometheus">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">_do_serve_prometheus</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">call_params</span><span class="p">:</span> <span class="n">PrometheusServeCallParams</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sends a serve prometheus extrinsic to the chain.</span>
<span class="sd">        Args:</span>
<span class="sd">            wallet (:func:`bittensor.wallet`): Wallet object.</span>
<span class="sd">            call_params (:func:`PrometheusServeCallParams`): Prometheus serve call parameters.</span>
<span class="sd">            wait_for_inclusion (bool): If ``true``, waits for inclusion.</span>
<span class="sd">            wait_for_finalization (bool): If ``true``, waits for finalization.</span>
<span class="sd">        Returns:</span>
<span class="sd">            success (bool): ``True`` if serve prometheus was successful.</span>
<span class="sd">            error (:func:`Optional[str]`): Error message if serve prometheus failed, ``None`` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">_logger</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">():</span>
            <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">compose_call</span><span class="p">(</span>
                <span class="n">call_module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
                <span class="n">call_function</span><span class="o">=</span><span class="s2">&quot;serve_prometheus&quot;</span><span class="p">,</span>
                <span class="n">call_params</span><span class="o">=</span><span class="n">call_params</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">extrinsic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">create_signed_extrinsic</span><span class="p">(</span>
                <span class="n">call</span><span class="o">=</span><span class="n">call</span><span class="p">,</span> <span class="n">keypair</span><span class="o">=</span><span class="n">wallet</span><span class="o">.</span><span class="n">hotkey</span>
            <span class="p">)</span>
            <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">submit_extrinsic</span><span class="p">(</span>
                <span class="n">extrinsic</span><span class="p">,</span>
                <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">wait_for_inclusion</span> <span class="ow">or</span> <span class="n">wait_for_finalization</span><span class="p">:</span>
                <span class="n">response</span><span class="o">.</span><span class="n">process_events</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">response</span><span class="o">.</span><span class="n">is_success</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">format_error_message</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">error_message</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span></div>


<div class="viewcode-block" id="Subtensor._do_associate_ips">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor._do_associate_ips">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">_do_associate_ips</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">ip_info_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;IPInfo&quot;</span><span class="p">],</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sends an associate IPs extrinsic to the chain.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (:func:`bittensor.wallet`): Wallet object.</span>
<span class="sd">            ip_info_list (:func:`List[IPInfo]`): List of IPInfo objects.</span>
<span class="sd">            netuid (int): Netuid to associate IPs to.</span>
<span class="sd">            wait_for_inclusion (bool): If ``true``, waits for inclusion.</span>
<span class="sd">            wait_for_finalization (bool): If ``true``, waits for finalization.</span>

<span class="sd">        Returns:</span>
<span class="sd">            success (bool): ``True`` if associate IPs was successful.</span>
<span class="sd">            error (:func:`Optional[str]`): Error message if associate IPs failed, None otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">_logger</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">():</span>
            <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">compose_call</span><span class="p">(</span>
                <span class="n">call_module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
                <span class="n">call_function</span><span class="o">=</span><span class="s2">&quot;associate_ips&quot;</span><span class="p">,</span>
                <span class="n">call_params</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;ip_info_list&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">ip_info</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span> <span class="k">for</span> <span class="n">ip_info</span> <span class="ow">in</span> <span class="n">ip_info_list</span><span class="p">],</span>
                    <span class="s2">&quot;netuid&quot;</span><span class="p">:</span> <span class="n">netuid</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>
            <span class="n">extrinsic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">create_signed_extrinsic</span><span class="p">(</span>
                <span class="n">call</span><span class="o">=</span><span class="n">call</span><span class="p">,</span> <span class="n">keypair</span><span class="o">=</span><span class="n">wallet</span><span class="o">.</span><span class="n">hotkey</span>
            <span class="p">)</span>
            <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">submit_extrinsic</span><span class="p">(</span>
                <span class="n">extrinsic</span><span class="p">,</span>
                <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">wait_for_inclusion</span> <span class="ow">or</span> <span class="n">wait_for_finalization</span><span class="p">:</span>
                <span class="n">response</span><span class="o">.</span><span class="n">process_events</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">response</span><span class="o">.</span><span class="n">is_success</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">response</span><span class="o">.</span><span class="n">error_message</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span></div>


    <span class="c1">###########</span>
    <span class="c1"># Staking #</span>
    <span class="c1">###########</span>
<div class="viewcode-block" id="Subtensor.add_stake">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.add_stake">[docs]</a>
    <span class="k">def</span> <span class="nf">add_stake</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">amount</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="s2">&quot;Balance&quot;</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">prompt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds the specified amount of stake to a neuron identified by the hotkey ``SS58`` address. Staking</span>
<span class="sd">        is a fundamental process in the Bittensor network that enables neurons to participate actively</span>
<span class="sd">        and earn incentives.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet to be used for staking.</span>
<span class="sd">            hotkey_ss58 (Optional[str]): The ``SS58`` address of the hotkey associated with the neuron.</span>
<span class="sd">            amount (Union[Balance, float]): The amount of TAO to stake.</span>
<span class="sd">            wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.</span>
<span class="sd">            wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.</span>
<span class="sd">            prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the staking is successful, False otherwise.</span>

<span class="sd">        This function enables neurons to increase their stake in the network, enhancing their influence</span>
<span class="sd">        and potential rewards in line with Bittensor&#39;s consensus and reward mechanisms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">add_stake_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">hotkey_ss58</span><span class="o">=</span><span class="n">hotkey_ss58</span><span class="p">,</span>
            <span class="n">amount</span><span class="o">=</span><span class="n">amount</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">prompt</span><span class="o">=</span><span class="n">prompt</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.add_stake_multiple">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.add_stake_multiple">[docs]</a>
    <span class="k">def</span> <span class="nf">add_stake_multiple</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">hotkey_ss58s</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">amounts</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="s2">&quot;Balance&quot;</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">prompt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds stakes to multiple neurons identified by their hotkey SS58 addresses. This bulk operation</span>
<span class="sd">        allows for efficient staking across different neurons from a single wallet.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet used for staking.</span>
<span class="sd">            hotkey_ss58s (List[str]): List of ``SS58`` addresses of hotkeys to stake to.</span>
<span class="sd">            amounts (List[Union[Balance, float]], optional): Corresponding amounts of TAO to stake for each hotkey.</span>
<span class="sd">            wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.</span>
<span class="sd">            wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.</span>
<span class="sd">            prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the staking is successful for all specified neurons, False otherwise.</span>

<span class="sd">        This function is essential for managing stakes across multiple neurons, reflecting the dynamic</span>
<span class="sd">        and collaborative nature of the Bittensor network.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">add_stake_multiple_extrinsic</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="p">,</span>
            <span class="n">hotkey_ss58s</span><span class="p">,</span>
            <span class="n">amounts</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">prompt</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor._do_stake">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor._do_stake">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">_do_stake</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">amount</span><span class="p">:</span> <span class="s2">&quot;Balance&quot;</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sends a stake extrinsic to the chain.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (:func:`bittensor.wallet`): Wallet object that can sign the extrinsic.</span>
<span class="sd">            hotkey_ss58 (str): Hotkey ``ss58`` address to stake to.</span>
<span class="sd">            amount (:func:`Balance`): Amount to stake.</span>
<span class="sd">            wait_for_inclusion (bool): If ``true``, waits for inclusion before returning.</span>
<span class="sd">            wait_for_finalization (bool): If ``true``, waits for finalization before returning.</span>
<span class="sd">        Returns:</span>
<span class="sd">            success (bool): ``True`` if the extrinsic was successful.</span>
<span class="sd">        Raises:</span>
<span class="sd">            StakeError: If the extrinsic failed.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">_logger</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">():</span>
            <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">compose_call</span><span class="p">(</span>
                <span class="n">call_module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
                <span class="n">call_function</span><span class="o">=</span><span class="s2">&quot;add_stake&quot;</span><span class="p">,</span>
                <span class="n">call_params</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;hotkey&quot;</span><span class="p">:</span> <span class="n">hotkey_ss58</span><span class="p">,</span> <span class="s2">&quot;amount_staked&quot;</span><span class="p">:</span> <span class="n">amount</span><span class="o">.</span><span class="n">rao</span><span class="p">},</span>
            <span class="p">)</span>
            <span class="n">extrinsic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">create_signed_extrinsic</span><span class="p">(</span>
                <span class="n">call</span><span class="o">=</span><span class="n">call</span><span class="p">,</span> <span class="n">keypair</span><span class="o">=</span><span class="n">wallet</span><span class="o">.</span><span class="n">coldkey</span>
            <span class="p">)</span>
            <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">submit_extrinsic</span><span class="p">(</span>
                <span class="n">extrinsic</span><span class="p">,</span>
                <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># We only wait here if we expect finalization.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">wait_for_finalization</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">wait_for_inclusion</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>

            <span class="n">response</span><span class="o">.</span><span class="n">process_events</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">response</span><span class="o">.</span><span class="n">is_success</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">StakeError</span><span class="p">(</span><span class="n">format_error_message</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">error_message</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span></div>


    <span class="c1">#############</span>
    <span class="c1"># Unstaking #</span>
    <span class="c1">#############</span>
<div class="viewcode-block" id="Subtensor.unstake_multiple">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.unstake_multiple">[docs]</a>
    <span class="k">def</span> <span class="nf">unstake_multiple</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">hotkey_ss58s</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">amounts</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="s2">&quot;Balance&quot;</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">prompt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs batch unstaking from multiple hotkey accounts, allowing a neuron to reduce its staked amounts</span>
<span class="sd">        efficiently. This function is useful for managing the distribution of stakes across multiple neurons.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet linked to the coldkey from which the stakes are being withdrawn.</span>
<span class="sd">            hotkey_ss58s (List[str]): A list of hotkey ``SS58`` addresses to unstake from.</span>
<span class="sd">            amounts (List[Union[Balance, float]], optional): The amounts of TAO to unstake from each hotkey. If not</span>
<span class="sd">                provided, unstakes all available stakes.</span>
<span class="sd">            wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.</span>
<span class="sd">            wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.</span>
<span class="sd">            prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the batch unstaking is successful, False otherwise.</span>

<span class="sd">        This function allows for strategic reallocation or withdrawal of stakes, aligning with the dynamic</span>
<span class="sd">        stake management aspect of the Bittensor network.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">unstake_multiple_extrinsic</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="p">,</span>
            <span class="n">hotkey_ss58s</span><span class="p">,</span>
            <span class="n">amounts</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">prompt</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.unstake">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.unstake">[docs]</a>
    <span class="k">def</span> <span class="nf">unstake</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">amount</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="s2">&quot;Balance&quot;</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">prompt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes a specified amount of stake from a single hotkey account. This function is critical for adjusting</span>
<span class="sd">        individual neuron stakes within the Bittensor network.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet associated with the neuron from which the stake is being removed.</span>
<span class="sd">            hotkey_ss58 (Optional[str]): The ``SS58`` address of the hotkey account to unstake from.</span>
<span class="sd">            amount (Union[Balance, float], optional): The amount of TAO to unstake. If not specified, unstakes all.</span>
<span class="sd">            wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.</span>
<span class="sd">            wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.</span>
<span class="sd">            prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the unstaking process is successful, False otherwise.</span>

<span class="sd">        This function supports flexible stake management, allowing neurons to adjust their network participation</span>
<span class="sd">        and potential reward accruals.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">unstake_extrinsic</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="p">,</span>
            <span class="n">hotkey_ss58</span><span class="p">,</span>
            <span class="n">amount</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">prompt</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor._do_unstake">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor._do_unstake">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">_do_unstake</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">amount</span><span class="p">:</span> <span class="s2">&quot;Balance&quot;</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sends an unstake extrinsic to the chain.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (:func:`bittensor.wallet`): Wallet object that can sign the extrinsic.</span>
<span class="sd">            hotkey_ss58 (str): Hotkey ``ss58`` address to unstake from.</span>
<span class="sd">            amount (:func:`Balance`): Amount to unstake.</span>
<span class="sd">            wait_for_inclusion (bool): If ``true``, waits for inclusion before returning.</span>
<span class="sd">            wait_for_finalization (bool): If ``true``, waits for finalization before returning.</span>
<span class="sd">        Returns:</span>
<span class="sd">            success (bool): ``True`` if the extrinsic was successful.</span>
<span class="sd">        Raises:</span>
<span class="sd">            StakeError: If the extrinsic failed.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">_logger</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">():</span>
            <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">compose_call</span><span class="p">(</span>
                <span class="n">call_module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
                <span class="n">call_function</span><span class="o">=</span><span class="s2">&quot;remove_stake&quot;</span><span class="p">,</span>
                <span class="n">call_params</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;hotkey&quot;</span><span class="p">:</span> <span class="n">hotkey_ss58</span><span class="p">,</span> <span class="s2">&quot;amount_unstaked&quot;</span><span class="p">:</span> <span class="n">amount</span><span class="o">.</span><span class="n">rao</span><span class="p">},</span>
            <span class="p">)</span>
            <span class="n">extrinsic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">create_signed_extrinsic</span><span class="p">(</span>
                <span class="n">call</span><span class="o">=</span><span class="n">call</span><span class="p">,</span> <span class="n">keypair</span><span class="o">=</span><span class="n">wallet</span><span class="o">.</span><span class="n">coldkey</span>
            <span class="p">)</span>
            <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">submit_extrinsic</span><span class="p">(</span>
                <span class="n">extrinsic</span><span class="p">,</span>
                <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># We only wait here if we expect finalization.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">wait_for_finalization</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">wait_for_inclusion</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>

            <span class="n">response</span><span class="o">.</span><span class="n">process_events</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">response</span><span class="o">.</span><span class="n">is_success</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">StakeError</span><span class="p">(</span><span class="n">format_error_message</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">error_message</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span></div>


    <span class="c1">###################</span>
    <span class="c1"># Child hotkeys #</span>
    <span class="c1">###################</span>

<div class="viewcode-block" id="Subtensor.set_childkey_take">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.set_childkey_take">[docs]</a>
    <span class="k">def</span> <span class="nf">set_childkey_take</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">hotkey</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">take</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">prompt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets a childkey take extrinsic on the subnet.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (:func:`bittensor.wallet`): Wallet object that can sign the extrinsic.</span>
<span class="sd">            hotkey: (str): Hotkey ``ss58`` address of the child for which take is getting set.</span>
<span class="sd">            netuid (int): Unique identifier of for the subnet.</span>
<span class="sd">            take (float): Value of childhotkey take on subnet.</span>
<span class="sd">            wait_for_inclusion (bool): If ``true``, waits for inclusion before returning.</span>
<span class="sd">            wait_for_finalization (bool): If ``true``, waits for finalization before returning.</span>
<span class="sd">            prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding.</span>
<span class="sd">        Returns:</span>
<span class="sd">            success (bool): ``True`` if the extrinsic was successful.</span>
<span class="sd">        Raises:</span>
<span class="sd">            ChildHotkeyError: If the extrinsic failed.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">set_childkey_take_extrinsic</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">hotkey</span><span class="o">=</span><span class="n">hotkey</span><span class="p">,</span>
            <span class="n">take</span><span class="o">=</span><span class="n">take</span><span class="p">,</span>
            <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">prompt</span><span class="o">=</span><span class="n">prompt</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor._do_set_childkey_take">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor._do_set_childkey_take">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">_do_set_childkey_take</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">hotkey</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">take</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sends a set_children hotkey extrinsic on the chain.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (:func:`bittensor.wallet`): Wallet object that can sign the extrinsic.</span>
<span class="sd">            hotkey: (str): Hotkey ``ss58`` address of the wallet for which take is getting set.</span>
<span class="sd">            take: (int): The take that this ss58 hotkey will have if assigned as a child hotkey as u16 value.</span>
<span class="sd">            netuid (int): Unique identifier for the network.</span>
<span class="sd">            wait_for_inclusion (bool): If ``true``, waits for inclusion before returning.</span>
<span class="sd">            wait_for_finalization (bool): If ``true``, waits for finalization before returning.</span>
<span class="sd">        Returns:</span>
<span class="sd">            success (bool): ``True`` if the extrinsic was successful.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">_logger</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">():</span>
            <span class="c1"># create extrinsic call</span>
            <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">compose_call</span><span class="p">(</span>
                <span class="n">call_module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
                <span class="n">call_function</span><span class="o">=</span><span class="s2">&quot;set_childkey_take&quot;</span><span class="p">,</span>
                <span class="n">call_params</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;hotkey&quot;</span><span class="p">:</span> <span class="n">hotkey</span><span class="p">,</span>
                    <span class="s2">&quot;take&quot;</span><span class="p">:</span> <span class="n">take</span><span class="p">,</span>
                    <span class="s2">&quot;netuid&quot;</span><span class="p">:</span> <span class="n">netuid</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>
            <span class="n">extrinsic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">create_signed_extrinsic</span><span class="p">(</span>
                <span class="n">call</span><span class="o">=</span><span class="n">call</span><span class="p">,</span> <span class="n">keypair</span><span class="o">=</span><span class="n">wallet</span><span class="o">.</span><span class="n">coldkey</span>
            <span class="p">)</span>
            <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">submit_extrinsic</span><span class="p">(</span>
                <span class="n">extrinsic</span><span class="p">,</span>
                <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">wait_for_finalization</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">wait_for_inclusion</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">None</span>

            <span class="n">response</span><span class="o">.</span><span class="n">process_events</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">response</span><span class="o">.</span><span class="n">is_success</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">format_error_message</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">error_message</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span></div>


<div class="viewcode-block" id="Subtensor.set_children">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.set_children">[docs]</a>
    <span class="k">def</span> <span class="nf">set_children</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">hotkey</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">children_with_proportions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">prompt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets a children hotkeys extrinsic on the subnet.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (:func:`bittensor.wallet`): Wallet object that can sign the extrinsic.</span>
<span class="sd">            hotkey: (str): Hotkey ``ss58`` address of the parent.</span>
<span class="sd">            netuid (int): Unique identifier of for the subnet.</span>
<span class="sd">            children_with_proportions (List[Tuple[float, str]]): List of (proportion, child_ss58) pairs.</span>
<span class="sd">            wait_for_inclusion (bool): If ``true``, waits for inclusion before returning.</span>
<span class="sd">            wait_for_finalization (bool): If ``true``, waits for finalization before returning.</span>
<span class="sd">            prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding.</span>
<span class="sd">        Returns:</span>
<span class="sd">            success (bool): ``True`` if the extrinsic was successful.</span>
<span class="sd">        Raises:</span>
<span class="sd">            ChildHotkeyError: If the extrinsic failed.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">set_children_extrinsic</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">hotkey</span><span class="o">=</span><span class="n">hotkey</span><span class="p">,</span>
            <span class="n">children_with_proportions</span><span class="o">=</span><span class="n">children_with_proportions</span><span class="p">,</span>
            <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">prompt</span><span class="o">=</span><span class="n">prompt</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor._do_set_children">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor._do_set_children">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">_do_set_children</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">hotkey</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">children</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sends a set_children hotkey extrinsic on the chain.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (:func:`bittensor.wallet`): Wallet object that can sign the extrinsic.</span>
<span class="sd">            hotkey: (str): Hotkey ``ss58`` address of the parent.</span>
<span class="sd">            children: (List[Tuple[int, str]]): A list of tuples containing the hotkey ``ss58`` addresses of the children and their proportions as u16 MAX standardized values.</span>
<span class="sd">            netuid (int): Unique identifier for the network.</span>
<span class="sd">            wait_for_inclusion (bool): If ``true``, waits for inclusion before returning.</span>
<span class="sd">            wait_for_finalization (bool): If ``true``, waits for finalization before returning.</span>
<span class="sd">        Returns:</span>
<span class="sd">            success (bool): ``True`` if the extrinsic was successful.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">_logger</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">():</span>
            <span class="c1"># create extrinsic call</span>
            <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">compose_call</span><span class="p">(</span>
                <span class="n">call_module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
                <span class="n">call_function</span><span class="o">=</span><span class="s2">&quot;set_children&quot;</span><span class="p">,</span>
                <span class="n">call_params</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;hotkey&quot;</span><span class="p">:</span> <span class="n">hotkey</span><span class="p">,</span>
                    <span class="s2">&quot;children&quot;</span><span class="p">:</span> <span class="n">children</span><span class="p">,</span>
                    <span class="s2">&quot;netuid&quot;</span><span class="p">:</span> <span class="n">netuid</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>
            <span class="n">extrinsic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">create_signed_extrinsic</span><span class="p">(</span>
                <span class="n">call</span><span class="o">=</span><span class="n">call</span><span class="p">,</span> <span class="n">keypair</span><span class="o">=</span><span class="n">wallet</span><span class="o">.</span><span class="n">coldkey</span>
            <span class="p">)</span>
            <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">submit_extrinsic</span><span class="p">(</span>
                <span class="n">extrinsic</span><span class="p">,</span>
                <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">wait_for_finalization</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">wait_for_inclusion</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">None</span>

            <span class="n">response</span><span class="o">.</span><span class="n">process_events</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">response</span><span class="o">.</span><span class="n">is_success</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">format_error_message</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">error_message</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span></div>


    <span class="c1">##################</span>
    <span class="c1"># Coldkey Swap   #</span>
    <span class="c1">##################</span>

<div class="viewcode-block" id="Subtensor.check_in_arbitration">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.check_in_arbitration">[docs]</a>
    <span class="k">def</span> <span class="nf">check_in_arbitration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ss58_address</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks storage function to see if the provided coldkey is in arbitration.</span>
<span class="sd">        If 0, `swap` has not been called on this key. If 1, swap has been called once, so</span>
<span class="sd">        the key is not in arbitration. If &gt;1, `swap` has been called with multiple destinations, and</span>
<span class="sd">        the key is thus in arbitration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_module</span><span class="p">(</span>
            <span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span> <span class="s2">&quot;ColdkeySwapDestinations&quot;</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">ss58_address</span><span class="p">]</span>
        <span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span></div>


<div class="viewcode-block" id="Subtensor.get_remaining_arbitration_period">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_remaining_arbitration_period">[docs]</a>
    <span class="k">def</span> <span class="nf">get_remaining_arbitration_period</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">coldkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the remaining arbitration period for a given coldkey.</span>
<span class="sd">        Args:</span>
<span class="sd">            coldkey_ss58 (str): The SS58 address of the coldkey.</span>
<span class="sd">            block (Optional[int], optional): The block number to query. If None, uses the latest block.</span>
<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The remaining arbitration period in blocks, or 0 if not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">arbitration_block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_subtensor</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;ColdkeyArbitrationBlock&quot;</span><span class="p">,</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">coldkey_ss58</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span>

        <span class="k">if</span> <span class="n">arbitration_block</span><span class="o">.</span><span class="n">value</span> <span class="o">&gt;</span> <span class="n">block</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">arbitration_block</span><span class="o">.</span><span class="n">value</span> <span class="o">-</span> <span class="n">block</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span></div>


    <span class="c1">##########</span>
    <span class="c1"># Senate #</span>
    <span class="c1">##########</span>

<div class="viewcode-block" id="Subtensor.register_senate">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.register_senate">[docs]</a>
    <span class="k">def</span> <span class="nf">register_senate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">prompt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes a specified amount of stake from a single hotkey account. This function is critical for adjusting</span>
<span class="sd">        individual neuron stakes within the Bittensor network.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet associated with the neuron from which the stake is being removed.</span>
<span class="sd">            wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.</span>
<span class="sd">            wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.</span>
<span class="sd">            prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the unstaking process is successful, False otherwise.</span>

<span class="sd">        This function supports flexible stake management, allowing neurons to adjust their network participation</span>
<span class="sd">        and potential reward accruals.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">register_senate_extrinsic</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">wallet</span><span class="p">,</span> <span class="n">wait_for_inclusion</span><span class="p">,</span> <span class="n">wait_for_finalization</span><span class="p">,</span> <span class="n">prompt</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.leave_senate">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.leave_senate">[docs]</a>
    <span class="k">def</span> <span class="nf">leave_senate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">prompt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes a specified amount of stake from a single hotkey account. This function is critical for adjusting</span>
<span class="sd">        individual neuron stakes within the Bittensor network.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet associated with the neuron from which the stake is being removed.</span>
<span class="sd">            wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.</span>
<span class="sd">            wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.</span>
<span class="sd">            prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the unstaking process is successful, False otherwise.</span>

<span class="sd">        This function supports flexible stake management, allowing neurons to adjust their network participation</span>
<span class="sd">        and potential reward accruals.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">leave_senate_extrinsic</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">wallet</span><span class="p">,</span> <span class="n">wait_for_inclusion</span><span class="p">,</span> <span class="n">wait_for_finalization</span><span class="p">,</span> <span class="n">prompt</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.vote_senate">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.vote_senate">[docs]</a>
    <span class="k">def</span> <span class="nf">vote_senate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">proposal_hash</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">proposal_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">vote</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">prompt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes a specified amount of stake from a single hotkey account. This function is critical for adjusting</span>
<span class="sd">        individual neuron stakes within the Bittensor network.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet associated with the neuron from which the stake is being removed.</span>
<span class="sd">            proposal_hash (str): The hash of the proposal being voted on.</span>
<span class="sd">            proposal_idx (int): The index of the proposal being voted on.</span>
<span class="sd">            vote (bool): The vote to be cast (True for yes, False for no).</span>
<span class="sd">            wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.</span>
<span class="sd">            wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.</span>
<span class="sd">            prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the unstaking process is successful, False otherwise.</span>

<span class="sd">        This function supports flexible stake management, allowing neurons to adjust their network participation</span>
<span class="sd">        and potential reward accruals.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">vote_senate_extrinsic</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="p">,</span>
            <span class="n">proposal_hash</span><span class="p">,</span>
            <span class="n">proposal_idx</span><span class="p">,</span>
            <span class="n">vote</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">prompt</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.is_senate_member">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.is_senate_member">[docs]</a>
    <span class="k">def</span> <span class="nf">is_senate_member</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if a given neuron (identified by its hotkey SS58 address) is a member of the Bittensor senate.</span>
<span class="sd">        The senate is a key governance body within the Bittensor network, responsible for overseeing and</span>
<span class="sd">        approving various network operations and proposals.</span>

<span class="sd">        Args:</span>
<span class="sd">            hotkey_ss58 (str): The ``SS58`` address of the neuron&#39;s hotkey.</span>
<span class="sd">            block (Optional[int]): The blockchain block number at which to check senate membership.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the neuron is a senate member at the given block, False otherwise.</span>

<span class="sd">        This function is crucial for understanding the governance dynamics of the Bittensor network and for</span>
<span class="sd">        identifying the neurons that hold decision-making power within the network.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">senate_members</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_module</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SenateMembers&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Members&quot;</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">senate_members</span><span class="p">,</span> <span class="s2">&quot;serialize&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">senate_members_serialized</span> <span class="o">=</span> <span class="n">senate_members</span><span class="o">.</span><span class="n">serialize</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">senate_members_serialized</span><span class="p">,</span> <span class="s2">&quot;count&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">senate_members_serialized</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">hotkey_ss58</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="Subtensor.get_vote_data">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_vote_data">[docs]</a>
    <span class="k">def</span> <span class="nf">get_vote_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">proposal_hash</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ProposalVoteData</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the voting data for a specific proposal on the Bittensor blockchain. This data includes</span>
<span class="sd">        information about how senate members have voted on the proposal.</span>

<span class="sd">        Args:</span>
<span class="sd">            proposal_hash (str): The hash of the proposal for which voting data is requested.</span>
<span class="sd">            block (Optional[int]): The blockchain block number to query the voting data.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[ProposalVoteData]: An object containing the proposal&#39;s voting data, or ``None`` if not found.</span>

<span class="sd">        This function is important for tracking and understanding the decision-making processes within</span>
<span class="sd">        the Bittensor network, particularly how proposals are received and acted upon by the governing body.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vote_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_module</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;Triumvirate&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Voting&quot;</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">proposal_hash</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">vote_data</span><span class="p">,</span> <span class="s2">&quot;serialize&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">vote_data</span><span class="o">.</span><span class="n">serialize</span><span class="p">()</span> <span class="k">if</span> <span class="n">vote_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span></div>


    <span class="n">get_proposal_vote_data</span> <span class="o">=</span> <span class="n">get_vote_data</span>

<div class="viewcode-block" id="Subtensor.get_senate_members">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_senate_members">[docs]</a>
    <span class="k">def</span> <span class="nf">get_senate_members</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the list of current senate members from the Bittensor blockchain. Senate members are</span>
<span class="sd">        responsible for governance and decision-making within the network.</span>

<span class="sd">        Args:</span>
<span class="sd">            block (Optional[int]): The blockchain block number at which to retrieve the senate members.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[List[str]]: A list of ``SS58`` addresses of current senate members, or ``None`` if not available.</span>

<span class="sd">        Understanding the composition of the senate is key to grasping the governance structure and</span>
<span class="sd">        decision-making authority within the Bittensor network.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">senate_members</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_module</span><span class="p">(</span><span class="s2">&quot;SenateMembers&quot;</span><span class="p">,</span> <span class="s2">&quot;Members&quot;</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">senate_members</span><span class="p">,</span> <span class="s2">&quot;serialize&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">senate_members</span><span class="o">.</span><span class="n">serialize</span><span class="p">()</span> <span class="k">if</span> <span class="n">senate_members</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Subtensor.get_proposal_call_data">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_proposal_call_data">[docs]</a>
    <span class="k">def</span> <span class="nf">get_proposal_call_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">proposal_hash</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;GenericCall&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the call data of a specific proposal on the Bittensor blockchain. This data provides</span>
<span class="sd">        detailed information about the proposal, including its purpose and specifications.</span>

<span class="sd">        Args:</span>
<span class="sd">            proposal_hash (str): The hash of the proposal.</span>
<span class="sd">            block (Optional[int]): The blockchain block number at which to query the proposal call data.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[GenericCall]: An object containing the proposal&#39;s call data, or ``None`` if not found.</span>

<span class="sd">        This function is crucial for analyzing the types of proposals made within the network and the</span>
<span class="sd">        specific changes or actions they intend to implement or address.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">proposal_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_module</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;Triumvirate&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;ProposalOf&quot;</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">proposal_hash</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">proposal_data</span><span class="p">,</span> <span class="s2">&quot;serialize&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">proposal_data</span><span class="o">.</span><span class="n">serialize</span><span class="p">()</span> <span class="k">if</span> <span class="n">proposal_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Subtensor.get_proposal_hashes">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_proposal_hashes">[docs]</a>
    <span class="k">def</span> <span class="nf">get_proposal_hashes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the list of proposal hashes currently present on the Bittensor blockchain. Each hash</span>
<span class="sd">        uniquely identifies a proposal made within the network.</span>

<span class="sd">        Args:</span>
<span class="sd">            block (Optional[int]): The blockchain block number to query the proposal hashes.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[List[str]]: A list of proposal hashes, or ``None`` if not available.</span>

<span class="sd">        This function enables tracking and reviewing the proposals made in the network, offering insights</span>
<span class="sd">        into the active governance and decision-making processes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">proposal_hashes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_module</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;Triumvirate&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Proposals&quot;</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">proposal_hashes</span><span class="p">,</span> <span class="s2">&quot;serialize&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">proposal_hashes</span><span class="o">.</span><span class="n">serialize</span><span class="p">()</span> <span class="k">if</span> <span class="n">proposal_hashes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Subtensor.get_proposals">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_proposals">[docs]</a>
    <span class="k">def</span> <span class="nf">get_proposals</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="s2">&quot;GenericCall&quot;</span><span class="p">,</span> <span class="s2">&quot;ProposalVoteData&quot;</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves all active proposals on the Bittensor blockchain, along with their call and voting data.</span>
<span class="sd">        This comprehensive view allows for a thorough understanding of the proposals and their reception</span>
<span class="sd">        by the senate.</span>

<span class="sd">        Args:</span>
<span class="sd">            block (Optional[int]): The blockchain block number to query the proposals.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[Dict[str, Tuple[bittensor.ProposalCallData, bittensor.ProposalVoteData]]]: A dictionary mapping</span>
<span class="sd">                proposal hashes to their corresponding call and vote data, or ``None`` if not available.</span>

<span class="sd">        This function is integral for analyzing the governance activity on the Bittensor network,</span>
<span class="sd">        providing a holistic view of the proposals and their impact or potential changes within the network.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">proposal_hashes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_proposal_hashes</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">proposal_hashes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="n">proposal_hash</span><span class="p">:</span> <span class="p">(</span>  <span class="c1"># type: ignore</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_proposal_call_data</span><span class="p">(</span><span class="n">proposal_hash</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_proposal_vote_data</span><span class="p">(</span><span class="n">proposal_hash</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">proposal_hash</span> <span class="ow">in</span> <span class="n">proposal_hashes</span>
        <span class="p">}</span></div>


    <span class="c1">########</span>
    <span class="c1"># Root #</span>
    <span class="c1">########</span>

<div class="viewcode-block" id="Subtensor.root_register">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.root_register">[docs]</a>
    <span class="k">def</span> <span class="nf">root_register</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">prompt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Registers the neuron associated with the wallet on the root network. This process is integral for</span>
<span class="sd">        participating in the highest layer of decision-making and governance within the Bittensor network.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet associated with the neuron to be registered on the root network.</span>
<span class="sd">            wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.</span>
<span class="sd">            wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.</span>
<span class="sd">            prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the registration on the root network is successful, False otherwise.</span>

<span class="sd">        This function enables neurons to engage in the most critical and influential aspects of the network&#39;s</span>
<span class="sd">        governance, signifying a high level of commitment and responsibility in the Bittensor ecosystem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">root_register_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">prompt</span><span class="o">=</span><span class="n">prompt</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor._do_root_register">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor._do_root_register">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">_do_root_register</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">_logger</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">():</span>
            <span class="c1"># create extrinsic call</span>
            <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">compose_call</span><span class="p">(</span>
                <span class="n">call_module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
                <span class="n">call_function</span><span class="o">=</span><span class="s2">&quot;root_register&quot;</span><span class="p">,</span>
                <span class="n">call_params</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;hotkey&quot;</span><span class="p">:</span> <span class="n">wallet</span><span class="o">.</span><span class="n">hotkey</span><span class="o">.</span><span class="n">ss58_address</span><span class="p">},</span>
            <span class="p">)</span>
            <span class="n">extrinsic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">create_signed_extrinsic</span><span class="p">(</span>
                <span class="n">call</span><span class="o">=</span><span class="n">call</span><span class="p">,</span> <span class="n">keypair</span><span class="o">=</span><span class="n">wallet</span><span class="o">.</span><span class="n">coldkey</span>
            <span class="p">)</span>
            <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">submit_extrinsic</span><span class="p">(</span>
                <span class="n">extrinsic</span><span class="p">,</span>
                <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># We only wait here if we expect finalization.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">wait_for_finalization</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">wait_for_inclusion</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>

            <span class="c1"># process if registration successful, try again if pow is still valid</span>
            <span class="n">response</span><span class="o">.</span><span class="n">process_events</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">response</span><span class="o">.</span><span class="n">is_success</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">format_error_message</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">error_message</span><span class="p">)</span>
            <span class="c1"># Successful registration</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span></div>


<div class="viewcode-block" id="Subtensor.root_set_weights">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.root_set_weights">[docs]</a>
    <span class="nd">@legacy_torch_api_compat</span>
    <span class="k">def</span> <span class="nf">root_set_weights</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">netuids</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">],</span> <span class="s2">&quot;torch.LongTensor&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">],</span>
        <span class="n">weights</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">],</span> <span class="s2">&quot;torch.FloatTensor&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">],</span>
        <span class="n">version_key</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">prompt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the weights for neurons on the root network. This action is crucial for defining the influence</span>
<span class="sd">        and interactions of neurons at the root level of the Bittensor network.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet associated with the neuron setting the weights.</span>
<span class="sd">            netuids (Union[NDArray[np.int64], torch.LongTensor, list]): The list of neuron UIDs for which weights are</span>
<span class="sd">                being set.</span>
<span class="sd">            weights (Union[NDArray[np.float32], torch.FloatTensor, list]): The corresponding weights to be set for each</span>
<span class="sd">                UID.</span>
<span class="sd">            version_key (int, optional): Version key for compatibility with the network.</span>
<span class="sd">            wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.</span>
<span class="sd">            wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.</span>
<span class="sd">            prompt (bool, optional): If ``True``, prompts for user confirmation before proceeding.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the setting of root-level weights is successful, False otherwise.</span>

<span class="sd">        This function plays a pivotal role in shaping the root network&#39;s collective intelligence and decision-making</span>
<span class="sd">        processes, reflecting the principles of decentralized governance and collaborative learning in Bittensor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">set_root_weights_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">netuids</span><span class="o">=</span><span class="n">netuids</span><span class="p">,</span>
            <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span>
            <span class="n">version_key</span><span class="o">=</span><span class="n">version_key</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">prompt</span><span class="o">=</span><span class="n">prompt</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor._do_set_root_weights">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor._do_set_root_weights">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">_do_set_root_weights</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">uids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">vals</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">version_key</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">bittensor</span><span class="o">.</span><span class="n">__version_as_int__</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>  <span class="c1"># (success, error_message)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal method to send a transaction to the Bittensor blockchain, setting weights</span>
<span class="sd">        for specified neurons on root. This method constructs and submits the transaction, handling</span>
<span class="sd">        retries and blockchain communication.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet associated with the neuron setting the weights.</span>
<span class="sd">            uids (List[int]): List of neuron UIDs for which weights are being set.</span>
<span class="sd">            vals (List[int]): List of weight values corresponding to each UID.</span>
<span class="sd">            netuid (int): Unique identifier for the network.</span>
<span class="sd">            version_key (int, optional): Version key for compatibility with the network.</span>
<span class="sd">            wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.</span>
<span class="sd">            wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[bool, Optional[str]]: A tuple containing a success flag and an optional error message.</span>

<span class="sd">        This method is vital for the dynamic weighting mechanism in Bittensor, where neurons adjust their</span>
<span class="sd">        trust in other neurons based on observed performance and contributions on the root network.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">_logger</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">():</span>
            <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">compose_call</span><span class="p">(</span>
                <span class="n">call_module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
                <span class="n">call_function</span><span class="o">=</span><span class="s2">&quot;set_root_weights&quot;</span><span class="p">,</span>
                <span class="n">call_params</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;dests&quot;</span><span class="p">:</span> <span class="n">uids</span><span class="p">,</span>
                    <span class="s2">&quot;weights&quot;</span><span class="p">:</span> <span class="n">vals</span><span class="p">,</span>
                    <span class="s2">&quot;netuid&quot;</span><span class="p">:</span> <span class="n">netuid</span><span class="p">,</span>
                    <span class="s2">&quot;version_key&quot;</span><span class="p">:</span> <span class="n">version_key</span><span class="p">,</span>
                    <span class="s2">&quot;hotkey&quot;</span><span class="p">:</span> <span class="n">wallet</span><span class="o">.</span><span class="n">hotkey</span><span class="o">.</span><span class="n">ss58_address</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>
            <span class="c1"># Period dictates how long the extrinsic will stay as part of waiting pool</span>
            <span class="n">extrinsic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">create_signed_extrinsic</span><span class="p">(</span>
                <span class="n">call</span><span class="o">=</span><span class="n">call</span><span class="p">,</span>
                <span class="n">keypair</span><span class="o">=</span><span class="n">wallet</span><span class="o">.</span><span class="n">coldkey</span><span class="p">,</span>
                <span class="n">era</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;period&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span>
            <span class="p">)</span>
            <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">submit_extrinsic</span><span class="p">(</span>
                <span class="n">extrinsic</span><span class="p">,</span>
                <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># We only wait here if we expect finalization.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">wait_for_finalization</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">wait_for_inclusion</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;Not waiting for finalziation or inclusion.&quot;</span>

            <span class="n">response</span><span class="o">.</span><span class="n">process_events</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">response</span><span class="o">.</span><span class="n">is_success</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;Successfully set weights.&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">response</span><span class="o">.</span><span class="n">error_message</span>

        <span class="k">return</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span></div>


    <span class="c1">##################</span>
    <span class="c1"># Registry Calls #</span>
    <span class="c1">##################</span>

    <span class="c1"># Queries subtensor registry named storage with params and block.</span>
<div class="viewcode-block" id="Subtensor.query_identity">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.query_identity">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">query_identity</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Queries the identity of a neuron on the Bittensor blockchain using the given key. This function retrieves</span>
<span class="sd">        detailed identity information about a specific neuron, which is a crucial aspect of the network&#39;s decentralized</span>
<span class="sd">        identity and governance system.</span>

<span class="sd">        NOTE:</span>
<span class="sd">            See the `Bittensor CLI documentation &lt;https://docs.bittensor.com/reference/btcli&gt;`_ for supported identity</span>
<span class="sd">            parameters.</span>

<span class="sd">        Args:</span>
<span class="sd">            key (str): The key used to query the neuron&#39;s identity, typically the neuron&#39;s ``SS58`` address.</span>
<span class="sd">            block (Optional[int]): The blockchain block number at which to perform the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            result (dict): An object containing the identity information of the neuron if found, ``None`` otherwise.</span>

<span class="sd">        The identity information can include various attributes such as the neuron&#39;s stake, rank, and other</span>
<span class="sd">        network-specific details, providing insights into the neuron&#39;s role and status within the Bittensor network.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">_logger</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="s2">&quot;ScaleType&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
                <span class="n">module</span><span class="o">=</span><span class="s2">&quot;Registry&quot;</span><span class="p">,</span>
                <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;IdentityOf&quot;</span><span class="p">,</span>
                <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                <span class="n">block_hash</span><span class="o">=</span><span class="p">(</span>
                    <span class="kc">None</span> <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
                <span class="p">),</span>
            <span class="p">)</span>

        <span class="n">identity_info</span> <span class="o">=</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">bittensor</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">wallet_utils</span><span class="o">.</span><span class="n">decode_hex_identity_dict</span><span class="p">(</span>
            <span class="n">identity_info</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="s2">&quot;info&quot;</span><span class="p">]</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.update_identity">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.update_identity">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">update_identity</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">identified</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates the identity of a neuron on the Bittensor blockchain. This function allows neurons to modify their</span>
<span class="sd">        identity attributes, reflecting changes in their roles, stakes, or other network-specific parameters.</span>

<span class="sd">        NOTE:</span>
<span class="sd">            See the `Bittensor CLI documentation &lt;https://docs.bittensor.com/reference/btcli&gt;`_ for supported identity</span>
<span class="sd">            parameters.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet associated with the neuron whose identity is being updated.</span>
<span class="sd">            identified (str, optional): The identified ``SS58`` address of the neuron. Defaults to the wallet&#39;s coldkey</span>
<span class="sd">                address.</span>
<span class="sd">            params (dict, optional): A dictionary of parameters to update in the neuron&#39;s identity.</span>
<span class="sd">            wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block.</span>
<span class="sd">            wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the identity update is successful, False otherwise.</span>

<span class="sd">        This function plays a vital role in maintaining the accuracy and currency of neuron identities in the</span>
<span class="sd">        Bittensor network, ensuring that the network&#39;s governance and consensus mechanisms operate effectively.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">identified</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">identified</span> <span class="o">=</span> <span class="n">wallet</span><span class="o">.</span><span class="n">coldkey</span><span class="o">.</span><span class="n">ss58_address</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">params</span>

        <span class="n">call_params</span> <span class="o">=</span> <span class="n">bittensor</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">wallet_utils</span><span class="o">.</span><span class="n">create_identity_dict</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>
        <span class="n">call_params</span><span class="p">[</span><span class="s2">&quot;identified&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">identified</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">_logger</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">compose_call</span><span class="p">(</span>
                <span class="n">call_module</span><span class="o">=</span><span class="s2">&quot;Registry&quot;</span><span class="p">,</span>
                <span class="n">call_function</span><span class="o">=</span><span class="s2">&quot;set_identity&quot;</span><span class="p">,</span>
                <span class="n">call_params</span><span class="o">=</span><span class="n">call_params</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">extrinsic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">create_signed_extrinsic</span><span class="p">(</span>
                <span class="n">call</span><span class="o">=</span><span class="n">call</span><span class="p">,</span> <span class="n">keypair</span><span class="o">=</span><span class="n">wallet</span><span class="o">.</span><span class="n">coldkey</span>
            <span class="p">)</span>
            <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">submit_extrinsic</span><span class="p">(</span>
                <span class="n">extrinsic</span><span class="p">,</span>
                <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># We only wait here if we expect finalization.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">wait_for_finalization</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">wait_for_inclusion</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="n">response</span><span class="o">.</span><span class="n">process_events</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">response</span><span class="o">.</span><span class="n">is_success</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">IdentityError</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">error_message</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span></div>


    <span class="c1"># Make some commitment on-chain about arbitrary data.</span>
<div class="viewcode-block" id="Subtensor.commit">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.commit">[docs]</a>
    <span class="k">def</span> <span class="nf">commit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wallet</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Commits arbitrary data to the Bittensor network by publishing metadata.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet associated with the neuron committing the data.</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            data (str): The data to be committed to the network.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">publish_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wallet</span><span class="p">,</span> <span class="n">netuid</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Raw</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span></div>


<div class="viewcode-block" id="Subtensor.get_commitment">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_commitment">[docs]</a>
    <span class="k">def</span> <span class="nf">get_commitment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">uid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the on-chain commitment for a specific neuron in the Bittensor network.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            uid (int): The unique identifier of the neuron.</span>
<span class="sd">            block (Optional[int]): The block number to retrieve the commitment from. If None, the latest block</span>
<span class="sd">                is used. Default is ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: The commitment data as a string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">metagraph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metagraph</span><span class="p">(</span><span class="n">netuid</span><span class="p">)</span>
        <span class="n">hotkey</span> <span class="o">=</span> <span class="n">metagraph</span><span class="o">.</span><span class="n">hotkeys</span><span class="p">[</span><span class="n">uid</span><span class="p">]</span>  <span class="c1"># type: ignore</span>

        <span class="n">metadata</span> <span class="o">=</span> <span class="n">get_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">,</span> <span class="n">hotkey</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>
        <span class="n">commitment</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;info&quot;</span><span class="p">][</span><span class="s2">&quot;fields&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># type: ignore</span>
        <span class="n">hex_data</span> <span class="o">=</span> <span class="n">commitment</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">commitment</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">2</span><span class="p">:]</span>  <span class="c1"># type: ignore</span>

        <span class="k">return</span> <span class="nb">bytes</span><span class="o">.</span><span class="n">fromhex</span><span class="p">(</span><span class="n">hex_data</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span></div>


    <span class="c1">##################</span>
    <span class="c1"># Standard Calls #</span>
    <span class="c1">##################</span>

    <span class="c1"># Queries subtensor named storage with params and block.</span>
<div class="viewcode-block" id="Subtensor.query_subtensor">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.query_subtensor">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">query_subtensor</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ScaleType&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Queries named storage from the Subtensor module on the Bittensor blockchain. This function is used to retrieve</span>
<span class="sd">        specific data or parameters from the blockchain, such as stake, rank, or other neuron-specific attributes.</span>

<span class="sd">        Args:</span>
<span class="sd">            name (str): The name of the storage function to query.</span>
<span class="sd">            block (Optional[int]): The blockchain block number at which to perform the query.</span>
<span class="sd">            params (Optional[List[object]], optional): A list of parameters to pass to the query function.</span>

<span class="sd">        Returns:</span>
<span class="sd">            query_response (ScaleType): An object containing the requested data.</span>

<span class="sd">        This query function is essential for accessing detailed information about the network and its neurons,</span>
<span class="sd">        providing valuable insights into the state and dynamics of the Bittensor ecosystem.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">_logger</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="s2">&quot;ScaleType&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
                <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
                <span class="n">storage_function</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
                <span class="n">block_hash</span><span class="o">=</span><span class="p">(</span>
                    <span class="kc">None</span> <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
                <span class="p">),</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span></div>


    <span class="c1"># Queries subtensor map storage with params and block.</span>
<div class="viewcode-block" id="Subtensor.query_map_subtensor">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.query_map_subtensor">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">query_map_subtensor</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;QueryMapResult&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Queries map storage from the Subtensor module on the Bittensor blockchain. This function is designed to</span>
<span class="sd">        retrieve a map-like data structure, which can include various neuron-specific details or network-wide</span>
<span class="sd">        attributes.</span>

<span class="sd">        Args:</span>
<span class="sd">            name (str): The name of the map storage function to query.</span>
<span class="sd">            block (Optional[int]): The blockchain block number at which to perform the query.</span>
<span class="sd">            params (Optional[List[object]], optional): A list of parameters to pass to the query function.</span>

<span class="sd">        Returns:</span>
<span class="sd">            QueryMapResult: An object containing the map-like data structure, or ``None`` if not found.</span>

<span class="sd">        This function is particularly useful for analyzing and understanding complex network structures and</span>
<span class="sd">        relationships within the Bittensor ecosystem, such as inter-neuronal connections and stake distributions.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">_logger</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query_map</span><span class="p">(</span>
                <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
                <span class="n">storage_function</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
                <span class="n">block_hash</span><span class="o">=</span><span class="p">(</span>
                    <span class="kc">None</span> <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
                <span class="p">),</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span></div>


<div class="viewcode-block" id="Subtensor.query_constant">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.query_constant">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">query_constant</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">module_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">constant_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;ScaleType&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a constant from the specified module on the Bittensor blockchain. This function is used to</span>
<span class="sd">        access fixed parameters or values defined within the blockchain&#39;s modules, which are essential for</span>
<span class="sd">        understanding the network&#39;s configuration and rules.</span>

<span class="sd">        Args:</span>
<span class="sd">            module_name (str): The name of the module containing the constant.</span>
<span class="sd">            constant_name (str): The name of the constant to retrieve.</span>
<span class="sd">            block (Optional[int]): The blockchain block number at which to query the constant.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[ScaleType]: The value of the constant if found, ``None`` otherwise.</span>

<span class="sd">        Constants queried through this function can include critical network parameters such as inflation rates,</span>
<span class="sd">        consensus rules, or validation thresholds, providing a deeper understanding of the Bittensor network&#39;s</span>
<span class="sd">        operational parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">_logger</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_constant</span><span class="p">(</span>
                <span class="n">module_name</span><span class="o">=</span><span class="n">module_name</span><span class="p">,</span>
                <span class="n">constant_name</span><span class="o">=</span><span class="n">constant_name</span><span class="p">,</span>
                <span class="n">block_hash</span><span class="o">=</span><span class="p">(</span>
                    <span class="kc">None</span> <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
                <span class="p">),</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span></div>


    <span class="c1"># Queries any module storage with params and block.</span>
<div class="viewcode-block" id="Subtensor.query_module">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.query_module">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">query_module</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">module</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ScaleType&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Queries any module storage on the Bittensor blockchain with the specified parameters and block number.</span>
<span class="sd">        This function is a generic query interface that allows for flexible and diverse data retrieval from</span>
<span class="sd">        various blockchain modules.</span>

<span class="sd">        Args:</span>
<span class="sd">            module (str): The name of the module from which to query data.</span>
<span class="sd">            name (str): The name of the storage function within the module.</span>
<span class="sd">            block (Optional[int]): The blockchain block number at which to perform the query.</span>
<span class="sd">            params (Optional[List[object]], optional): A list of parameters to pass to the query function.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[ScaleType]: An object containing the requested data if found, ``None`` otherwise.</span>

<span class="sd">        This versatile query function is key to accessing a wide range of data and insights from different</span>
<span class="sd">        parts of the Bittensor blockchain, enhancing the understanding and analysis of the network&#39;s state and dynamics.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">_logger</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="s2">&quot;ScaleType&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
                <span class="n">module</span><span class="o">=</span><span class="n">module</span><span class="p">,</span>
                <span class="n">storage_function</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
                <span class="n">block_hash</span><span class="o">=</span><span class="p">(</span>
                    <span class="kc">None</span> <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
                <span class="p">),</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span></div>


    <span class="c1"># Queries any module map storage with params and block.</span>
<div class="viewcode-block" id="Subtensor.query_map">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.query_map">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">query_map</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">module</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QueryMapResult</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Queries map storage from any module on the Bittensor blockchain. This function retrieves data structures</span>
<span class="sd">        that represent key-value mappings, essential for accessing complex and structured data within the blockchain</span>
<span class="sd">        modules.</span>

<span class="sd">        Args:</span>
<span class="sd">            module (str): The name of the module from which to query the map storage.</span>
<span class="sd">            name (str): The specific storage function within the module to query.</span>
<span class="sd">            block (Optional[int]): The blockchain block number at which to perform the query.</span>
<span class="sd">            params (Optional[List[object]], optional): Parameters to be passed to the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            result (QueryMapResult): A data structure representing the map storage if found, ``None`` otherwise.</span>

<span class="sd">        This function is particularly useful for retrieving detailed and structured data from various blockchain</span>
<span class="sd">        modules, offering insights into the network&#39;s state and the relationships between its different components.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">_logger</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="s2">&quot;QueryMapResult&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query_map</span><span class="p">(</span>
                <span class="n">module</span><span class="o">=</span><span class="n">module</span><span class="p">,</span>
                <span class="n">storage_function</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
                <span class="n">block_hash</span><span class="o">=</span><span class="p">(</span>
                    <span class="kc">None</span> <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
                <span class="p">),</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span></div>


<div class="viewcode-block" id="Subtensor.state_call">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.state_call">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">state_call</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes a state call to the Bittensor blockchain, allowing for direct queries of the blockchain&#39;s state.</span>
<span class="sd">        This function is typically used for advanced queries that require specific method calls and data inputs.</span>

<span class="sd">        Args:</span>
<span class="sd">            method (str): The method name for the state call.</span>
<span class="sd">            data (str): The data to be passed to the method.</span>
<span class="sd">            block (Optional[int]): The blockchain block number at which to perform the state call.</span>

<span class="sd">        Returns:</span>
<span class="sd">            result (Dict[Any, Any]): The result of the rpc call.</span>

<span class="sd">        The state call function provides a more direct and flexible way of querying blockchain data,</span>
<span class="sd">        useful for specific use cases where standard queries are insufficient.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">_logger</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
            <span class="n">block_hash</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">rpc_request</span><span class="p">(</span>
                <span class="n">method</span><span class="o">=</span><span class="s2">&quot;state_call&quot;</span><span class="p">,</span>
                <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">method</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">block_hash</span><span class="p">]</span> <span class="k">if</span> <span class="n">block_hash</span> <span class="k">else</span> <span class="p">[</span><span class="n">method</span><span class="p">,</span> <span class="n">data</span><span class="p">],</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span></div>


<div class="viewcode-block" id="Subtensor.query_runtime_api">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.query_runtime_api">[docs]</a>
    <span class="k">def</span> <span class="nf">query_runtime_api</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">runtime_api</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]],</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Queries the runtime API of the Bittensor blockchain, providing a way to interact with the underlying</span>
<span class="sd">        runtime and retrieve data encoded in Scale Bytes format. This function is essential for advanced users</span>
<span class="sd">        who need to interact with specific runtime methods and decode complex data types.</span>

<span class="sd">        Args:</span>
<span class="sd">            runtime_api (str): The name of the runtime API to query.</span>
<span class="sd">            method (str): The specific method within the runtime API to call.</span>
<span class="sd">            params (Optional[List[ParamWithTypes]], optional): The parameters to pass to the method call.</span>
<span class="sd">            block (Optional[int]): The blockchain block number at which to perform the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[bytes]: The Scale Bytes encoded result from the runtime API call, or ``None`` if the call fails.</span>

<span class="sd">        This function enables access to the deeper layers of the Bittensor blockchain, allowing for detailed</span>
<span class="sd">        and specific interactions with the network&#39;s runtime environment.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call_definition</span> <span class="o">=</span> <span class="n">bittensor</span><span class="o">.</span><span class="n">__type_registry__</span><span class="p">[</span><span class="s2">&quot;runtime_api&quot;</span><span class="p">][</span><span class="n">runtime_api</span><span class="p">][</span>  <span class="c1"># type: ignore</span>
            <span class="s2">&quot;methods&quot;</span>  <span class="c1"># type: ignore</span>
        <span class="p">][</span><span class="n">method</span><span class="p">]</span>  <span class="c1"># type: ignore</span>

        <span class="n">json_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_call</span><span class="p">(</span>
            <span class="n">method</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">runtime_api</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;0x&quot;</span>
                <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encode_params</span><span class="p">(</span><span class="n">call_definition</span><span class="o">=</span><span class="n">call_definition</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
            <span class="p">),</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">json_result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">return_type</span> <span class="o">=</span> <span class="n">call_definition</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span>

        <span class="n">as_scale_bytes</span> <span class="o">=</span> <span class="n">scalecodec</span><span class="o">.</span><span class="n">ScaleBytes</span><span class="p">(</span><span class="n">json_result</span><span class="p">[</span><span class="s2">&quot;result&quot;</span><span class="p">])</span>  <span class="c1"># type: ignore</span>

        <span class="n">rpc_runtime_config</span> <span class="o">=</span> <span class="n">RuntimeConfiguration</span><span class="p">()</span>
        <span class="n">rpc_runtime_config</span><span class="o">.</span><span class="n">update_type_registry</span><span class="p">(</span><span class="n">load_type_registry_preset</span><span class="p">(</span><span class="s2">&quot;legacy&quot;</span><span class="p">))</span>
        <span class="n">rpc_runtime_config</span><span class="o">.</span><span class="n">update_type_registry</span><span class="p">(</span><span class="n">custom_rpc_type_registry</span><span class="p">)</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="n">rpc_runtime_config</span><span class="o">.</span><span class="n">create_scale_object</span><span class="p">(</span><span class="n">return_type</span><span class="p">,</span> <span class="n">as_scale_bytes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">to_hex</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;0x0400&quot;</span><span class="p">:</span>  <span class="c1"># RPC returned None result</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span></div>


<div class="viewcode-block" id="Subtensor._encode_params">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor._encode_params">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">_encode_params</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">call_definition</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;ParamWithTypes&quot;</span><span class="p">],</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a hex encoded string of the params using their types.&quot;&quot;&quot;</span>
        <span class="n">param_data</span> <span class="o">=</span> <span class="n">scalecodec</span><span class="o">.</span><span class="n">ScaleBytes</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">call_definition</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">]):</span>  <span class="c1"># type: ignore</span>
            <span class="n">scale_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">create_scale_object</span><span class="p">(</span><span class="n">param</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
                <span class="n">param_data</span> <span class="o">+=</span> <span class="n">scale_obj</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">param</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Missing param </span><span class="si">{</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> in params dict.&quot;</span><span class="p">)</span>

                <span class="n">param_data</span> <span class="o">+=</span> <span class="n">scale_obj</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">param</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]])</span>

        <span class="k">return</span> <span class="n">param_data</span><span class="o">.</span><span class="n">to_hex</span><span class="p">()</span></div>


    <span class="c1">##########################</span>
    <span class="c1"># Hyper parameter calls. #</span>
    <span class="c1">##########################</span>

<div class="viewcode-block" id="Subtensor._get_hyperparameter">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor._get_hyperparameter">[docs]</a>
    <span class="k">def</span> <span class="nf">_get_hyperparameter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">param_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a specified hyperparameter for a specific subnet.</span>

<span class="sd">        Args:</span>
<span class="sd">            param_name (str): The name of the hyperparameter to retrieve.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[Union[int, float]]: The value of the specified hyperparameter if the subnet exists, ``None``</span>
<span class="sd">                otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">subnet_exists</span><span class="p">(</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_subtensor</span><span class="p">(</span><span class="n">param_name</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="p">[</span><span class="n">netuid</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">value</span></div>


<div class="viewcode-block" id="Subtensor.rho">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.rho">[docs]</a>
    <span class="k">def</span> <span class="nf">rho</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the &#39;Rho&#39; hyperparameter for a specified subnet within the Bittensor network. &#39;Rho&#39; represents the</span>
<span class="sd">        global inflation rate, which directly influences the network&#39;s token emission rate and economic model.</span>

<span class="sd">        Note:</span>
<span class="sd">            This is currently fixed such that the Bittensor blockchain emmits 7200 Tao per day.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int]): The blockchain block number at which to query the parameter.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The value of the &#39;Rho&#39; hyperparameter if the subnet exists, ``None`` otherwise.</span>

<span class="sd">        Mathematical Context:</span>
<span class="sd">            Rho (p) is calculated based on the network&#39;s target inflation and actual neuron staking.</span>
<span class="sd">            It adjusts the emission rate of the TAO token to balance the network&#39;s economy and dynamics.</span>
<span class="sd">            The formula for Rho is defined as: p = (Staking_Target / Staking_Actual) * Inflation_Target.</span>
<span class="sd">            Here, Staking_Target and Staking_Actual represent the desired and actual total stakes in the network,</span>
<span class="sd">            while Inflation_Target is the predefined inflation rate goal.</span>

<span class="sd">        &#39;Rho&#39; is essential for understanding the network&#39;s economic dynamics, affecting the reward distribution</span>
<span class="sd">        and incentive structures across the network&#39;s neurons.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hyperparameter</span><span class="p">(</span><span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;Rho&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.kappa">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.kappa">[docs]</a>
    <span class="k">def</span> <span class="nf">kappa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the &#39;Kappa&#39; hyperparameter for a specified subnet. &#39;Kappa&#39; is a critical parameter in</span>
<span class="sd">        the Bittensor network that controls the distribution of stake weights among neurons, impacting their</span>
<span class="sd">        rankings and incentive allocations.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[float]: The value of the &#39;Kappa&#39; hyperparameter if the subnet exists, None otherwise.</span>

<span class="sd">        Mathematical Context:</span>
<span class="sd">            Kappa (κ) is used in the calculation of neuron ranks, which determine their share of network incentives.</span>
<span class="sd">            It is derived from the softmax function applied to the inter-neuronal weights set by each neuron.</span>
<span class="sd">            The formula for Kappa is: κ_i = exp(w_i) / Σ(exp(w_j)), where w_i represents the weight set by neuron i,</span>
<span class="sd">            and the denominator is the sum of exponential weights set by all neurons.</span>
<span class="sd">            This mechanism ensures a normalized and probabilistic distribution of ranks based on relative weights.</span>

<span class="sd">        Understanding &#39;Kappa&#39; is crucial for analyzing stake dynamics and the consensus mechanism within the network,</span>
<span class="sd">        as it plays a significant role in neuron ranking and incentive allocation processes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hyperparameter</span><span class="p">(</span><span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;Kappa&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">U16_NORMALIZED_FLOAT</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">))</span></div>


<div class="viewcode-block" id="Subtensor.difficulty">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.difficulty">[docs]</a>
    <span class="k">def</span> <span class="nf">difficulty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the &#39;Difficulty&#39; hyperparameter for a specified subnet in the Bittensor network.</span>
<span class="sd">        This parameter is instrumental in determining the computational challenge required for neurons</span>
<span class="sd">        to participate in consensus and validation processes.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The value of the &#39;Difficulty&#39; hyperparameter if the subnet exists, ``None`` otherwise.</span>

<span class="sd">        The &#39;Difficulty&#39; parameter directly impacts the network&#39;s security and integrity by setting the</span>
<span class="sd">        computational effort required for validating transactions and participating in the network&#39;s consensus</span>
<span class="sd">        mechanism.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hyperparameter</span><span class="p">(</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;Difficulty&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.recycle">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.recycle">[docs]</a>
    <span class="k">def</span> <span class="nf">recycle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;Balance&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the &#39;Burn&#39; hyperparameter for a specified subnet. The &#39;Burn&#39; parameter represents the</span>
<span class="sd">        amount of Tao that is effectively recycled within the Bittensor network.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[Balance]: The value of the &#39;Burn&#39; hyperparameter if the subnet exists, None otherwise.</span>

<span class="sd">        Understanding the &#39;Burn&#39; rate is essential for analyzing the network registration usage, particularly</span>
<span class="sd">        how it is correlated with user activity and the overall cost of participation in a given subnet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hyperparameter</span><span class="p">(</span><span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;Burn&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">))</span></div>


    <span class="c1"># Returns network ImmunityPeriod hyper parameter.</span>
<div class="viewcode-block" id="Subtensor.immunity_period">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.immunity_period">[docs]</a>
    <span class="k">def</span> <span class="nf">immunity_period</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the &#39;ImmunityPeriod&#39; hyperparameter for a specific subnet. This parameter defines the</span>
<span class="sd">        duration during which new neurons are protected from certain network penalties or restrictions.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The value of the &#39;ImmunityPeriod&#39; hyperparameter if the subnet exists, ``None`` otherwise.</span>

<span class="sd">        The &#39;ImmunityPeriod&#39; is a critical aspect of the network&#39;s governance system, ensuring that new</span>
<span class="sd">        participants have a grace period to establish themselves and contribute to the network without facing</span>
<span class="sd">        immediate punitive actions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hyperparameter</span><span class="p">(</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;ImmunityPeriod&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.validator_batch_size">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.validator_batch_size">[docs]</a>
    <span class="k">def</span> <span class="nf">validator_batch_size</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns network ValidatorBatchSize hyper parameter.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            block (Optional[int]): The block number to retrieve the parameter from. If None, the latest block</span>
<span class="sd">                is used. Default is ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The value of the ValidatorBatchSize hyperparameter, or None if the subnetwork does not exist</span>
<span class="sd">                or the parameter is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hyperparameter</span><span class="p">(</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;ValidatorBatchSize&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.validator_prune_len">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.validator_prune_len">[docs]</a>
    <span class="k">def</span> <span class="nf">validator_prune_len</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns network ValidatorPruneLen hyper parameter.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            block (Optional[int]): The block number to retrieve the parameter from. If None, the latest block</span>
<span class="sd">            is used. Default is ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The value of the ValidatorPruneLen hyperparameter, or None if the subnetwork does not exist</span>
<span class="sd">            or the parameter is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hyperparameter</span><span class="p">(</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;ValidatorPruneLen&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.validator_logits_divergence">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.validator_logits_divergence">[docs]</a>
    <span class="k">def</span> <span class="nf">validator_logits_divergence</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns network ValidatorLogitsDivergence hyper parameter.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            block (Optional[int]): The block number to retrieve the parameter from. If None, the latest block</span>
<span class="sd">            is used. Default is ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[float]: The value of the ValidatorLogitsDivergence hyperparameter, or None if the subnetwork does</span>
<span class="sd">            not exist or the parameter is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hyperparameter</span><span class="p">(</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;ValidatorLogitsDivergence&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">U16_NORMALIZED_FLOAT</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">))</span></div>


<div class="viewcode-block" id="Subtensor.validator_sequence_length">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.validator_sequence_length">[docs]</a>
    <span class="k">def</span> <span class="nf">validator_sequence_length</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns network ValidatorSequenceLength hyperparameter.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            block (Optional[int], optional): The block number to retrieve the parameter from. If ``None``, the latest</span>
<span class="sd">                block is used. Default is ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The value of the ValidatorSequenceLength hyperparameter, or ``None`` if the subnetwork does</span>
<span class="sd">                not exist or the parameter is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hyperparameter</span><span class="p">(</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;ValidatorSequenceLength&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.validator_epochs_per_reset">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.validator_epochs_per_reset">[docs]</a>
    <span class="k">def</span> <span class="nf">validator_epochs_per_reset</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns network ValidatorEpochsPerReset hyperparameter.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            block (Optional[int], optional): The block number to retrieve the parameter from. If ``None``, the latest</span>
<span class="sd">                block is used. Default is ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The value of the ValidatorEpochsPerReset hyperparameter, or ``None`` if the subnetwork does</span>
<span class="sd">                not exist or the parameter is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hyperparameter</span><span class="p">(</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;ValidatorEpochsPerReset&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.validator_epoch_length">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.validator_epoch_length">[docs]</a>
    <span class="k">def</span> <span class="nf">validator_epoch_length</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns network ValidatorEpochLen hyperparameter.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            block (Optional[int], optional): The block number to retrieve the parameter from. If ``None``, the latest</span>
<span class="sd">                block is used. Default is ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The value of the ValidatorEpochLen hyperparameter, or ``None`` if the subnetwork does not</span>
<span class="sd">                exist or the parameter is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hyperparameter</span><span class="p">(</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;ValidatorEpochLen&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.validator_exclude_quantile">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.validator_exclude_quantile">[docs]</a>
    <span class="k">def</span> <span class="nf">validator_exclude_quantile</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns network ValidatorExcludeQuantile hyperparameter.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            block (Optional[int], optional): The block number to retrieve the parameter from. If ``None``, the latest block is used. Default is ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[float]: The value of the ValidatorExcludeQuantile hyperparameter, or ``None`` if the subnetwork does not exist or the parameter is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hyperparameter</span><span class="p">(</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;ValidatorExcludeQuantile&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">U16_NORMALIZED_FLOAT</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">))</span></div>


<div class="viewcode-block" id="Subtensor.max_allowed_validators">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.max_allowed_validators">[docs]</a>
    <span class="k">def</span> <span class="nf">max_allowed_validators</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns network ValidatorExcludeQuantile hyperparameter.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            block (Optional[int], optional): The block number to retrieve the parameter from. If ``None``, the latest</span>
<span class="sd">                block is used. Default is ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[float]: The value of the ValidatorExcludeQuantile hyperparameter, or ``None`` if the subnetwork</span>
<span class="sd">                does not exist or the parameter is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hyperparameter</span><span class="p">(</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;MaxAllowedValidators&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.min_allowed_weights">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.min_allowed_weights">[docs]</a>
    <span class="k">def</span> <span class="nf">min_allowed_weights</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns network MinAllowedWeights hyperparameter.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            block (Optional[int], optional): The block number to retrieve the parameter from. If ``None``, the latest</span>
<span class="sd">                block is used. Default is ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The value of the MinAllowedWeights hyperparameter, or ``None`` if the subnetwork does not</span>
<span class="sd">                exist or the parameter is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hyperparameter</span><span class="p">(</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;MinAllowedWeights&quot;</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.max_weight_limit">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.max_weight_limit">[docs]</a>
    <span class="k">def</span> <span class="nf">max_weight_limit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns network MaxWeightsLimit hyperparameter.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            block (Optional[int], optional): The block number to retrieve the parameter from. If ``None``, the latest</span>
<span class="sd">                block is used. Default is ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[float]: The value of the MaxWeightsLimit hyperparameter, or ``None`` if the subnetwork does not</span>
<span class="sd">                exist or the parameter is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hyperparameter</span><span class="p">(</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;MaxWeightsLimit&quot;</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">U16_NORMALIZED_FLOAT</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">))</span></div>


<div class="viewcode-block" id="Subtensor.adjustment_alpha">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.adjustment_alpha">[docs]</a>
    <span class="k">def</span> <span class="nf">adjustment_alpha</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns network AdjustmentAlpha hyperparameter.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            block (Optional[int], optional): The block number to retrieve the parameter from. If ``None``, the latest</span>
<span class="sd">                block is used. Default is ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[float]: The value of the AdjustmentAlpha hyperparameter, or ``None`` if the subnetwork does not</span>
<span class="sd">                exist or the parameter is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hyperparameter</span><span class="p">(</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;AdjustmentAlpha&quot;</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">U64_NORMALIZED_FLOAT</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">))</span></div>


<div class="viewcode-block" id="Subtensor.bonds_moving_avg">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.bonds_moving_avg">[docs]</a>
    <span class="k">def</span> <span class="nf">bonds_moving_avg</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns network BondsMovingAverage hyperparameter.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            block (Optional[int], optional): The block number to retrieve the parameter from. If ``None``, the latest</span>
<span class="sd">                block is used. Default is ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[float]: The value of the BondsMovingAverage hyperparameter, or ``None`` if the subnetwork does not</span>
<span class="sd">                exist or the parameter is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hyperparameter</span><span class="p">(</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;BondsMovingAverage&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">U64_NORMALIZED_FLOAT</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">))</span></div>


<div class="viewcode-block" id="Subtensor.scaling_law_power">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.scaling_law_power">[docs]</a>
    <span class="k">def</span> <span class="nf">scaling_law_power</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns network ScalingLawPower hyper parameter&quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hyperparameter</span><span class="p">(</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;ScalingLawPower&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">)</span> <span class="o">/</span> <span class="mf">100.0</span></div>


<div class="viewcode-block" id="Subtensor.synergy_scaling_law_power">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.synergy_scaling_law_power">[docs]</a>
    <span class="k">def</span> <span class="nf">synergy_scaling_law_power</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns network ScalingLawPower hyperparameter.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            block (Optional[int], optional): The block number to retrieve the parameter from. If ``None``, the latest</span>
<span class="sd">                block is used. Default is ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[float]: The value of the ScalingLawPower hyperparameter, or ``None`` if the subnetwork does not</span>
<span class="sd">                exist or the parameter is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hyperparameter</span><span class="p">(</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;SynergyScalingLawPower&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">)</span> <span class="o">/</span> <span class="mf">100.0</span></div>


<div class="viewcode-block" id="Subtensor.subnetwork_n">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.subnetwork_n">[docs]</a>
    <span class="k">def</span> <span class="nf">subnetwork_n</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns network SubnetworkN hyperparameter.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            block (Optional[int], optional): The block number to retrieve the parameter from. If ``None``, the latest</span>
<span class="sd">                block is used. Default is ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The value of the SubnetworkN hyperparameter, or ``None`` if the subnetwork does not</span>
<span class="sd">                exist or the parameter is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hyperparameter</span><span class="p">(</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;SubnetworkN&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.max_n">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.max_n">[docs]</a>
    <span class="k">def</span> <span class="nf">max_n</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns network MaxAllowedUids hyperparameter.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            block (Optional[int], optional): The block number to retrieve the parameter from. If ``None``, the latest</span>
<span class="sd">                block is used. Default is ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The value of the MaxAllowedUids hyperparameter, or ``None`` if the subnetwork does not</span>
<span class="sd">                exist or the parameter is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hyperparameter</span><span class="p">(</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;MaxAllowedUids&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.blocks_since_epoch">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.blocks_since_epoch">[docs]</a>
    <span class="k">def</span> <span class="nf">blocks_since_epoch</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns network BlocksSinceEpoch hyperparameter.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            block (Optional[int], optional): The block number to retrieve the parameter from. If ``None``, the latest</span>
<span class="sd">                block is used. Default is ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The value of the BlocksSinceEpoch hyperparameter, or ``None`` if the subnetwork does not</span>
<span class="sd">                exist or the parameter is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hyperparameter</span><span class="p">(</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;BlocksSinceEpoch&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.blocks_since_last_update">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.blocks_since_last_update">[docs]</a>
    <span class="k">def</span> <span class="nf">blocks_since_last_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">uid</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of blocks since the last update for a specific UID in the subnetwork.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            uid (int): The unique identifier of the neuron.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The number of blocks since the last update, or ``None`` if the subnetwork or UID does not</span>
<span class="sd">                exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hyperparameter</span><span class="p">(</span><span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;LastUpdate&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_current_block</span><span class="p">()</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">[</span><span class="n">uid</span><span class="p">])</span></div>


<div class="viewcode-block" id="Subtensor.weights_rate_limit">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.weights_rate_limit">[docs]</a>
    <span class="k">def</span> <span class="nf">weights_rate_limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns network WeightsSetRateLimit hyperparameter.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The value of the WeightsSetRateLimit hyperparameter, or ``None`` if the subnetwork does not</span>
<span class="sd">                exist or the parameter is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hyperparameter</span><span class="p">(</span><span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;WeightsSetRateLimit&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.tempo">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.tempo">[docs]</a>
    <span class="k">def</span> <span class="nf">tempo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns network Tempo hyperparameter.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            block (Optional[int], optional): The block number to retrieve the parameter from. If ``None``, the latest</span>
<span class="sd">                block is used. Default is ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The value of the Tempo hyperparameter, or ``None`` if the subnetwork does not</span>
<span class="sd">                exist or the parameter is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hyperparameter</span><span class="p">(</span><span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;Tempo&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">)</span></div>


    <span class="c1">#####################</span>
    <span class="c1"># Account functions #</span>
    <span class="c1">#####################</span>

<div class="viewcode-block" id="Subtensor.get_total_stake_for_hotkey">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_total_stake_for_hotkey">[docs]</a>
    <span class="k">def</span> <span class="nf">get_total_stake_for_hotkey</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">ss58_address</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;Balance&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the total stake held on a hotkey including delegative.</span>

<span class="sd">        Args:</span>
<span class="sd">            ss58_address (str): The SS58 address of the hotkey.</span>
<span class="sd">            block (Optional[int], optional): The block number to retrieve the stake from. If ``None``, the latest</span>
<span class="sd">                block is used. Default is ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[Balance]: The total stake held on the hotkey, or ``None`` if the hotkey does not</span>
<span class="sd">                exist or the stake is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_subtensor</span><span class="p">(</span><span class="s2">&quot;TotalHotkeyStake&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="p">[</span><span class="n">ss58_address</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="kc">None</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">_result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="n">_result</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_total_stake_for_coldkey">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_total_stake_for_coldkey">[docs]</a>
    <span class="k">def</span> <span class="nf">get_total_stake_for_coldkey</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">ss58_address</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;Balance&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the total stake held on a coldkey.</span>

<span class="sd">        Args:</span>
<span class="sd">            ss58_address (str): The SS58 address of the coldkey.</span>
<span class="sd">            block (Optional[int], optional): The block number to retrieve the stake from. If ``None``, the latest</span>
<span class="sd">                block is used. Default is ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[Balance]: The total stake held on the coldkey, or ``None`` if the coldkey does not</span>
<span class="sd">                exist or the stake is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_subtensor</span><span class="p">(</span><span class="s2">&quot;TotalColdkeyStake&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="p">[</span><span class="n">ss58_address</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="kc">None</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">_result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="n">_result</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_stake_for_coldkey_and_hotkey">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_stake_for_coldkey_and_hotkey">[docs]</a>
    <span class="k">def</span> <span class="nf">get_stake_for_coldkey_and_hotkey</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">coldkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;Balance&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the stake under a coldkey - hotkey pairing.</span>

<span class="sd">        Args:</span>
<span class="sd">            hotkey_ss58 (str): The SS58 address of the hotkey.</span>
<span class="sd">            coldkey_ss58 (str): The SS58 address of the coldkey.</span>
<span class="sd">            block (Optional[int], optional): The block number to retrieve the stake from. If ``None``, the latest</span>
<span class="sd">                block is used. Default is ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[Balance]: The stake under the coldkey - hotkey pairing, or ``None`` if the pairing does not</span>
<span class="sd">                exist or the stake is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_subtensor</span><span class="p">(</span><span class="s2">&quot;Stake&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="p">[</span><span class="n">hotkey_ss58</span><span class="p">,</span> <span class="n">coldkey_ss58</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="kc">None</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">_result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="n">_result</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_stake">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_stake">[docs]</a>
    <span class="k">def</span> <span class="nf">get_stake</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s2">&quot;Balance&quot;</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of stake tuples (coldkey, balance) for each delegating coldkey including the owner.</span>

<span class="sd">        Args:</span>
<span class="sd">            hotkey_ss58 (str): The SS58 address of the hotkey.</span>
<span class="sd">            block (Optional[int], optional): The block number to retrieve the stakes from. If ``None``, the latest</span>
<span class="sd">                block is used. Default is ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List[Tuple[str, Balance]]: A list of tuples, each containing a coldkey SS58 address and the corresponding</span>
<span class="sd">                balance staked by that coldkey.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_map_subtensor</span><span class="p">(</span><span class="s2">&quot;Stake&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="p">[</span><span class="n">hotkey_ss58</span><span class="p">])</span>
        <span class="p">]</span></div>


<div class="viewcode-block" id="Subtensor.does_hotkey_exist">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.does_hotkey_exist">[docs]</a>
    <span class="k">def</span> <span class="nf">does_hotkey_exist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns true if the hotkey is known by the chain and there are accounts.</span>

<span class="sd">        Args:</span>
<span class="sd">            hotkey_ss58 (str): The SS58 address of the hotkey.</span>
<span class="sd">            block (Optional[int], optional): The block number to check the hotkey against. If ``None``, the latest</span>
<span class="sd">                block is used. Default is ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the hotkey is known by the chain and there are accounts, ``False`` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_subtensor</span><span class="p">(</span><span class="s2">&quot;Owner&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="p">[</span><span class="n">hotkey_ss58</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="kc">False</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">_result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="n">_result</span><span class="o">.</span><span class="n">value</span> <span class="o">!=</span> <span class="s2">&quot;5C4hrfjw9DjXZTzV3MwzrrAr9P1MJhSrvWGWqi1eSuyUpnhM&quot;</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_hotkey_owner">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_hotkey_owner">[docs]</a>
    <span class="k">def</span> <span class="nf">get_hotkey_owner</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the coldkey owner of the passed hotkey.</span>

<span class="sd">        Args:</span>
<span class="sd">            hotkey_ss58 (str): The SS58 address of the hotkey.</span>
<span class="sd">            block (Optional[int], optional): The block number to check the hotkey owner against. If ``None``, the latest</span>
<span class="sd">                block is used. Default is ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[str]: The SS58 address of the coldkey owner, or ``None`` if the hotkey does not exist or the owner</span>
<span class="sd">                is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_subtensor</span><span class="p">(</span><span class="s2">&quot;Owner&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="p">[</span><span class="n">hotkey_ss58</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="kc">None</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">_result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">does_hotkey_exist</span><span class="p">(</span><span class="n">hotkey_ss58</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>
            <span class="k">else</span> <span class="n">_result</span><span class="o">.</span><span class="n">value</span>
        <span class="p">)</span></div>


    <span class="c1"># TODO: check if someone still use this method. bittensor not.</span>
<div class="viewcode-block" id="Subtensor.get_axon_info">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_axon_info">[docs]</a>
    <span class="k">def</span> <span class="nf">get_axon_info</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AxonInfo</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the axon information for this hotkey account.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            hotkey_ss58 (str): The SS58 address of the hotkey.</span>
<span class="sd">            block (Optional[int], optional): The block number to retrieve the axon information from. If ``None``, the</span>
<span class="sd">                latest block is used. Default is ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[AxonInfo]: An AxonInfo object containing the axon information, or ``None`` if the axon information</span>
<span class="sd">                is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_subtensor</span><span class="p">(</span><span class="s2">&quot;Axons&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="p">[</span><span class="n">netuid</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">AxonInfo</span><span class="p">(</span>
                <span class="n">ip</span><span class="o">=</span><span class="n">networking</span><span class="o">.</span><span class="n">int_to_ip</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="s2">&quot;ip&quot;</span><span class="p">]),</span>
                <span class="n">ip_type</span><span class="o">=</span><span class="n">result</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="s2">&quot;ip_type&quot;</span><span class="p">],</span>
                <span class="n">port</span><span class="o">=</span><span class="n">result</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="s2">&quot;port&quot;</span><span class="p">],</span>
                <span class="n">protocol</span><span class="o">=</span><span class="n">result</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="s2">&quot;protocol&quot;</span><span class="p">],</span>
                <span class="n">version</span><span class="o">=</span><span class="n">result</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="s2">&quot;version&quot;</span><span class="p">],</span>
                <span class="n">placeholder1</span><span class="o">=</span><span class="n">result</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="s2">&quot;placeholder1&quot;</span><span class="p">],</span>
                <span class="n">placeholder2</span><span class="o">=</span><span class="n">result</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="s2">&quot;placeholder2&quot;</span><span class="p">],</span>
                <span class="n">hotkey</span><span class="o">=</span><span class="n">hotkey_ss58</span><span class="p">,</span>
                <span class="n">coldkey</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span></div>


    <span class="c1"># It is used in subtensor in neuron_info, and serving</span>
<div class="viewcode-block" id="Subtensor.get_prometheus_info">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_prometheus_info">[docs]</a>
    <span class="k">def</span> <span class="nf">get_prometheus_info</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">PrometheusInfo</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the prometheus information for this hotkey account.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            hotkey_ss58 (str): The SS58 address of the hotkey.</span>
<span class="sd">            block (Optional[int], optional): The block number to retrieve the prometheus information from. If ``None``,</span>
<span class="sd">                the latest block is used. Default is ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[PrometheusInfo]: A PrometheusInfo object containing the prometheus information, or ``None`` if the</span>
<span class="sd">                prometheus information is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_subtensor</span><span class="p">(</span><span class="s2">&quot;Prometheus&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="p">[</span><span class="n">netuid</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">PrometheusInfo</span><span class="p">(</span>
                <span class="n">ip</span><span class="o">=</span><span class="n">networking</span><span class="o">.</span><span class="n">int_to_ip</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="s2">&quot;ip&quot;</span><span class="p">]),</span>
                <span class="n">ip_type</span><span class="o">=</span><span class="n">result</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="s2">&quot;ip_type&quot;</span><span class="p">],</span>
                <span class="n">port</span><span class="o">=</span><span class="n">result</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="s2">&quot;port&quot;</span><span class="p">],</span>
                <span class="n">version</span><span class="o">=</span><span class="n">result</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="s2">&quot;version&quot;</span><span class="p">],</span>
                <span class="n">block</span><span class="o">=</span><span class="n">result</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="s2">&quot;block&quot;</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span></div>


    <span class="c1">#####################</span>
    <span class="c1"># Global Parameters #</span>
    <span class="c1">#####################</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">block</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns current chain block.</span>
<span class="sd">        Returns:</span>
<span class="sd">            block (int):</span>
<span class="sd">                Current chain block.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_current_block</span><span class="p">()</span>

<div class="viewcode-block" id="Subtensor.total_issuance">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.total_issuance">[docs]</a>
    <span class="k">def</span> <span class="nf">total_issuance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Balance</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the total issuance of the Bittensor network&#39;s native token (Tao) as of a specific</span>
<span class="sd">        blockchain block. This represents the total amount of currency that has been issued or mined on the network.</span>

<span class="sd">        Args:</span>
<span class="sd">            block (Optional[int], optional): The blockchain block number at which to perform the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Balance: The total issuance of TAO, represented as a Balance object.</span>

<span class="sd">        The total issuance is a key economic indicator in the Bittensor network, reflecting the overall supply</span>
<span class="sd">        of the currency and providing insights into the network&#39;s economic health and inflationary trends.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_subtensor</span><span class="p">(</span><span class="s2">&quot;TotalIssuance&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="kc">None</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">_result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="n">_result</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.total_stake">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.total_stake">[docs]</a>
    <span class="k">def</span> <span class="nf">total_stake</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Balance</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the total amount of TAO staked on the Bittensor network as of a specific blockchain block.</span>
<span class="sd">        This represents the cumulative stake across all neurons in the network, indicating the overall level</span>
<span class="sd">        of participation and investment by the network&#39;s participants.</span>

<span class="sd">        Args:</span>
<span class="sd">            block (Optional[int], optional): The blockchain block number at which to perform the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Balance: The total amount of TAO staked on the network, represented as a Balance object.</span>

<span class="sd">        The total stake is an important metric for understanding the network&#39;s security, governance dynamics,</span>
<span class="sd">        and the level of commitment by its participants. It is also a critical factor in the network&#39;s</span>
<span class="sd">        consensus and incentive mechanisms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_subtensor</span><span class="p">(</span><span class="s2">&quot;TotalStake&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="kc">None</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">_result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="n">_result</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.serving_rate_limit">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.serving_rate_limit">[docs]</a>
    <span class="k">def</span> <span class="nf">serving_rate_limit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the serving rate limit for a specific subnet within the Bittensor network.</span>
<span class="sd">        This rate limit determines how often you can change your node&#39;s IP address on the blockchain. Expressed in</span>
<span class="sd">        number of blocks. Applies to both subnet validator and subnet miner nodes. Used when you move your node to a new</span>
<span class="sd">        machine.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int], optional): The blockchain block number at which to perform the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The serving rate limit of the subnet if it exists, ``None`` otherwise.</span>

<span class="sd">        The serving rate limit is a crucial parameter for maintaining network efficiency and preventing</span>
<span class="sd">        overuse of resources by individual neurons. It helps ensure a balanced distribution of service</span>
<span class="sd">        requests across the network.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hyperparameter</span><span class="p">(</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;ServingRateLimit&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.tx_rate_limit">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.tx_rate_limit">[docs]</a>
    <span class="k">def</span> <span class="nf">tx_rate_limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the transaction rate limit for the Bittensor network as of a specific blockchain block.</span>
<span class="sd">        This rate limit sets the maximum number of transactions that can be processed within a given time frame.</span>

<span class="sd">        Args:</span>
<span class="sd">            block (Optional[int], optional): The blockchain block number at which to perform the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The transaction rate limit of the network, None if not available.</span>

<span class="sd">        The transaction rate limit is an essential parameter for ensuring the stability and scalability</span>
<span class="sd">        of the Bittensor network. It helps in managing network load and preventing congestion, thereby</span>
<span class="sd">        maintaining efficient and timely transaction processing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_subtensor</span><span class="p">(</span><span class="s2">&quot;TxRateLimit&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">_result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>


    <span class="c1">######################</span>
    <span class="c1"># Network Parameters #</span>
    <span class="c1">######################</span>

<div class="viewcode-block" id="Subtensor.subnet_exists">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.subnet_exists">[docs]</a>
    <span class="k">def</span> <span class="nf">subnet_exists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if a subnet with the specified unique identifier (netuid) exists within the Bittensor network.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int], optional): The blockchain block number at which to check the subnet&#39;s existence.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the subnet exists, False otherwise.</span>

<span class="sd">        This function is critical for verifying the presence of specific subnets in the network,</span>
<span class="sd">        enabling a deeper understanding of the network&#39;s structure and composition.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_subtensor</span><span class="p">(</span><span class="s2">&quot;NetworksAdded&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="p">[</span><span class="n">netuid</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">_result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_all_subnet_netuids">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_all_subnet_netuids">[docs]</a>
    <span class="k">def</span> <span class="nf">get_all_subnet_netuids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the list of all subnet unique identifiers (netuids) currently present in the Bittensor network.</span>

<span class="sd">        Args:</span>
<span class="sd">            block (Optional[int], optional): The blockchain block number at which to retrieve the subnet netuids.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List[int]: A list of subnet netuids.</span>

<span class="sd">        This function provides a comprehensive view of the subnets within the Bittensor network,</span>
<span class="sd">        offering insights into its diversity and scale.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_map_subtensor</span><span class="p">(</span><span class="s2">&quot;NetworksAdded&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="p">[]</span>
            <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;records&quot;</span><span class="p">)</span>
            <span class="k">else</span> <span class="p">[</span><span class="n">netuid</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">netuid</span><span class="p">,</span> <span class="n">exists</span> <span class="ow">in</span> <span class="n">result</span> <span class="k">if</span> <span class="n">exists</span><span class="p">]</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_total_subnets">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_total_subnets">[docs]</a>
    <span class="k">def</span> <span class="nf">get_total_subnets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the total number of subnets within the Bittensor network as of a specific blockchain block.</span>

<span class="sd">        Args:</span>
<span class="sd">            block (Optional[int], optional): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: The total number of subnets in the network.</span>

<span class="sd">        Understanding the total number of subnets is essential for assessing the network&#39;s growth and</span>
<span class="sd">        the extent of its decentralized infrastructure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_subtensor</span><span class="p">(</span><span class="s2">&quot;TotalNetworks&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">_result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_subnet_modality">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_subnet_modality">[docs]</a>
    <span class="k">def</span> <span class="nf">get_subnet_modality</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the NetworkModality hyperparameter for a specific subnetwork.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            block (Optional[int], optional): The block number to retrieve the parameter from. If ``None``, the latest block is used. Default is ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The value of the NetworkModality hyperparameter, or ``None`` if the subnetwork does not exist or the parameter is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_subtensor</span><span class="p">(</span><span class="s2">&quot;NetworkModality&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="p">[</span><span class="n">netuid</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">_result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_subnet_connection_requirement">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_subnet_connection_requirement">[docs]</a>
    <span class="k">def</span> <span class="nf">get_subnet_connection_requirement</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid_0</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">netuid_1</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_subtensor</span><span class="p">(</span><span class="s2">&quot;NetworkConnect&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="p">[</span><span class="n">netuid_0</span><span class="p">,</span> <span class="n">netuid_1</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">_result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_emission_value_by_subnet">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_emission_value_by_subnet">[docs]</a>
    <span class="k">def</span> <span class="nf">get_emission_value_by_subnet</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the emission value of a specific subnet within the Bittensor network. The emission value</span>
<span class="sd">        represents the rate at which the subnet emits or distributes the network&#39;s native token (Tao).</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int], optional): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[float]: The emission value of the subnet, None if not available.</span>

<span class="sd">        The emission value is a critical economic parameter, influencing the incentive distribution and</span>
<span class="sd">        reward mechanisms within the subnet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_subtensor</span><span class="p">(</span><span class="s2">&quot;EmissionValues&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="p">[</span><span class="n">netuid</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="kc">None</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">_result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="n">_result</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_subnet_connection_requirements">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_subnet_connection_requirements">[docs]</a>
    <span class="k">def</span> <span class="nf">get_subnet_connection_requirements</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the connection requirements for a specific subnet within the Bittensor network. This</span>
<span class="sd">        function provides details on the criteria that must be met for neurons to connect to the subnet.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The network UID of the subnet to query.</span>
<span class="sd">            block (Optional[int], optional): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dict[str, int]: A dictionary detailing the connection requirements for the subnet.</span>

<span class="sd">        Understanding these requirements is crucial for neurons looking to participate in or interact</span>
<span class="sd">        with specific subnets, ensuring compliance with their connection standards.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_map_subtensor</span><span class="p">(</span><span class="s2">&quot;NetworkConnect&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="p">[</span><span class="n">netuid</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">netuid</span><span class="o">.</span><span class="n">value</span><span class="p">):</span> <span class="n">exists</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">netuid</span><span class="p">,</span> <span class="n">exists</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">records</span><span class="p">}</span>
            <span class="k">if</span> <span class="n">result</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;records&quot;</span><span class="p">)</span>
            <span class="k">else</span> <span class="p">{}</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_subnets">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_subnets">[docs]</a>
    <span class="k">def</span> <span class="nf">get_subnets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a list of all subnets currently active within the Bittensor network. This function</span>
<span class="sd">        provides an overview of the various subnets and their identifiers.</span>

<span class="sd">        Args:</span>
<span class="sd">            block (Optional[int], optional): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List[int]: A list of network UIDs representing each active subnet.</span>

<span class="sd">        This function is valuable for understanding the network&#39;s structure and the diversity of subnets</span>
<span class="sd">        available for neuron participation and collaboration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_map_subtensor</span><span class="p">(</span><span class="s2">&quot;NetworksAdded&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="p">[</span><span class="n">network</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">network</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">records</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">result</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;records&quot;</span><span class="p">)</span>
            <span class="k">else</span> <span class="p">[]</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_all_subnets_info">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_all_subnets_info">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">get_all_subnets_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">SubnetInfo</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves detailed information about all subnets within the Bittensor network. This function</span>
<span class="sd">        provides comprehensive data on each subnet, including its characteristics and operational parameters.</span>

<span class="sd">        Args:</span>
<span class="sd">            block (Optional[int], optional): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List[SubnetInfo]: A list of SubnetInfo objects, each containing detailed information about a subnet.</span>

<span class="sd">        Gaining insights into the subnets&#39; details assists in understanding the network&#39;s composition,</span>
<span class="sd">        the roles of different subnets, and their unique features.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">_logger</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">():</span>
            <span class="n">block_hash</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">rpc_request</span><span class="p">(</span>
                <span class="n">method</span><span class="o">=</span><span class="s2">&quot;subnetInfo_getSubnetsInfo&quot;</span><span class="p">,</span>  <span class="c1"># custom rpc method</span>
                <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">block_hash</span><span class="p">]</span> <span class="k">if</span> <span class="n">block_hash</span> <span class="k">else</span> <span class="p">[],</span>
            <span class="p">)</span>

        <span class="n">json_body</span> <span class="o">=</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">result</span> <span class="o">:=</span> <span class="n">json_body</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;result&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)):</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="n">SubnetInfo</span><span class="o">.</span><span class="n">list_from_vec_u8</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_subnet_info">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_subnet_info">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">get_subnet_info</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SubnetInfo</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves detailed information about a specific subnet within the Bittensor network. This function</span>
<span class="sd">        provides key data on the subnet, including its operational parameters and network status.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The network UID of the subnet to query.</span>
<span class="sd">            block (Optional[int], optional): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[SubnetInfo]: Detailed information about the subnet, or ``None`` if not found.</span>

<span class="sd">        This function is essential for neurons and stakeholders interested in the specifics of a particular</span>
<span class="sd">        subnet, including its governance, performance, and role within the broader network.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">_logger</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">():</span>
            <span class="n">block_hash</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">rpc_request</span><span class="p">(</span>
                <span class="n">method</span><span class="o">=</span><span class="s2">&quot;subnetInfo_getSubnetInfo&quot;</span><span class="p">,</span>  <span class="c1"># custom rpc method</span>
                <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block_hash</span><span class="p">]</span> <span class="k">if</span> <span class="n">block_hash</span> <span class="k">else</span> <span class="p">[</span><span class="n">netuid</span><span class="p">],</span>
            <span class="p">)</span>

        <span class="n">json_body</span> <span class="o">=</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">result</span> <span class="o">:=</span> <span class="n">json_body</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;result&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">SubnetInfo</span><span class="o">.</span><span class="n">from_vec_u8</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_subnet_hyperparameters">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_subnet_hyperparameters">[docs]</a>
    <span class="k">def</span> <span class="nf">get_subnet_hyperparameters</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">,</span> <span class="n">SubnetHyperparameters</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the hyperparameters for a specific subnet within the Bittensor network. These hyperparameters</span>
<span class="sd">        define the operational settings and rules governing the subnet&#39;s behavior.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The network UID of the subnet to query.</span>
<span class="sd">            block (Optional[int], optional): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[SubnetHyperparameters]: The subnet&#39;s hyperparameters, or ``None`` if not available.</span>

<span class="sd">        Understanding the hyperparameters is crucial for comprehending how subnets are configured and</span>
<span class="sd">        managed, and how they interact with the network&#39;s consensus and incentive mechanisms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hex_bytes_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_runtime_api</span><span class="p">(</span>
            <span class="n">runtime_api</span><span class="o">=</span><span class="s2">&quot;SubnetInfoRuntimeApi&quot;</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;get_subnet_hyperparams&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">],</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">hex_bytes_result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">hex_bytes_result</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;0x&quot;</span><span class="p">):</span>
            <span class="n">bytes_result</span> <span class="o">=</span> <span class="nb">bytes</span><span class="o">.</span><span class="n">fromhex</span><span class="p">(</span><span class="n">hex_bytes_result</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bytes_result</span> <span class="o">=</span> <span class="nb">bytes</span><span class="o">.</span><span class="n">fromhex</span><span class="p">(</span><span class="n">hex_bytes_result</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">SubnetHyperparameters</span><span class="o">.</span><span class="n">from_vec_u8</span><span class="p">(</span><span class="n">bytes_result</span><span class="p">)</span>  <span class="c1"># type: ignore</span></div>


<div class="viewcode-block" id="Subtensor.get_subnet_owner">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_subnet_owner">[docs]</a>
    <span class="k">def</span> <span class="nf">get_subnet_owner</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the owner&#39;s address of a specific subnet within the Bittensor network. The owner is</span>
<span class="sd">        typically the entity responsible for the creation and maintenance of the subnet.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The network UID of the subnet to query.</span>
<span class="sd">            block (Optional[int], optional): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[str]: The SS58 address of the subnet&#39;s owner, or ``None`` if not available.</span>

<span class="sd">        Knowing the subnet owner provides insights into the governance and operational control of the subnet,</span>
<span class="sd">        which can be important for decision-making and collaboration within the network.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_subtensor</span><span class="p">(</span><span class="s2">&quot;SubnetOwner&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="p">[</span><span class="n">netuid</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">_result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>


    <span class="c1">##############</span>
    <span class="c1"># Nomination #</span>
    <span class="c1">##############</span>
<div class="viewcode-block" id="Subtensor.is_hotkey_delegate">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.is_hotkey_delegate">[docs]</a>
    <span class="k">def</span> <span class="nf">is_hotkey_delegate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines whether a given hotkey (public key) is a delegate on the Bittensor network. This function</span>
<span class="sd">        checks if the neuron associated with the hotkey is part of the network&#39;s delegation system.</span>

<span class="sd">        Args:</span>
<span class="sd">            hotkey_ss58 (str): The SS58 address of the neuron&#39;s hotkey.</span>
<span class="sd">            block (Optional[int], optional): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the hotkey is a delegate, ``False`` otherwise.</span>

<span class="sd">        Being a delegate is a significant status within the Bittensor network, indicating a neuron&#39;s</span>
<span class="sd">        involvement in consensus and governance processes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">hotkey_ss58</span> <span class="ow">in</span> <span class="p">[</span>
            <span class="n">info</span><span class="o">.</span><span class="n">hotkey_ss58</span> <span class="k">for</span> <span class="n">info</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_delegates</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span>
        <span class="p">]</span></div>


<div class="viewcode-block" id="Subtensor.get_delegate_take">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_delegate_take">[docs]</a>
    <span class="k">def</span> <span class="nf">get_delegate_take</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the delegate &#39;take&#39; percentage for a neuron identified by its hotkey. The &#39;take&#39;</span>
<span class="sd">        represents the percentage of rewards that the delegate claims from its nominators&#39; stakes.</span>

<span class="sd">        Args:</span>
<span class="sd">            hotkey_ss58 (str): The ``SS58`` address of the neuron&#39;s hotkey.</span>
<span class="sd">            block (Optional[int], optional): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[float]: The delegate take percentage, None if not available.</span>

<span class="sd">        The delegate take is a critical parameter in the network&#39;s incentive structure, influencing</span>
<span class="sd">        the distribution of rewards among neurons and their nominators.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_subtensor</span><span class="p">(</span><span class="s2">&quot;Delegates&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="p">[</span><span class="n">hotkey_ss58</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="kc">None</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">_result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="n">U16_NORMALIZED_FLOAT</span><span class="p">(</span><span class="n">_result</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_nominators_for_hotkey">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_nominators_for_hotkey">[docs]</a>
    <span class="k">def</span> <span class="nf">get_nominators_for_hotkey</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Balance</span><span class="p">]],</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a list of nominators and their stakes for a neuron identified by its hotkey.</span>
<span class="sd">        Nominators are neurons that stake their tokens on a delegate to support its operations.</span>

<span class="sd">        Args:</span>
<span class="sd">            hotkey_ss58 (str): The ``SS58`` address of the neuron&#39;s hotkey.</span>
<span class="sd">            block (Optional[int], optional): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">           Union[List[Tuple[str, Balance]], int]: A list of tuples containing each nominator&#39;s address and staked amount or 0.</span>

<span class="sd">        This function provides insights into the neuron&#39;s support network within the Bittensor ecosystem,</span>
<span class="sd">        indicating its trust and collaboration relationships.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_map_subtensor</span><span class="p">(</span><span class="s2">&quot;Stake&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="p">[</span><span class="n">hotkey_ss58</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="p">[(</span><span class="n">record</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">record</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">records</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">result</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;records&quot;</span><span class="p">)</span>
            <span class="k">else</span> <span class="mi">0</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_delegate_by_hotkey">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_delegate_by_hotkey">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">get_delegate_by_hotkey</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DelegateInfo</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves detailed information about a delegate neuron based on its hotkey. This function provides</span>
<span class="sd">        a comprehensive view of the delegate&#39;s status, including its stakes, nominators, and reward distribution.</span>

<span class="sd">        Args:</span>
<span class="sd">            hotkey_ss58 (str): The ``SS58`` address of the delegate&#39;s hotkey.</span>
<span class="sd">            block (Optional[int], optional): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[DelegateInfo]: Detailed information about the delegate neuron, ``None`` if not found.</span>

<span class="sd">        This function is essential for understanding the roles and influence of delegate neurons within</span>
<span class="sd">        the Bittensor network&#39;s consensus and governance structures.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">_logger</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">(</span><span class="n">encoded_hotkey_</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
            <span class="n">block_hash</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">rpc_request</span><span class="p">(</span>
                <span class="n">method</span><span class="o">=</span><span class="s2">&quot;delegateInfo_getDelegate&quot;</span><span class="p">,</span>  <span class="c1"># custom rpc method</span>
                <span class="n">params</span><span class="o">=</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">encoded_hotkey_</span><span class="p">,</span> <span class="n">block_hash</span><span class="p">]</span> <span class="k">if</span> <span class="n">block_hash</span> <span class="k">else</span> <span class="p">[</span><span class="n">encoded_hotkey_</span><span class="p">]</span>
                <span class="p">),</span>
            <span class="p">)</span>

        <span class="n">encoded_hotkey</span> <span class="o">=</span> <span class="n">ss58_to_vec_u8</span><span class="p">(</span><span class="n">hotkey_ss58</span><span class="p">)</span>
        <span class="n">json_body</span> <span class="o">=</span> <span class="n">make_substrate_call_with_retry</span><span class="p">(</span><span class="n">encoded_hotkey</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">result</span> <span class="o">:=</span> <span class="n">json_body</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;result&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">DelegateInfo</span><span class="o">.</span><span class="n">from_vec_u8</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_delegates_lite">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_delegates_lite">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">get_delegates_lite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">DelegateInfoLite</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a lighter list of all delegate neurons within the Bittensor network. This function provides an</span>
<span class="sd">        overview of the neurons that are actively involved in the network&#39;s delegation system.</span>

<span class="sd">        Analyzing the delegate population offers insights into the network&#39;s governance dynamics and the distribution</span>
<span class="sd">        of trust and responsibility among participating neurons.</span>

<span class="sd">        This is a lighter version of :func:`get_delegates`.</span>

<span class="sd">        Args:</span>
<span class="sd">            block (Optional[int], optional): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List[DelegateInfoLite]: A list of ``DelegateInfoLite`` objects detailing each delegate&#39;s characteristics.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">_logger</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">():</span>
            <span class="n">block_hash</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">rpc_request</span><span class="p">(</span>
                <span class="n">method</span><span class="o">=</span><span class="s2">&quot;delegateInfo_getDelegatesLite&quot;</span><span class="p">,</span>  <span class="c1"># custom rpc method</span>
                <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">block_hash</span><span class="p">]</span> <span class="k">if</span> <span class="n">block_hash</span> <span class="k">else</span> <span class="p">[],</span>
            <span class="p">)</span>

        <span class="n">json_body</span> <span class="o">=</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">result</span> <span class="o">:=</span> <span class="n">json_body</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;result&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)):</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">DelegateInfoLite</span><span class="p">(</span><span class="o">**</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">result</span><span class="p">]</span></div>


<div class="viewcode-block" id="Subtensor.get_delegates">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_delegates">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">get_delegates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">DelegateInfo</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a list of all delegate neurons within the Bittensor network. This function provides an overview of the</span>
<span class="sd">        neurons that are actively involved in the network&#39;s delegation system.</span>

<span class="sd">        Analyzing the delegate population offers insights into the network&#39;s governance dynamics and the distribution of</span>
<span class="sd">        trust and responsibility among participating neurons.</span>

<span class="sd">        Args:</span>
<span class="sd">            block (Optional[int], optional): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List[DelegateInfo]: A list of DelegateInfo objects detailing each delegate&#39;s characteristics.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">_logger</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">():</span>
            <span class="n">block_hash</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">rpc_request</span><span class="p">(</span>
                <span class="n">method</span><span class="o">=</span><span class="s2">&quot;delegateInfo_getDelegates&quot;</span><span class="p">,</span>  <span class="c1"># custom rpc method</span>
                <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">block_hash</span><span class="p">]</span> <span class="k">if</span> <span class="n">block_hash</span> <span class="k">else</span> <span class="p">[],</span>
            <span class="p">)</span>

        <span class="n">json_body</span> <span class="o">=</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">result</span> <span class="o">:=</span> <span class="n">json_body</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;result&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)):</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="n">DelegateInfo</span><span class="o">.</span><span class="n">list_from_vec_u8</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_delegated">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_delegated">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">get_delegated</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">coldkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">DelegateInfo</span><span class="p">,</span> <span class="n">Balance</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a list of delegates and their associated stakes for a given coldkey. This function</span>
<span class="sd">        identifies the delegates that a specific account has staked tokens on.</span>

<span class="sd">        Args:</span>
<span class="sd">            coldkey_ss58 (str): The ``SS58`` address of the account&#39;s coldkey.</span>
<span class="sd">            block (Optional[int], optional): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List[Tuple[DelegateInfo, Balance]]: A list of tuples, each containing a delegate&#39;s information and staked</span>
<span class="sd">                amount.</span>

<span class="sd">        This function is important for account holders to understand their stake allocations and their</span>
<span class="sd">        involvement in the network&#39;s delegation and consensus mechanisms.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">_logger</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">(</span><span class="n">encoded_coldkey_</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
            <span class="n">block_hash</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">rpc_request</span><span class="p">(</span>
                <span class="n">method</span><span class="o">=</span><span class="s2">&quot;delegateInfo_getDelegated&quot;</span><span class="p">,</span>
                <span class="n">params</span><span class="o">=</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">block_hash</span><span class="p">,</span> <span class="n">encoded_coldkey_</span><span class="p">]</span> <span class="k">if</span> <span class="n">block_hash</span> <span class="k">else</span> <span class="p">[</span><span class="n">encoded_coldkey_</span><span class="p">]</span>
                <span class="p">),</span>
            <span class="p">)</span>

        <span class="n">encoded_coldkey</span> <span class="o">=</span> <span class="n">ss58_to_vec_u8</span><span class="p">(</span><span class="n">coldkey_ss58</span><span class="p">)</span>
        <span class="n">json_body</span> <span class="o">=</span> <span class="n">make_substrate_call_with_retry</span><span class="p">(</span><span class="n">encoded_coldkey</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">result</span> <span class="o">:=</span> <span class="n">json_body</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;result&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)):</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="n">DelegateInfo</span><span class="o">.</span><span class="n">delegated_list_from_vec_u8</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>


        <span class="c1">############################</span>
        <span class="c1"># Child Hotkey Information #</span>
        <span class="c1">############################</span>

<div class="viewcode-block" id="Subtensor.get_childkey_take">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_childkey_take">[docs]</a>
    <span class="k">def</span> <span class="nf">get_childkey_take</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hotkey</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the childkey take of a hotkey on a specific network.</span>
<span class="sd">        Args:</span>
<span class="sd">        - hotkey (str): The hotkey to search for.</span>
<span class="sd">        - netuid (int): The netuid to search for.</span>
<span class="sd">        - block (Optional[int]): Optional parameter specifying the block number. Defaults to None.</span>

<span class="sd">        Returns:</span>
<span class="sd">        - Optional[int]: The value of the &quot;ChildkeyTake&quot; if found, or None if any error occurs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">childkey_take</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_subtensor</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="s2">&quot;ChildkeyTake&quot;</span><span class="p">,</span>
                <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
                <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">hotkey</span><span class="p">,</span> <span class="n">netuid</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">childkey_take</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">childkey_take</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

        <span class="k">except</span> <span class="n">SubstrateRequestException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error querying ChildKeys: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected error in get_children: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Subtensor.get_children">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_children">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">get_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hotkey</span><span class="p">,</span> <span class="n">netuid</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the children of a hotkey on a specific network.</span>
<span class="sd">        Args:</span>
<span class="sd">            hotkey (str): The hotkey to query.</span>
<span class="sd">            netuid (int): The network ID.</span>
<span class="sd">        Returns:</span>
<span class="sd">            list or None: List of (proportion, child_address) tuples, or None if an error occurred.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">children</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
                <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
                <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;ChildKeys&quot;</span><span class="p">,</span>
                <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">hotkey</span><span class="p">,</span> <span class="n">netuid</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">children</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">format_children</span><span class="p">(</span><span class="n">children</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[]</span>
        <span class="k">except</span> <span class="n">SubstrateRequestException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error querying ChildKeys: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected error in get_children: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Subtensor.get_parents">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_parents">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">get_parents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child_hotkey</span><span class="p">,</span> <span class="n">netuid</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the parents of a child hotkey on a specific network.</span>
<span class="sd">        Args:</span>
<span class="sd">            child_hotkey (str): The child hotkey to query.</span>
<span class="sd">            netuid (int): The network ID.</span>
<span class="sd">        Returns:</span>
<span class="sd">            list or None: List of (proportion, parent_address) tuples, or None if an error occurred.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">parents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
                <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
                <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;ParentKeys&quot;</span><span class="p">,</span>
                <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">child_hotkey</span><span class="p">,</span> <span class="n">netuid</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">parents</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No parents found.&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="p">[]</span>

            <span class="n">formatted_parents</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">format_parent</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="n">parent</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">proportion</span><span class="p">,</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">parents</span>
                <span class="k">if</span> <span class="n">proportion</span> <span class="o">!=</span> <span class="mi">0</span>
            <span class="p">]</span>
            <span class="k">return</span> <span class="n">formatted_parents</span>
        <span class="k">except</span> <span class="n">SubstrateRequestException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error querying ParentKeys: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected error in get_parents: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">None</span></div>


    <span class="c1">#####################</span>
    <span class="c1"># Stake Information #</span>
    <span class="c1">#####################</span>

<div class="viewcode-block" id="Subtensor.get_stake_info_for_coldkey">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_stake_info_for_coldkey">[docs]</a>
    <span class="k">def</span> <span class="nf">get_stake_info_for_coldkey</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">coldkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">StakeInfo</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves stake information associated with a specific coldkey. This function provides details</span>
<span class="sd">        about the stakes held by an account, including the staked amounts and associated delegates.</span>

<span class="sd">        Args:</span>
<span class="sd">            coldkey_ss58 (str): The ``SS58`` address of the account&#39;s coldkey.</span>
<span class="sd">            block (Optional[int], optional): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List[StakeInfo]: A list of StakeInfo objects detailing the stake allocations for the account.</span>

<span class="sd">        Stake information is vital for account holders to assess their investment and participation</span>
<span class="sd">        in the network&#39;s delegation and consensus processes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">encoded_coldkey</span> <span class="o">=</span> <span class="n">ss58_to_vec_u8</span><span class="p">(</span><span class="n">coldkey_ss58</span><span class="p">)</span>

        <span class="n">hex_bytes_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_runtime_api</span><span class="p">(</span>
            <span class="n">runtime_api</span><span class="o">=</span><span class="s2">&quot;StakeInfoRuntimeApi&quot;</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;get_stake_info_for_coldkey&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">encoded_coldkey</span><span class="p">],</span>  <span class="c1"># type: ignore</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">hex_bytes_result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">hex_bytes_result</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;0x&quot;</span><span class="p">):</span>
            <span class="n">bytes_result</span> <span class="o">=</span> <span class="nb">bytes</span><span class="o">.</span><span class="n">fromhex</span><span class="p">(</span><span class="n">hex_bytes_result</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bytes_result</span> <span class="o">=</span> <span class="nb">bytes</span><span class="o">.</span><span class="n">fromhex</span><span class="p">(</span><span class="n">hex_bytes_result</span><span class="p">)</span>
        <span class="c1"># TODO: review if this is the correct type / works</span>
        <span class="k">return</span> <span class="n">StakeInfo</span><span class="o">.</span><span class="n">list_from_vec_u8</span><span class="p">(</span><span class="n">bytes_result</span><span class="p">)</span>  <span class="c1"># type: ignore</span></div>


<div class="viewcode-block" id="Subtensor.get_stake_info_for_coldkeys">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_stake_info_for_coldkeys">[docs]</a>
    <span class="k">def</span> <span class="nf">get_stake_info_for_coldkeys</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">coldkey_ss58_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">StakeInfo</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves stake information for a list of coldkeys. This function aggregates stake data for multiple</span>
<span class="sd">        accounts, providing a collective view of their stakes and delegations.</span>

<span class="sd">        Args:</span>
<span class="sd">            coldkey_ss58_list (List[str]): A list of ``SS58`` addresses of the accounts&#39; coldkeys.</span>
<span class="sd">            block (Optional[int], optional): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dict[str, List[StakeInfo]]: A dictionary mapping each coldkey to a list of its StakeInfo objects.</span>

<span class="sd">        This function is useful for analyzing the stake distribution and delegation patterns of multiple</span>
<span class="sd">        accounts simultaneously, offering a broader perspective on network participation and investment strategies.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: review - ss58_to_vec_u8 returns List[int] but the runtime api expects List[List[int]]</span>
        <span class="n">encoded_coldkeys</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">ss58_to_vec_u8</span><span class="p">(</span><span class="n">coldkey_ss58</span><span class="p">)</span> <span class="k">for</span> <span class="n">coldkey_ss58</span> <span class="ow">in</span> <span class="n">coldkey_ss58_list</span>
        <span class="p">]</span>

        <span class="n">hex_bytes_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_runtime_api</span><span class="p">(</span>
            <span class="n">runtime_api</span><span class="o">=</span><span class="s2">&quot;StakeInfoRuntimeApi&quot;</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;get_stake_info_for_coldkeys&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">encoded_coldkeys</span><span class="p">],</span>  <span class="c1"># type: ignore</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">hex_bytes_result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">hex_bytes_result</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;0x&quot;</span><span class="p">):</span>
            <span class="n">bytes_result</span> <span class="o">=</span> <span class="nb">bytes</span><span class="o">.</span><span class="n">fromhex</span><span class="p">(</span><span class="n">hex_bytes_result</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bytes_result</span> <span class="o">=</span> <span class="nb">bytes</span><span class="o">.</span><span class="n">fromhex</span><span class="p">(</span><span class="n">hex_bytes_result</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">StakeInfo</span><span class="o">.</span><span class="n">list_of_tuple_from_vec_u8</span><span class="p">(</span><span class="n">bytes_result</span><span class="p">)</span>  <span class="c1"># type: ignore</span></div>


<div class="viewcode-block" id="Subtensor.get_minimum_required_stake">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_minimum_required_stake">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">get_minimum_required_stake</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Balance</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the minimum required stake for nominators in the Subtensor network.</span>

<span class="sd">        This method retries the substrate call up to three times with exponential backoff in case of failures.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Balance: The minimum required stake as a Balance object.</span>

<span class="sd">        Raises:</span>
<span class="sd">            Exception: If the substrate call fails after the maximum number of retries.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">_logger</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
                <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span> <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;NominatorMinRequiredStake&quot;</span>
            <span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">decode</span><span class="p">())</span></div>


    <span class="c1">#################################</span>
    <span class="c1"># Neuron information per subnet #</span>
    <span class="c1">#################################</span>

<div class="viewcode-block" id="Subtensor.is_hotkey_registered_any">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.is_hotkey_registered_any">[docs]</a>
    <span class="k">def</span> <span class="nf">is_hotkey_registered_any</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if a neuron&#39;s hotkey is registered on any subnet within the Bittensor network.</span>

<span class="sd">        Args:</span>
<span class="sd">            hotkey_ss58 (str): The ``SS58`` address of the neuron&#39;s hotkey.</span>
<span class="sd">            block (Optional[int]): The blockchain block number at which to perform the check.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the hotkey is registered on any subnet, False otherwise.</span>

<span class="sd">        This function is essential for determining the network-wide presence and participation of a neuron.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_netuids_for_hotkey</span><span class="p">(</span><span class="n">hotkey_ss58</span><span class="p">,</span> <span class="n">block</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="Subtensor.is_hotkey_registered_on_subnet">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.is_hotkey_registered_on_subnet">[docs]</a>
    <span class="k">def</span> <span class="nf">is_hotkey_registered_on_subnet</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if a neuron&#39;s hotkey is registered on a specific subnet within the Bittensor network.</span>

<span class="sd">        Args:</span>
<span class="sd">            hotkey_ss58 (str): The ``SS58`` address of the neuron&#39;s hotkey.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int]): The blockchain block number at which to perform the check.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the hotkey is registered on the specified subnet, False otherwise.</span>

<span class="sd">        This function helps in assessing the participation of a neuron in a particular subnet,</span>
<span class="sd">        indicating its specific area of operation or influence within the network.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_uid_for_hotkey_on_subnet</span><span class="p">(</span><span class="n">hotkey_ss58</span><span class="p">,</span> <span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Subtensor.is_hotkey_registered">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.is_hotkey_registered">[docs]</a>
    <span class="k">def</span> <span class="nf">is_hotkey_registered</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines whether a given hotkey (public key) is registered in the Bittensor network, either</span>
<span class="sd">        globally across any subnet or specifically on a specified subnet. This function checks the registration</span>
<span class="sd">        status of a neuron identified by its hotkey, which is crucial for validating its participation and</span>
<span class="sd">        activities within the network.</span>

<span class="sd">        Args:</span>
<span class="sd">            hotkey_ss58 (str): The SS58 address of the neuron&#39;s hotkey.</span>
<span class="sd">            netuid (Optional[int]): The unique identifier of the subnet to check the registration. If ``None``, the</span>
<span class="sd">                registration is checked across all subnets.</span>
<span class="sd">            block (Optional[int]): The blockchain block number at which to perform the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the hotkey is registered in the specified context (either any subnet or a specific</span>
<span class="sd">                subnet), ``False`` otherwise.</span>

<span class="sd">        This function is important for verifying the active status of neurons in the Bittensor network. It aids</span>
<span class="sd">        in understanding whether a neuron is eligible to participate in network processes such as consensus,</span>
<span class="sd">        validation, and incentive distribution based on its registration status.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">netuid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_hotkey_registered_any</span><span class="p">(</span><span class="n">hotkey_ss58</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_hotkey_registered_on_subnet</span><span class="p">(</span><span class="n">hotkey_ss58</span><span class="p">,</span> <span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_uid_for_hotkey_on_subnet">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_uid_for_hotkey_on_subnet">[docs]</a>
    <span class="k">def</span> <span class="nf">get_uid_for_hotkey_on_subnet</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the unique identifier (UID) for a neuron&#39;s hotkey on a specific subnet.</span>

<span class="sd">        Args:</span>
<span class="sd">            hotkey_ss58 (str): The ``SS58`` address of the neuron&#39;s hotkey.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The UID of the neuron if it is registered on the subnet, ``None`` otherwise.</span>

<span class="sd">        The UID is a critical identifier within the network, linking the neuron&#39;s hotkey to its</span>
<span class="sd">        operational and governance activities on a particular subnet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_subtensor</span><span class="p">(</span><span class="s2">&quot;Uids&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="p">[</span><span class="n">netuid</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">_result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_all_uids_for_hotkey">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_all_uids_for_hotkey">[docs]</a>
    <span class="k">def</span> <span class="nf">get_all_uids_for_hotkey</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves all unique identifiers (UIDs) associated with a given hotkey across different subnets</span>
<span class="sd">        within the Bittensor network. This function helps in identifying all the neuron instances that are</span>
<span class="sd">        linked to a specific hotkey.</span>

<span class="sd">        Args:</span>
<span class="sd">            hotkey_ss58 (str): The ``SS58`` address of the neuron&#39;s hotkey.</span>
<span class="sd">            block (Optional[int]): The blockchain block number at which to perform the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List[int]: A list of UIDs associated with the given hotkey across various subnets.</span>

<span class="sd">        This function is important for tracking a neuron&#39;s presence and activities across different</span>
<span class="sd">        subnets within the Bittensor ecosystem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_uid_for_hotkey_on_subnet</span><span class="p">(</span><span class="n">hotkey_ss58</span><span class="p">,</span> <span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span> <span class="ow">or</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">netuid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_netuids_for_hotkey</span><span class="p">(</span><span class="n">hotkey_ss58</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>
        <span class="p">]</span></div>


<div class="viewcode-block" id="Subtensor.get_netuids_for_hotkey">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_netuids_for_hotkey">[docs]</a>
    <span class="k">def</span> <span class="nf">get_netuids_for_hotkey</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a list of subnet UIDs (netuids) for which a given hotkey is a member. This function</span>
<span class="sd">        identifies the specific subnets within the Bittensor network where the neuron associated with</span>
<span class="sd">        the hotkey is active.</span>

<span class="sd">        Args:</span>
<span class="sd">            hotkey_ss58 (str): The ``SS58`` address of the neuron&#39;s hotkey.</span>
<span class="sd">            block (Optional[int]): The blockchain block number at which to perform the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List[int]: A list of netuids where the neuron is a member.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_map_subtensor</span><span class="p">(</span><span class="s2">&quot;IsNetworkMember&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="p">[</span><span class="n">hotkey_ss58</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="p">[</span><span class="n">record</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">records</span> <span class="k">if</span> <span class="n">record</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">result</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;records&quot;</span><span class="p">)</span>
            <span class="k">else</span> <span class="p">[]</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_neuron_for_pubkey_and_subnet">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_neuron_for_pubkey_and_subnet">[docs]</a>
    <span class="k">def</span> <span class="nf">get_neuron_for_pubkey_and_subnet</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">NeuronInfo</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves information about a neuron based on its public key (hotkey SS58 address) and the specific</span>
<span class="sd">        subnet UID (netuid). This function provides detailed neuron information for a particular subnet within</span>
<span class="sd">        the Bittensor network.</span>

<span class="sd">        Args:</span>
<span class="sd">            hotkey_ss58 (str): The ``SS58`` address of the neuron&#39;s hotkey.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int]): The blockchain block number at which to perform the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[NeuronInfo]: Detailed information about the neuron if found, ``None`` otherwise.</span>

<span class="sd">        This function is crucial for accessing specific neuron data and understanding its status, stake,</span>
<span class="sd">        and other attributes within a particular subnet of the Bittensor ecosystem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron_for_uid</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_uid_for_hotkey_on_subnet</span><span class="p">(</span><span class="n">hotkey_ss58</span><span class="p">,</span> <span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">),</span>
            <span class="n">netuid</span><span class="p">,</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_all_neurons_for_pubkey">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_all_neurons_for_pubkey">[docs]</a>
    <span class="k">def</span> <span class="nf">get_all_neurons_for_pubkey</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">NeuronInfo</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves information about all neuron instances associated with a given public key (hotkey ``SS58``</span>
<span class="sd">        address) across different subnets of the Bittensor network. This function aggregates neuron data</span>
<span class="sd">        from various subnets to provide a comprehensive view of a neuron&#39;s presence and status within the network.</span>

<span class="sd">        Args:</span>
<span class="sd">            hotkey_ss58 (str): The ``SS58`` address of the neuron&#39;s hotkey.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List[NeuronInfo]: A list of NeuronInfo objects detailing the neuron&#39;s presence across various subnets.</span>

<span class="sd">        This function is valuable for analyzing a neuron&#39;s overall participation, influence, and</span>
<span class="sd">        contributions across the Bittensor network.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">netuids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_netuids_for_hotkey</span><span class="p">(</span><span class="n">hotkey_ss58</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>
        <span class="n">uids</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_uid_for_hotkey_on_subnet</span><span class="p">(</span><span class="n">hotkey_ss58</span><span class="p">,</span> <span class="n">net</span><span class="p">)</span> <span class="k">for</span> <span class="n">net</span> <span class="ow">in</span> <span class="n">netuids</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">neuron_for_uid</span><span class="p">(</span><span class="n">uid</span><span class="p">,</span> <span class="n">net</span><span class="p">)</span> <span class="k">for</span> <span class="n">uid</span><span class="p">,</span> <span class="n">net</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">uids</span><span class="p">,</span> <span class="n">netuids</span><span class="p">))]</span></div>


<div class="viewcode-block" id="Subtensor.neuron_has_validator_permit">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.neuron_has_validator_permit">[docs]</a>
    <span class="k">def</span> <span class="nf">neuron_has_validator_permit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">uid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if a neuron, identified by its unique identifier (UID), has a validator permit on a specific</span>
<span class="sd">        subnet within the Bittensor network. This function determines whether the neuron is authorized to</span>
<span class="sd">        participate in validation processes on the subnet.</span>

<span class="sd">        Args:</span>
<span class="sd">            uid (int): The unique identifier of the neuron.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[bool]: ``True`` if the neuron has a validator permit, False otherwise.</span>

<span class="sd">        This function is essential for understanding a neuron&#39;s role and capabilities within a specific</span>
<span class="sd">        subnet, particularly regarding its involvement in network validation and governance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_subtensor</span><span class="p">(</span><span class="s2">&quot;ValidatorPermit&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="p">[</span><span class="n">netuid</span><span class="p">,</span> <span class="n">uid</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">_result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.neuron_for_wallet">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.neuron_for_wallet">[docs]</a>
    <span class="k">def</span> <span class="nf">neuron_for_wallet</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">NeuronInfo</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves information about a neuron associated with a given wallet on a specific subnet.</span>
<span class="sd">        This function provides detailed data about the neuron&#39;s status, stake, and activities based on</span>
<span class="sd">        the wallet&#39;s hotkey address.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet associated with the neuron.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int]): The blockchain block number at which to perform the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[NeuronInfo]: Detailed information about the neuron if found, ``None`` otherwise.</span>

<span class="sd">        This function is important for wallet owners to understand and manage their neuron&#39;s presence</span>
<span class="sd">        and activities within a particular subnet of the Bittensor network.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_neuron_for_pubkey_and_subnet</span><span class="p">(</span>
            <span class="n">wallet</span><span class="o">.</span><span class="n">hotkey</span><span class="o">.</span><span class="n">ss58_address</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.neuron_for_uid">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.neuron_for_uid">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">neuron_for_uid</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">uid</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NeuronInfo</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves detailed information about a specific neuron identified by its unique identifier (UID)</span>
<span class="sd">        within a specified subnet (netuid) of the Bittensor network. This function provides a comprehensive</span>
<span class="sd">        view of a neuron&#39;s attributes, including its stake, rank, and operational status.</span>

<span class="sd">        Args:</span>
<span class="sd">            uid (int): The unique identifier of the neuron.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int], optional): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            NeuronInfo: Detailed information about the neuron if found, ``None`` otherwise.</span>

<span class="sd">        This function is crucial for analyzing individual neurons&#39; contributions and status within a specific</span>
<span class="sd">        subnet, offering insights into their roles in the network&#39;s consensus and validation mechanisms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">uid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">NeuronInfo</span><span class="o">.</span><span class="n">get_null_neuron</span><span class="p">()</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">_logger</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">():</span>
            <span class="n">block_hash</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
            <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">netuid</span><span class="p">,</span> <span class="n">uid</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">block_hash</span><span class="p">:</span>
                <span class="n">params</span> <span class="o">=</span> <span class="n">params</span> <span class="o">+</span> <span class="p">[</span><span class="n">block_hash</span><span class="p">]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">rpc_request</span><span class="p">(</span>
                <span class="n">method</span><span class="o">=</span><span class="s2">&quot;neuronInfo_getNeuron&quot;</span><span class="p">,</span>
                <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>  <span class="c1"># custom rpc method</span>
            <span class="p">)</span>

        <span class="n">json_body</span> <span class="o">=</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">result</span> <span class="o">:=</span> <span class="n">json_body</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;result&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">NeuronInfo</span><span class="o">.</span><span class="n">get_null_neuron</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">NeuronInfo</span><span class="o">.</span><span class="n">from_vec_u8</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.neurons">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.neurons">[docs]</a>
    <span class="k">def</span> <span class="nf">neurons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">NeuronInfo</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a list of all neurons within a specified subnet of the Bittensor network. This function</span>
<span class="sd">        provides a snapshot of the subnet&#39;s neuron population, including each neuron&#39;s attributes and network</span>
<span class="sd">        interactions.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int], optional): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List[NeuronInfo]: A list of NeuronInfo objects detailing each neuron&#39;s characteristics in the subnet.</span>

<span class="sd">        Understanding the distribution and status of neurons within a subnet is key to comprehending the</span>
<span class="sd">        network&#39;s decentralized structure and the dynamics of its consensus and governance processes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">neurons_lite</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neurons_lite</span><span class="p">(</span><span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">)</span>
        <span class="n">bonds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">)</span>

        <span class="n">weights_as_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">uid</span><span class="p">:</span> <span class="n">w</span> <span class="k">for</span> <span class="n">uid</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">weights</span><span class="p">}</span>
        <span class="n">bonds_as_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">uid</span><span class="p">:</span> <span class="n">b</span> <span class="k">for</span> <span class="n">uid</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bonds</span><span class="p">}</span>

        <span class="n">neurons</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">NeuronInfo</span><span class="o">.</span><span class="n">from_weights_bonds_and_neuron_lite</span><span class="p">(</span>
                <span class="n">neuron_lite</span><span class="p">,</span> <span class="n">weights_as_dict</span><span class="p">,</span> <span class="n">bonds_as_dict</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">neuron_lite</span> <span class="ow">in</span> <span class="n">neurons_lite</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="n">neurons</span></div>


<div class="viewcode-block" id="Subtensor.neuron_for_uid_lite">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.neuron_for_uid_lite">[docs]</a>
    <span class="k">def</span> <span class="nf">neuron_for_uid_lite</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">uid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">NeuronInfoLite</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a lightweight version of information about a neuron in a specific subnet, identified by</span>
<span class="sd">        its UID. The &#39;lite&#39; version focuses on essential attributes such as stake and network activity.</span>

<span class="sd">        Args:</span>
<span class="sd">            uid (int): The unique identifier of the neuron.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int], optional): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[NeuronInfoLite]: A simplified version of neuron information if found, ``None`` otherwise.</span>

<span class="sd">        This function is useful for quick and efficient analyses of neuron status and activities within a</span>
<span class="sd">        subnet without the need for comprehensive data retrieval.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">uid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">NeuronInfoLite</span><span class="o">.</span><span class="n">get_null_neuron</span><span class="p">()</span>

        <span class="n">hex_bytes_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_runtime_api</span><span class="p">(</span>
            <span class="n">runtime_api</span><span class="o">=</span><span class="s2">&quot;NeuronInfoRuntimeApi&quot;</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;get_neuron_lite&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;netuid&quot;</span><span class="p">:</span> <span class="n">netuid</span><span class="p">,</span>
                <span class="s2">&quot;uid&quot;</span><span class="p">:</span> <span class="n">uid</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">hex_bytes_result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">NeuronInfoLite</span><span class="o">.</span><span class="n">get_null_neuron</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">hex_bytes_result</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;0x&quot;</span><span class="p">):</span>
            <span class="n">bytes_result</span> <span class="o">=</span> <span class="nb">bytes</span><span class="o">.</span><span class="n">fromhex</span><span class="p">(</span><span class="n">hex_bytes_result</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bytes_result</span> <span class="o">=</span> <span class="nb">bytes</span><span class="o">.</span><span class="n">fromhex</span><span class="p">(</span><span class="n">hex_bytes_result</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">NeuronInfoLite</span><span class="o">.</span><span class="n">from_vec_u8</span><span class="p">(</span><span class="n">bytes_result</span><span class="p">)</span>  <span class="c1"># type: ignore</span></div>


<div class="viewcode-block" id="Subtensor.neurons_lite">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.neurons_lite">[docs]</a>
    <span class="k">def</span> <span class="nf">neurons_lite</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">NeuronInfoLite</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a list of neurons in a &#39;lite&#39; format from a specific subnet of the Bittensor network.</span>
<span class="sd">        This function provides a streamlined view of the neurons, focusing on key attributes such as stake</span>
<span class="sd">        and network participation.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int], optional): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List[NeuronInfoLite]: A list of simplified neuron information for the subnet.</span>

<span class="sd">        This function offers a quick overview of the neuron population within a subnet, facilitating</span>
<span class="sd">        efficient analysis of the network&#39;s decentralized structure and neuron dynamics.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hex_bytes_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_runtime_api</span><span class="p">(</span>
            <span class="n">runtime_api</span><span class="o">=</span><span class="s2">&quot;NeuronInfoRuntimeApi&quot;</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;get_neurons_lite&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">],</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">hex_bytes_result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">hex_bytes_result</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;0x&quot;</span><span class="p">):</span>
            <span class="n">bytes_result</span> <span class="o">=</span> <span class="nb">bytes</span><span class="o">.</span><span class="n">fromhex</span><span class="p">(</span><span class="n">hex_bytes_result</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bytes_result</span> <span class="o">=</span> <span class="nb">bytes</span><span class="o">.</span><span class="n">fromhex</span><span class="p">(</span><span class="n">hex_bytes_result</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">NeuronInfoLite</span><span class="o">.</span><span class="n">list_from_vec_u8</span><span class="p">(</span><span class="n">bytes_result</span><span class="p">)</span>  <span class="c1"># type: ignore</span></div>


<div class="viewcode-block" id="Subtensor.metagraph">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.metagraph">[docs]</a>
    <span class="k">def</span> <span class="nf">metagraph</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">lite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bittensor.metagraph&quot;</span><span class="p">:</span>  <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a synced metagraph for a specified subnet within the Bittensor network. The metagraph</span>
<span class="sd">        represents the network&#39;s structure, including neuron connections and interactions.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The network UID of the subnet to query.</span>
<span class="sd">            lite (bool, default=True): If true, returns a metagraph using a lightweight sync (no weights, no bonds).</span>
<span class="sd">            block (Optional[int]): Block number for synchronization, or ``None`` for the latest block.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bittensor.Metagraph: The metagraph representing the subnet&#39;s structure and neuron relationships.</span>

<span class="sd">        The metagraph is an essential tool for understanding the topology and dynamics of the Bittensor</span>
<span class="sd">        network&#39;s decentralized architecture, particularly in relation to neuron interconnectivity and consensus</span>
<span class="sd">            processes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">metagraph_</span> <span class="o">=</span> <span class="n">bittensor</span><span class="o">.</span><span class="n">metagraph</span><span class="p">(</span>
            <span class="n">network</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">lite</span><span class="o">=</span><span class="n">lite</span><span class="p">,</span> <span class="n">sync</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>
        <span class="n">metagraph_</span><span class="o">.</span><span class="n">sync</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span> <span class="n">lite</span><span class="o">=</span><span class="n">lite</span><span class="p">,</span> <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">metagraph_</span></div>


<div class="viewcode-block" id="Subtensor.incentive">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.incentive">[docs]</a>
    <span class="k">def</span> <span class="nf">incentive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the list of incentives for neurons within a specific subnet of the Bittensor network.</span>
<span class="sd">        This function provides insights into the reward distribution mechanisms and the incentives allocated</span>
<span class="sd">        to each neuron based on their contributions and activities.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The network UID of the subnet to query.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List[int]: The list of incentives for neurons within the subnet, indexed by UID.</span>

<span class="sd">        Understanding the incentive structure is crucial for analyzing the network&#39;s economic model and</span>
<span class="sd">        the motivational drivers for neuron participation and collaboration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i_map</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">i_map_encoded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_map_subtensor</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Incentive&quot;</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i_map_encoded</span><span class="o">.</span><span class="n">records</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">netuid_</span><span class="p">,</span> <span class="n">incentives_map</span> <span class="ow">in</span> <span class="n">i_map_encoded</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">netuid_</span> <span class="o">==</span> <span class="n">netuid</span><span class="p">:</span>
                    <span class="n">i_map</span> <span class="o">=</span> <span class="n">incentives_map</span><span class="o">.</span><span class="n">serialize</span><span class="p">()</span>
                    <span class="k">break</span>

        <span class="k">return</span> <span class="n">i_map</span></div>


<div class="viewcode-block" id="Subtensor.weights">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.weights">[docs]</a>
    <span class="k">def</span> <span class="nf">weights</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the weight distribution set by neurons within a specific subnet of the Bittensor network.</span>
<span class="sd">        This function maps each neuron&#39;s UID to the weights it assigns to other neurons, reflecting the</span>
<span class="sd">        network&#39;s trust and value assignment mechanisms.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The network UID of the subnet to query.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List[Tuple[int, List[Tuple[int, int]]]]: A list of tuples mapping each neuron&#39;s UID to its assigned weights.</span>

<span class="sd">        The weight distribution is a key factor in the network&#39;s consensus algorithm and the ranking of neurons,</span>
<span class="sd">        influencing their influence and reward allocation within the subnet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">w_map</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">w_map_encoded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_map_subtensor</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Weights&quot;</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">w_map_encoded</span><span class="o">.</span><span class="n">records</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">uid</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">w_map_encoded</span><span class="p">:</span>
                <span class="n">w_map</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">uid</span><span class="o">.</span><span class="n">serialize</span><span class="p">(),</span> <span class="n">w</span><span class="o">.</span><span class="n">serialize</span><span class="p">()))</span>

        <span class="k">return</span> <span class="n">w_map</span></div>


<div class="viewcode-block" id="Subtensor.bonds">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.bonds">[docs]</a>
    <span class="k">def</span> <span class="nf">bonds</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the bond distribution set by neurons within a specific subnet of the Bittensor network.</span>
<span class="sd">        Bonds represent the investments or commitments made by neurons in one another, indicating a level</span>
<span class="sd">        of trust and perceived value. This bonding mechanism is integral to the network&#39;s market-based approach</span>
<span class="sd">        to measuring and rewarding machine intelligence.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The network UID of the subnet to query.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List[Tuple[int, List[Tuple[int, int]]]]: A list of tuples mapping each neuron&#39;s UID to its bonds with other</span>
<span class="sd">                neurons.</span>

<span class="sd">        Understanding bond distributions is crucial for analyzing the trust dynamics and market behavior</span>
<span class="sd">        within the subnet. It reflects how neurons recognize and invest in each other&#39;s intelligence and</span>
<span class="sd">        contributions, supporting diverse and niche systems within the Bittensor ecosystem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">b_map</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">b_map_encoded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_map_subtensor</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Bonds&quot;</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">b_map_encoded</span><span class="o">.</span><span class="n">records</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">uid</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">b_map_encoded</span><span class="p">:</span>
                <span class="n">b_map</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">uid</span><span class="o">.</span><span class="n">serialize</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">serialize</span><span class="p">()))</span>

        <span class="k">return</span> <span class="n">b_map</span></div>


<div class="viewcode-block" id="Subtensor.get_subnet_burn_cost">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_subnet_burn_cost">[docs]</a>
    <span class="k">def</span> <span class="nf">get_subnet_burn_cost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the burn cost for registering a new subnet within the Bittensor network. This cost</span>
<span class="sd">        represents the amount of Tao that needs to be locked or burned to establish a new subnet.</span>

<span class="sd">        Args:</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: The burn cost for subnet registration.</span>

<span class="sd">        The subnet burn cost is an important economic parameter, reflecting the network&#39;s mechanisms for</span>
<span class="sd">        controlling the proliferation of subnets and ensuring their commitment to the network&#39;s long-term viability.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lock_cost</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_runtime_api</span><span class="p">(</span>
            <span class="n">runtime_api</span><span class="o">=</span><span class="s2">&quot;SubnetRegistrationRuntimeApi&quot;</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;get_network_registration_cost&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[],</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">lock_cost</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">lock_cost</span></div>


    <span class="c1">##############</span>
    <span class="c1"># Extrinsics #</span>
    <span class="c1">##############</span>

<div class="viewcode-block" id="Subtensor._do_delegation">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor._do_delegation">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">_do_delegation</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">delegate_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">amount</span><span class="p">:</span> <span class="s2">&quot;Balance&quot;</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delegates a specified amount of stake to a delegate&#39;s hotkey.</span>

<span class="sd">        This method sends a transaction to add stake to a delegate&#39;s hotkey and retries the call up to three times</span>
<span class="sd">        with exponential backoff in case of failures.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet from which the stake will be delegated.</span>
<span class="sd">            delegate_ss58 (str): The SS58 address of the delegate&#39;s hotkey.</span>
<span class="sd">            amount (Balance): The amount of stake to be delegated.</span>
<span class="sd">            wait_for_inclusion (bool, optional): Whether to wait for the transaction to be included in a block. Default is ``True``.</span>
<span class="sd">            wait_for_finalization (bool, optional): Whether to wait for the transaction to be finalized. Default is ``False``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the delegation is successful, ``False`` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">_logger</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">():</span>
            <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">compose_call</span><span class="p">(</span>
                <span class="n">call_module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
                <span class="n">call_function</span><span class="o">=</span><span class="s2">&quot;add_stake&quot;</span><span class="p">,</span>
                <span class="n">call_params</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;hotkey&quot;</span><span class="p">:</span> <span class="n">delegate_ss58</span><span class="p">,</span> <span class="s2">&quot;amount_staked&quot;</span><span class="p">:</span> <span class="n">amount</span><span class="o">.</span><span class="n">rao</span><span class="p">},</span>
            <span class="p">)</span>
            <span class="n">extrinsic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">create_signed_extrinsic</span><span class="p">(</span>
                <span class="n">call</span><span class="o">=</span><span class="n">call</span><span class="p">,</span> <span class="n">keypair</span><span class="o">=</span><span class="n">wallet</span><span class="o">.</span><span class="n">coldkey</span>
            <span class="p">)</span>
            <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">submit_extrinsic</span><span class="p">(</span>
                <span class="n">extrinsic</span><span class="p">,</span>
                <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># We only wait here if we expect finalization.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">wait_for_finalization</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">wait_for_inclusion</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="n">response</span><span class="o">.</span><span class="n">process_events</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">response</span><span class="o">.</span><span class="n">is_success</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">StakeError</span><span class="p">(</span><span class="n">format_error_message</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">error_message</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span></div>


<div class="viewcode-block" id="Subtensor._do_undelegation">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor._do_undelegation">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">_do_undelegation</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">delegate_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">amount</span><span class="p">:</span> <span class="s2">&quot;Balance&quot;</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes a specified amount of stake from a delegate&#39;s hotkey.</span>

<span class="sd">        This method sends a transaction to remove stake from a delegate&#39;s hotkey and retries the call up to three times</span>
<span class="sd">        with exponential backoff in case of failures.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet from which the stake will be removed.</span>
<span class="sd">            delegate_ss58 (str): The SS58 address of the delegate&#39;s hotkey.</span>
<span class="sd">            amount (Balance): The amount of stake to be removed.</span>
<span class="sd">            wait_for_inclusion (bool, optional): Whether to wait for the transaction to be included in a block. Default is ``True``.</span>
<span class="sd">            wait_for_finalization (bool, optional): Whether to wait for the transaction to be finalized. Default is ``False``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the undelegation is successful, ``False`` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">_logger</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">():</span>
            <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">compose_call</span><span class="p">(</span>
                <span class="n">call_module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
                <span class="n">call_function</span><span class="o">=</span><span class="s2">&quot;remove_stake&quot;</span><span class="p">,</span>
                <span class="n">call_params</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;hotkey&quot;</span><span class="p">:</span> <span class="n">delegate_ss58</span><span class="p">,</span>
                    <span class="s2">&quot;amount_unstaked&quot;</span><span class="p">:</span> <span class="n">amount</span><span class="o">.</span><span class="n">rao</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>
            <span class="n">extrinsic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">create_signed_extrinsic</span><span class="p">(</span>
                <span class="n">call</span><span class="o">=</span><span class="n">call</span><span class="p">,</span> <span class="n">keypair</span><span class="o">=</span><span class="n">wallet</span><span class="o">.</span><span class="n">coldkey</span>
            <span class="p">)</span>
            <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">submit_extrinsic</span><span class="p">(</span>
                <span class="n">extrinsic</span><span class="p">,</span>
                <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># We only wait here if we expect finalization.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">wait_for_finalization</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">wait_for_inclusion</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="n">response</span><span class="o">.</span><span class="n">process_events</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">response</span><span class="o">.</span><span class="n">is_success</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">StakeError</span><span class="p">(</span><span class="n">format_error_message</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">error_message</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span></div>


<div class="viewcode-block" id="Subtensor._do_nominate">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor._do_nominate">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">_do_nominate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Nominates the wallet&#39;s hotkey to become a delegate.</span>

<span class="sd">        This method sends a transaction to nominate the wallet&#39;s hotkey to become a delegate and retries the call up to</span>
<span class="sd">        three times with exponential backoff in case of failures.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet whose hotkey will be nominated.</span>
<span class="sd">            wait_for_inclusion (bool, optional): Whether to wait for the transaction to be included in a block. Default is ``True``.</span>
<span class="sd">            wait_for_finalization (bool, optional): Whether to wait for the transaction to be finalized. Default is ``False``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the nomination is successful, ``False`` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">_logger</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">():</span>
            <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">compose_call</span><span class="p">(</span>
                <span class="n">call_module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
                <span class="n">call_function</span><span class="o">=</span><span class="s2">&quot;become_delegate&quot;</span><span class="p">,</span>
                <span class="n">call_params</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;hotkey&quot;</span><span class="p">:</span> <span class="n">wallet</span><span class="o">.</span><span class="n">hotkey</span><span class="o">.</span><span class="n">ss58_address</span><span class="p">},</span>
            <span class="p">)</span>
            <span class="n">extrinsic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">create_signed_extrinsic</span><span class="p">(</span>
                <span class="n">call</span><span class="o">=</span><span class="n">call</span><span class="p">,</span> <span class="n">keypair</span><span class="o">=</span><span class="n">wallet</span><span class="o">.</span><span class="n">coldkey</span>
            <span class="p">)</span>  <span class="c1"># sign with coldkey</span>
            <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">submit_extrinsic</span><span class="p">(</span>
                <span class="n">extrinsic</span><span class="p">,</span>
                <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># We only wait here if we expect finalization.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">wait_for_finalization</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">wait_for_inclusion</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="n">response</span><span class="o">.</span><span class="n">process_events</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">response</span><span class="o">.</span><span class="n">is_success</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">NominationError</span><span class="p">(</span><span class="n">format_error_message</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">error_message</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span></div>


<div class="viewcode-block" id="Subtensor._do_increase_take">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor._do_increase_take">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">_do_increase_take</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">take</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Increases the take rate for a delegate&#39;s hotkey.</span>

<span class="sd">        This method sends a transaction to increase the take rate for a delegate&#39;s hotkey and retries the call up to</span>
<span class="sd">        three times with exponential backoff in case of failures.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet from which the transaction will be signed.</span>
<span class="sd">            hotkey_ss58 (str): The SS58 address of the delegate&#39;s hotkey.</span>
<span class="sd">            take (int): The new take rate to be set.</span>
<span class="sd">            wait_for_inclusion (bool, optional): Whether to wait for the transaction to be included in a block. Default is ``True``.</span>
<span class="sd">            wait_for_finalization (bool, optional): Whether to wait for the transaction to be finalized. Default is ``False``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the take rate increase is successful, ``False`` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">():</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span> <span class="k">as</span> <span class="n">substrate</span><span class="p">:</span>
                <span class="n">call</span> <span class="o">=</span> <span class="n">substrate</span><span class="o">.</span><span class="n">compose_call</span><span class="p">(</span>
                    <span class="n">call_module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
                    <span class="n">call_function</span><span class="o">=</span><span class="s2">&quot;increase_take&quot;</span><span class="p">,</span>
                    <span class="n">call_params</span><span class="o">=</span><span class="p">{</span>
                        <span class="s2">&quot;hotkey&quot;</span><span class="p">:</span> <span class="n">hotkey_ss58</span><span class="p">,</span>
                        <span class="s2">&quot;take&quot;</span><span class="p">:</span> <span class="n">take</span><span class="p">,</span>
                    <span class="p">},</span>
                <span class="p">)</span>
                <span class="n">extrinsic</span> <span class="o">=</span> <span class="n">substrate</span><span class="o">.</span><span class="n">create_signed_extrinsic</span><span class="p">(</span>
                    <span class="n">call</span><span class="o">=</span><span class="n">call</span><span class="p">,</span> <span class="n">keypair</span><span class="o">=</span><span class="n">wallet</span><span class="o">.</span><span class="n">coldkey</span>
                <span class="p">)</span>  <span class="c1"># sign with coldkey</span>
                <span class="n">response</span> <span class="o">=</span> <span class="n">substrate</span><span class="o">.</span><span class="n">submit_extrinsic</span><span class="p">(</span>
                    <span class="n">extrinsic</span><span class="p">,</span>
                    <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                    <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="c1"># We only wait here if we expect finalization.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">wait_for_finalization</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">wait_for_inclusion</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
                <span class="n">response</span><span class="o">.</span><span class="n">process_events</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">response</span><span class="o">.</span><span class="n">is_success</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">TakeError</span><span class="p">(</span><span class="n">format_error_message</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">error_message</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span></div>


<div class="viewcode-block" id="Subtensor._do_decrease_take">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor._do_decrease_take">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">_do_decrease_take</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;bittensor.wallet&quot;</span><span class="p">,</span>
        <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">take</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decreases the take rate for a delegate&#39;s hotkey.</span>

<span class="sd">        This method sends a transaction to decrease the take rate for a delegate&#39;s hotkey and retries the call up to</span>
<span class="sd">        three times with exponential backoff in case of failures.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet from which the transaction will be signed.</span>
<span class="sd">            hotkey_ss58 (str): The SS58 address of the delegate&#39;s hotkey.</span>
<span class="sd">            take (int): The new take rate to be set.</span>
<span class="sd">            wait_for_inclusion (bool, optional): Whether to wait for the transaction to be included in a block. Default is ``True``.</span>
<span class="sd">            wait_for_finalization (bool, optional): Whether to wait for the transaction to be finalized. Default is ``False``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the take rate decrease is successful, ``False`` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">():</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span> <span class="k">as</span> <span class="n">substrate</span><span class="p">:</span>
                <span class="n">call</span> <span class="o">=</span> <span class="n">substrate</span><span class="o">.</span><span class="n">compose_call</span><span class="p">(</span>
                    <span class="n">call_module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
                    <span class="n">call_function</span><span class="o">=</span><span class="s2">&quot;decrease_take&quot;</span><span class="p">,</span>
                    <span class="n">call_params</span><span class="o">=</span><span class="p">{</span>
                        <span class="s2">&quot;hotkey&quot;</span><span class="p">:</span> <span class="n">hotkey_ss58</span><span class="p">,</span>
                        <span class="s2">&quot;take&quot;</span><span class="p">:</span> <span class="n">take</span><span class="p">,</span>
                    <span class="p">},</span>
                <span class="p">)</span>
                <span class="n">extrinsic</span> <span class="o">=</span> <span class="n">substrate</span><span class="o">.</span><span class="n">create_signed_extrinsic</span><span class="p">(</span>
                    <span class="n">call</span><span class="o">=</span><span class="n">call</span><span class="p">,</span> <span class="n">keypair</span><span class="o">=</span><span class="n">wallet</span><span class="o">.</span><span class="n">coldkey</span>
                <span class="p">)</span>  <span class="c1"># sign with coldkey</span>
                <span class="n">response</span> <span class="o">=</span> <span class="n">substrate</span><span class="o">.</span><span class="n">submit_extrinsic</span><span class="p">(</span>
                    <span class="n">extrinsic</span><span class="p">,</span>
                    <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                    <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="c1"># We only wait here if we expect finalization.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">wait_for_finalization</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">wait_for_inclusion</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
                <span class="n">response</span><span class="o">.</span><span class="n">process_events</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">response</span><span class="o">.</span><span class="n">is_success</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">TakeError</span><span class="p">(</span><span class="n">format_error_message</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">error_message</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span></div>


    <span class="c1">##########</span>
    <span class="c1"># Legacy #</span>
    <span class="c1">##########</span>

<div class="viewcode-block" id="Subtensor.get_balance">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_balance">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">get_balance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Balance</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the token balance of a specific address within the Bittensor network. This function queries</span>
<span class="sd">        the blockchain to determine the amount of Tao held by a given account.</span>

<span class="sd">        Args:</span>
<span class="sd">            address (str): The Substrate address in ``ss58`` format.</span>
<span class="sd">            block (int, optional): The blockchain block number at which to perform the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Balance: The account balance at the specified block, represented as a Balance object.</span>

<span class="sd">        This function is important for monitoring account holdings and managing financial transactions</span>
<span class="sd">        within the Bittensor ecosystem. It helps in assessing the economic status and capacity of network participants.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>

            <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">_logger</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">():</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
                    <span class="n">module</span><span class="o">=</span><span class="s2">&quot;System&quot;</span><span class="p">,</span>
                    <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;Account&quot;</span><span class="p">,</span>
                    <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">address</span><span class="p">],</span>
                    <span class="n">block_hash</span><span class="o">=</span><span class="p">(</span>
                        <span class="kc">None</span> <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
                    <span class="p">),</span>
                <span class="p">)</span>

            <span class="n">result</span> <span class="o">=</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">RemainingScaleBytesNotEmptyException</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;Received a corrupted message. This likely points to an error with the network or subnet.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">Balance</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Balance</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">][</span><span class="s2">&quot;free&quot;</span><span class="p">])</span></div>


<div class="viewcode-block" id="Subtensor.get_current_block">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_current_block">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">get_current_block</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the current block number on the Bittensor blockchain. This function provides the latest block</span>
<span class="sd">        number, indicating the most recent state of the blockchain.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: The current chain block number.</span>

<span class="sd">        Knowing the current block number is essential for querying real-time data and performing time-sensitive</span>
<span class="sd">        operations on the blockchain. It serves as a reference point for network activities and data synchronization.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">_logger</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_block_number</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

        <span class="k">return</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span></div>


<div class="viewcode-block" id="Subtensor.get_balances">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_balances">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">get_balances</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Balance</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the token balances of all accounts within the Bittensor network as of a specific blockchain block.</span>
<span class="sd">        This function provides a comprehensive view of the token distribution among different accounts.</span>

<span class="sd">        Args:</span>
<span class="sd">            block (int, optional): The blockchain block number at which to perform the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dict[str, Balance]: A dictionary mapping each account&#39;s ``ss58`` address to its balance.</span>

<span class="sd">        This function is valuable for analyzing the overall economic landscape of the Bittensor network,</span>
<span class="sd">        including the distribution of financial resources and the financial status of network participants.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@retry</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">_logger</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_substrate_call_with_retry</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query_map</span><span class="p">(</span>
                <span class="n">module</span><span class="o">=</span><span class="s2">&quot;System&quot;</span><span class="p">,</span>
                <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;Account&quot;</span><span class="p">,</span>
                <span class="n">block_hash</span><span class="o">=</span><span class="p">(</span>
                    <span class="kc">None</span> <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
                <span class="p">),</span>
            <span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">make_substrate_call_with_retry</span><span class="p">()</span>
        <span class="n">return_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
            <span class="n">bal</span> <span class="o">=</span> <span class="n">Balance</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">][</span><span class="s2">&quot;free&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
            <span class="n">return_dict</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="n">bal</span>
        <span class="k">return</span> <span class="n">return_dict</span></div>


    <span class="c1"># TODO: check with the team if this is used anywhere externally. not in bittensor</span>
<div class="viewcode-block" id="Subtensor._null_neuron">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor._null_neuron">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_null_neuron</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">NeuronInfo</span><span class="p">:</span>
        <span class="n">neuron</span> <span class="o">=</span> <span class="n">NeuronInfo</span><span class="p">(</span>
            <span class="n">uid</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">netuid</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">active</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">stake</span><span class="o">=</span><span class="n">Balance</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">rank</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">emission</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">incentive</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">consensus</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">trust</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">validator_trust</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">dividends</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">last_update</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">validator_permit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">weights</span><span class="o">=</span><span class="p">[],</span>
            <span class="n">bonds</span><span class="o">=</span><span class="p">[],</span>
            <span class="n">prometheus_info</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">axon_info</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">is_null</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">coldkey</span><span class="o">=</span><span class="s2">&quot;000000000000000000000000000000000000000000000000&quot;</span><span class="p">,</span>
            <span class="n">hotkey</span><span class="o">=</span><span class="s2">&quot;000000000000000000000000000000000000000000000000&quot;</span><span class="p">,</span>
        <span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="k">return</span> <span class="n">neuron</span></div>


<div class="viewcode-block" id="Subtensor.get_block_hash">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_block_hash">[docs]</a>
    <span class="nd">@networking</span><span class="o">.</span><span class="n">ensure_connected</span>
    <span class="k">def</span> <span class="nf">get_block_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the hash of a specific block on the Bittensor blockchain. The block hash is a unique</span>
<span class="sd">        identifier representing the cryptographic hash of the block&#39;s content, ensuring its integrity and</span>
<span class="sd">        immutability.</span>

<span class="sd">        Args:</span>
<span class="sd">            block_id (int): The block number for which the hash is to be retrieved.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: The cryptographic hash of the specified block.</span>

<span class="sd">        The block hash is a fundamental aspect of blockchain technology, providing a secure reference to</span>
<span class="sd">        each block&#39;s data. It is crucial for verifying transactions, ensuring data consistency, and</span>
<span class="sd">        maintaining the trustworthiness of the blockchain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_block_hash</span><span class="p">(</span><span class="n">block_id</span><span class="o">=</span><span class="n">block_id</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_error_info_by_index">
<a class="viewcode-back" href="../../autoapi/bittensor/subtensor/index.html#bittensor.Subtensor.get_error_info_by_index">[docs]</a>
    <span class="k">def</span> <span class="nf">get_error_info_by_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">error_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the error name and description from the Subtensor error list.</span>

<span class="sd">        Args:</span>
<span class="sd">            error_index (int): The index of the error to retrieve.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[str, str]: A tuple containing the error name and description from substrate metadata. If the error index is not found, returns (&quot;Unknown Error&quot;, &quot;&quot;) and logs a warning.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">unknown_error</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Unknown Error&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subtensor_errors</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_subtensor_errors</span> <span class="o">=</span> <span class="n">get_subtensor_errors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="p">)</span>

        <span class="n">name</span><span class="p">,</span> <span class="n">description</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subtensor_errors</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">error_index</span><span class="p">),</span> <span class="n">unknown_error</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="n">unknown_error</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Subtensor returned an error with an unknown index: </span><span class="si">{</span><span class="n">error_index</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">name</span><span class="p">,</span> <span class="n">description</span></div>
</div>



<span class="c1"># TODO: remove this after fully migrate `bittensor.subtensor` to `bittensor.Subtensor` in `bittensor/__init__.py`</span>
<span class="n">subtensor</span> <span class="o">=</span> <span class="n">Subtensor</span>
</pre></div>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Opentensor Foundation
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2024, Opentensor Foundation.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>